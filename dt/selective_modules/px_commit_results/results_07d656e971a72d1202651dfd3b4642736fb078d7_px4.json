{"sha":"07d656e971a72d1202651dfd3b4642736fb078d7","node_id":"MDY6Q29tbWl0NTI5ODc5MDowN2Q2NTZlOTcxYTcyZDEyMDI2NTFkZmQzYjQ2NDI3MzZmYjA3OGQ3","commit":{"author":{"name":"Julian Kent","email":"julian@auterion.com","date":"2019-09-24T15:00:04Z"},"committer":{"name":"GitHub","email":"noreply@github.com","date":"2019-09-24T15:00:04Z"},"message":"Guidance feature for Collision Prevention (#13017)\n\n* add guidance\r\n\r\n* remove COL_PREV_ANG and replace with COL_PREV_CNG\r\n\r\n* safe max ranges per bin\r\n\r\n* increase default value for colprev delay to account for tracking delay\r\n\r\n* update parameter description\r\n\r\n* fix and extend testing\r\n\r\n* add handling for overlapping sensor data\r\n\r\n* fix decision process for overlapping sensors","tree":{"sha":"9f837327fd717f645574d61d4389ca8c05fea922","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/9f837327fd717f645574d61d4389ca8c05fea922"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/07d656e971a72d1202651dfd3b4642736fb078d7","comment_count":0,"verification":{"verified":true,"reason":"valid","signature":"-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdii90CRBK7hj4Ov3rIwAAdHIIAFIGi+AZuU2TGhvXt2cPLGTw\ncYxUA91iqZVn/XS+WZBNAhBiTn7Vd3NHnbkBf1jvmh8VO+9ZsHYvk/s5gsORz1Le\nIE0elDckvGYt6VTEIOMc0EQZPkbypTK1CN2H+ZhqZtlCwr3mLW2UGG83UUTuVMKl\nErCd7dU00GCerUIaTiVv/wNHj07ukWFBqlFd3UXupbf8OAOMpNv2vYydL7PZ9Bx9\nR7QJ9NV2HUVNDFYTOHEWr2yxMFb5enhWMCT8jbIOgnJQpQl7g3ibDJyIxOIml1KN\nCbzyUHKBw/E4PjZ+RDAO4cAYMX+u9E2qiSOv96Qt339pKiynhzPPyy19/pEYIqk=\n=dFnC\n-----END PGP SIGNATURE-----\n","payload":"tree 9f837327fd717f645574d61d4389ca8c05fea922\nparent 61398122934850b5ad7f96970e1018d34f61bb2a\nauthor Julian Kent <julian@auterion.com> 1569337204 +0200\ncommitter GitHub <noreply@github.com> 1569337204 +0200\n\nGuidance feature for Collision Prevention (#13017)\n\n* add guidance\r\n\r\n* remove COL_PREV_ANG and replace with COL_PREV_CNG\r\n\r\n* safe max ranges per bin\r\n\r\n* increase default value for colprev delay to account for tracking delay\r\n\r\n* update parameter description\r\n\r\n* fix and extend testing\r\n\r\n* add handling for overlapping sensor data\r\n\r\n* fix decision process for overlapping sensors\r\n"}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/07d656e971a72d1202651dfd3b4642736fb078d7","html_url":"https://github.com/PX4/PX4-Autopilot/commit/07d656e971a72d1202651dfd3b4642736fb078d7","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/07d656e971a72d1202651dfd3b4642736fb078d7/comments","author":null,"committer":{"login":"web-flow","id":19864447,"node_id":"MDQ6VXNlcjE5ODY0NDQ3","avatar_url":"https://avatars.githubusercontent.com/u/19864447?v=4","gravatar_id":"","url":"https://api.github.com/users/web-flow","html_url":"https://github.com/web-flow","followers_url":"https://api.github.com/users/web-flow/followers","following_url":"https://api.github.com/users/web-flow/following{/other_user}","gists_url":"https://api.github.com/users/web-flow/gists{/gist_id}","starred_url":"https://api.github.com/users/web-flow/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/web-flow/subscriptions","organizations_url":"https://api.github.com/users/web-flow/orgs","repos_url":"https://api.github.com/users/web-flow/repos","events_url":"https://api.github.com/users/web-flow/events{/privacy}","received_events_url":"https://api.github.com/users/web-flow/received_events","type":"User","site_admin":false},"parents":[{"sha":"61398122934850b5ad7f96970e1018d34f61bb2a","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/61398122934850b5ad7f96970e1018d34f61bb2a","html_url":"https://github.com/PX4/PX4-Autopilot/commit/61398122934850b5ad7f96970e1018d34f61bb2a"}],"stats":{"total":442,"additions":409,"deletions":33},"files":[{"sha":"b50054dc8d4c9fd7cd551404c8373a80dffdb580","filename":"src/lib/CollisionPrevention/CollisionPrevention.cpp","status":"modified","additions":116,"deletions":14,"changes":130,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/07d656e971a72d1202651dfd3b4642736fb078d7/src%2Flib%2FCollisionPrevention%2FCollisionPrevention.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/07d656e971a72d1202651dfd3b4642736fb078d7/src%2Flib%2FCollisionPrevention%2FCollisionPrevention.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Flib%2FCollisionPrevention%2FCollisionPrevention.cpp?ref=07d656e971a72d1202651dfd3b4642736fb078d7","patch":"@@ -79,6 +79,7 @@ CollisionPrevention::CollisionPrevention(ModuleParams *parent) :\n \n \tfor (uint32_t i = 0 ; i < internal_bins; i++) {\n \t\t_data_timestamps[i] = current_time;\n+\t\t_data_maxranges[i] = 0;\n \t\t_obstacle_map_body_frame.distances[i] = UINT16_MAX;\n \t}\n }\n@@ -118,8 +119,11 @@ void CollisionPrevention::_addObstacleSensorData(const obstacle_distance_s &obst\n \n \t\t\t//add all data points inside to FOV\n \t\t\tif (obstacle.distances[msg_index] != UINT16_MAX) {\n-\t\t\t\t_obstacle_map_body_frame.distances[i] = obstacle.distances[msg_index];\n-\t\t\t\t_data_timestamps[i] = _obstacle_map_body_frame.timestamp;\n+\t\t\t\tif (_enterData(i, obstacle.max_distance * 0.01f, obstacle.distances[msg_index] * 0.01f)) {\n+\t\t\t\t\t_obstacle_map_body_frame.distances[i] = obstacle.distances[msg_index];\n+\t\t\t\t\t_data_timestamps[i] = _obstacle_map_body_frame.timestamp;\n+\t\t\t\t\t_data_maxranges[i] = obstacle.max_distance;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t}\n@@ -134,8 +138,12 @@ void CollisionPrevention::_addObstacleSensorData(const obstacle_distance_s &obst\n \n \t\t\t//add all data points inside to FOV\n \t\t\tif (obstacle.distances[msg_index] != UINT16_MAX) {\n-\t\t\t\t_obstacle_map_body_frame.distances[i] = obstacle.distances[msg_index];\n-\t\t\t\t_data_timestamps[i] = _obstacle_map_body_frame.timestamp;\n+\n+\t\t\t\tif (_enterData(i, obstacle.max_distance * 0.01f, obstacle.distances[msg_index] * 0.01f)) {\n+\t\t\t\t\t_obstacle_map_body_frame.distances[i] = obstacle.distances[msg_index];\n+\t\t\t\t\t_data_timestamps[i] = _obstacle_map_body_frame.timestamp;\n+\t\t\t\t\t_data_maxranges[i] = obstacle.max_distance;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t}\n@@ -146,6 +154,37 @@ void CollisionPrevention::_addObstacleSensorData(const obstacle_distance_s &obst\n \t}\n }\n \n+\n+bool CollisionPrevention::_enterData(int map_index, float sensor_range, float sensor_reading)\n+{\n+\t//use data from this sensor if:\n+\t//1. this sensor data is in range, the bin contains already valid data and this data is coming from the same or less range sensor\n+\t//2. this sensor data is in range, and the last reading was out of range\n+\t//3. this sensor data is out of range, the last reading was as well and this is the sensor with longest range\n+\t//4. this sensor data is out of range, the last reading was valid and coming from the same sensor\n+\n+\tuint16_t sensor_range_cm = (int)(100 * sensor_range); //convert to cm\n+\n+\tif (sensor_reading < sensor_range) {\n+\t\tif ((_obstacle_map_body_frame.distances[map_index] < _data_maxranges[map_index]\n+\t\t     && sensor_range_cm <= _data_maxranges[map_index])\n+\t\t    || _obstacle_map_body_frame.distances[map_index] >= _data_maxranges[map_index]) {\n+\t\t\treturn true;\n+\n+\t\t}\n+\n+\t} else {\n+\t\tif ((_obstacle_map_body_frame.distances[map_index] >= _data_maxranges[map_index]\n+\t\t     && sensor_range_cm >= _data_maxranges[map_index])\n+\t\t    || (_obstacle_map_body_frame.distances[map_index] < _data_maxranges[map_index]\n+\t\t\t&& sensor_range_cm == _data_maxranges[map_index])) {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\treturn false;\n+}\n+\n void CollisionPrevention::_updateObstacleMap()\n {\n \t_sub_vehicle_attitude.update();\n@@ -223,14 +262,64 @@ void CollisionPrevention::_addDistanceSensorData(distance_sensor_s &distance_sen\n \t\tattitude_sensor_frame.rotate(Vector3f(0.f, 0.f, sensor_yaw_body_rad));\n \t\tfloat sensor_dist_scale = cosf(Eulerf(attitude_sensor_frame).theta());\n \n+\t\tif (distance_reading < distance_sensor.max_distance) {\n+\t\t\tdistance_reading = distance_reading * sensor_dist_scale;\n+\t\t}\n+\n+\t\tuint16_t sensor_range = (int)(100 * distance_sensor.max_distance); //convert to cm\n+\n \t\tfor (int bin = lower_bound; bin <= upper_bound; ++bin) {\n \t\t\tint wrapped_bin = wrap_bin(bin);\n \n-\t\t\t// compensate measurement for vehicle tilt and convert to cm\n-\t\t\t_obstacle_map_body_frame.distances[wrapped_bin] = (int)(100 * distance_reading * sensor_dist_scale);\n-\t\t\t_data_timestamps[wrapped_bin] = _obstacle_map_body_frame.timestamp;\n+\t\t\tif (_enterData(wrapped_bin, distance_sensor.max_distance, distance_reading)) {\n+\t\t\t\t_obstacle_map_body_frame.distances[wrapped_bin] = (int)(100 * distance_reading);\n+\t\t\t\t_data_timestamps[wrapped_bin] = _obstacle_map_body_frame.timestamp;\n+\t\t\t\t_data_maxranges[wrapped_bin] = sensor_range;\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+void CollisionPrevention::_adaptSetpointDirection(Vector2f &setpoint_dir, int &setpoint_index,\n+\t\tfloat vehicle_yaw_angle_rad)\n+{\n+\tfloat col_prev_d = _param_mpc_col_prev_d.get();\n+\tint guidance_bins = floor(_param_mpc_col_prev_cng.get() / INTERNAL_MAP_INCREMENT_DEG);\n+\tint sp_index_original = setpoint_index;\n+\tfloat best_cost = 9999.f;\n+\n+\tfor (int i = sp_index_original - guidance_bins; i <= sp_index_original + guidance_bins; i++) {\n+\n+\t\t//apply moving average filter to the distance array to be able to center in larger gaps\n+\t\tint filter_size = 1;\n+\t\tfloat mean_dist = 0;\n+\n+\t\tfor (int j =  i - filter_size; j <= i + filter_size; j++) {\n+\t\t\tint bin = wrap_bin(j);\n+\n+\t\t\tif (_obstacle_map_body_frame.distances[bin] == UINT16_MAX) {\n+\t\t\t\tmean_dist += col_prev_d * 100.f;\n+\n+\t\t\t} else {\n+\t\t\t\tmean_dist += _obstacle_map_body_frame.distances[bin];\n+\t\t\t}\n+\t\t}\n+\n+\t\tint bin = wrap_bin(i);\n+\t\tmean_dist = mean_dist / (2.f * filter_size + 1.f);\n+\t\tfloat deviation_cost = col_prev_d * 50.f * std::abs(i - sp_index_original);\n+\t\tfloat bin_cost = deviation_cost - mean_dist - _obstacle_map_body_frame.distances[bin];\n+\n+\t\tif (bin_cost < best_cost && _obstacle_map_body_frame.distances[bin] != UINT16_MAX) {\n+\t\t\tbest_cost = bin_cost;\n+\n+\t\t\tfloat angle = math::radians((float)bin * INTERNAL_MAP_INCREMENT_DEG + _obstacle_map_body_frame.angle_offset);\n+\t\t\tangle  = wrap_2pi(vehicle_yaw_angle_rad + angle);\n+\t\t\tsetpoint_dir = {cosf(angle), sinf(angle)};\n+\t\t\tsetpoint_index = bin;\n \t\t}\n \t}\n+\n }\n \n \n@@ -242,7 +331,6 @@ void CollisionPrevention::_calculateConstrainedSetpoint(Vector2f &setpoint,\n \t//read parameters\n \tfloat col_prev_d = _param_mpc_col_prev_d.get();\n \tfloat col_prev_dly = _param_mpc_col_prev_dly.get();\n-\tfloat col_prev_ang_rad = math::radians(_param_mpc_col_prev_ang.get());\n \tfloat xy_p = _param_mpc_xy_p.get();\n \tfloat max_jerk = _param_mpc_jerk_max.get();\n \tfloat max_accel = _param_mpc_acc_hor.get();\n@@ -264,6 +352,10 @@ void CollisionPrevention::_calculateConstrainedSetpoint(Vector2f &setpoint,\n \t\t\tfloat sp_angle_with_offset_deg = wrap_360(math::degrees(sp_angle_body_frame) - _obstacle_map_body_frame.angle_offset);\n \t\t\tint sp_index = floor(sp_angle_with_offset_deg / INTERNAL_MAP_INCREMENT_DEG);\n \n+\t\t\t//change setpoint direction slightly (max by _param_mpc_col_prev_cng degrees) to help guide through narrow gaps\n+\t\t\t_adaptSetpointDirection(setpoint_dir, sp_index, vehicle_yaw_angle_rad);\n+\n+\t\t\t//limit speed for safe flight\n \t\t\tfor (int i = 0; i < INTERNAL_MAP_USED_BINS; i++) { //disregard unused bins at the end of the message\n \n \t\t\t\t//delete stale values\n@@ -274,6 +366,7 @@ void CollisionPrevention::_calculateConstrainedSetpoint(Vector2f &setpoint,\n \t\t\t\t}\n \n \t\t\t\tfloat distance = _obstacle_map_body_frame.distances[i] * 0.01f; //convert to meters\n+\t\t\t\tfloat max_range = _data_maxranges[i] * 0.01f; //convert to meters\n \t\t\t\tfloat angle = math::radians((float)i * INTERNAL_MAP_INCREMENT_DEG + _obstacle_map_body_frame.angle_offset);\n \n \t\t\t\t// convert from body to local frame in the range [0, 2*pi]\n@@ -285,16 +378,25 @@ void CollisionPrevention::_calculateConstrainedSetpoint(Vector2f &setpoint,\n \t\t\t\tif (_obstacle_map_body_frame.distances[i] > _obstacle_map_body_frame.min_distance\n \t\t\t\t    && _obstacle_map_body_frame.distances[i] < UINT16_MAX) {\n \n-\t\t\t\t\tif (setpoint_dir.dot(bin_direction) > 0\n-\t\t\t\t\t    && setpoint_dir.dot(bin_direction) > cosf(col_prev_ang_rad)) {\n+\t\t\t\t\tif (setpoint_dir.dot(bin_direction) > 0) {\n \t\t\t\t\t\t//calculate max allowed velocity with a P-controller (same gain as in the position controller)\n \t\t\t\t\t\tfloat curr_vel_parallel = math::max(0.f, curr_vel.dot(bin_direction));\n-\t\t\t\t\t\tfloat delay_distance = curr_vel_parallel * (col_prev_dly + data_age * 1e-6f);\n+\t\t\t\t\t\tfloat delay_distance = curr_vel_parallel * col_prev_dly;\n+\n+\t\t\t\t\t\tif (distance < max_range) {\n+\t\t\t\t\t\t\tdelay_distance += curr_vel_parallel * (data_age * 1e-6f);\n+\t\t\t\t\t\t}\n+\n \t\t\t\t\t\tfloat stop_distance =  math::max(0.f, distance - min_dist_to_keep - delay_distance);\n \t\t\t\t\t\tfloat vel_max_posctrl = xy_p * stop_distance;\n+\n \t\t\t\t\t\tfloat vel_max_smooth = math::trajectory::computeMaxSpeedFromBrakingDistance(max_jerk, max_accel, stop_distance);\n-\t\t\t\t\t\tVector2f  vel_max_vec = bin_direction * math::min(vel_max_posctrl, vel_max_smooth);\n-\t\t\t\t\t\tfloat vel_max_bin = vel_max_vec.dot(setpoint_dir);\n+\t\t\t\t\t\tfloat projection = bin_direction.dot(setpoint_dir);\n+\t\t\t\t\t\tfloat vel_max_bin = vel_max;\n+\n+\t\t\t\t\t\tif (projection > 0.01f) {\n+\t\t\t\t\t\t\tvel_max_bin = math::min(vel_max_posctrl, vel_max_smooth) / projection;\n+\t\t\t\t\t\t}\n \n \t\t\t\t\t\t//constrain the velocity\n \t\t\t\t\t\tif (vel_max_bin >= 0) {\n@@ -311,7 +413,7 @@ void CollisionPrevention::_calculateConstrainedSetpoint(Vector2f &setpoint,\n \t\t}\n \n \t} else {\n-\t\t// if distance data are stale, switch to Loiter\n+\t\t// if distance data is stale, switch to Loiter\n \t\t_publishVehicleCmdDoLoiter();\n \t\tmavlink_log_critical(&_mavlink_log_pub, \"No range data received, loitering.\");\n \t}"},{"sha":"df444e815a9898b4e433e64e0fbb577d070ecc4c","filename":"src/lib/CollisionPrevention/CollisionPrevention.hpp","status":"modified","additions":22,"deletions":4,"changes":26,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/07d656e971a72d1202651dfd3b4642736fb078d7/src%2Flib%2FCollisionPrevention%2FCollisionPrevention.hpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/07d656e971a72d1202651dfd3b4642736fb078d7/src%2Flib%2FCollisionPrevention%2FCollisionPrevention.hpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Flib%2FCollisionPrevention%2FCollisionPrevention.hpp?ref=07d656e971a72d1202651dfd3b4642736fb078d7","patch":"@@ -84,15 +84,35 @@ class CollisionPrevention : public ModuleParams\n \n \tobstacle_distance_s _obstacle_map_body_frame {};\n \tuint64_t _data_timestamps[sizeof(_obstacle_map_body_frame.distances) / sizeof(_obstacle_map_body_frame.distances[0])];\n+\tuint16_t _data_maxranges[sizeof(_obstacle_map_body_frame.distances) / sizeof(\n+\t\t\t\t\t\t\t\t\t\t    _obstacle_map_body_frame.distances[0])]; /**< in cm */\n \n-\tvoid _addDistanceSensorData(distance_sensor_s &distance_sensor, const matrix::Quatf &attitude);\n+\tvoid _addDistanceSensorData(distance_sensor_s &distance_sensor, const matrix::Quatf &vehicle_attitude);\n \n \t/**\n \t * Updates obstacle distance message with measurement from offboard\n \t * @param obstacle, obstacle_distance message to be updated\n \t */\n \tvoid _addObstacleSensorData(const obstacle_distance_s &obstacle, const matrix::Quatf &vehicle_attitude);\n \n+\t/**\n+\t * Computes an adaption to the setpoint direction to guide towards free space\n+\t * @param setpoint_dir, setpoint direction before collision prevention intervention\n+\t * @param setpoint_index, index of the setpoint in the internal obstacle map\n+\t * @param vehicle_yaw_angle_rad, vehicle orientation\n+\t */\n+\tvoid _adaptSetpointDirection(matrix::Vector2f &setpoint_dir, int &setpoint_index, float vehicle_yaw_angle_rad);\n+\n+\t/**\n+\t * Determines whether a new sensor measurement is used\n+\t * @param map_index, index of the bin in the internal map the measurement belongs in\n+\t * @param sensor_range, max range of the sensor in meters\n+\t * @param sensor_reading, distance measurement in meters\n+\t */\n+\tbool _enterData(int map_index, float sensor_range, float sensor_reading);\n+\n+\n+\t//Timing functions. Necessary to mock time in the tests\n \tvirtual hrt_abstime getTime();\n \tvirtual hrt_abstime getElapsedTime(const hrt_abstime *ptr);\n \n@@ -115,7 +135,7 @@ class CollisionPrevention : public ModuleParams\n \n \tDEFINE_PARAMETERS(\n \t\t(ParamFloat<px4::params::MPC_COL_PREV_D>) _param_mpc_col_prev_d, /**< collision prevention keep minimum distance */\n-\t\t(ParamFloat<px4::params::MPC_COL_PREV_ANG>) _param_mpc_col_prev_ang, /**< collision prevention detection angle */\n+\t\t(ParamFloat<px4::params::MPC_COL_PREV_CNG>) _param_mpc_col_prev_cng, /**< collision prevention change setpoint angle */\n \t\t(ParamFloat<px4::params::MPC_XY_P>) _param_mpc_xy_p, /**< p gain from position controller*/\n \t\t(ParamFloat<px4::params::MPC_COL_PREV_DLY>) _param_mpc_col_prev_dly, /**< delay of the range measurement data*/\n \t\t(ParamFloat<px4::params::MPC_JERK_MAX>) _param_mpc_jerk_max, /**< vehicle maximum jerk*/\n@@ -153,8 +173,6 @@ class CollisionPrevention : public ModuleParams\n \t\treturn offset;\n \t}\n \n-\n-\n \t/**\n \t * Computes collision free setpoints\n \t * @param setpoint, setpoint before collision prevention intervention"},{"sha":"25a31ea4c219af46c2b8c9331ba8cb8e26a97516","filename":"src/lib/CollisionPrevention/CollisionPreventionTest.cpp","status":"modified","additions":266,"deletions":10,"changes":276,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/07d656e971a72d1202651dfd3b4642736fb078d7/src%2Flib%2FCollisionPrevention%2FCollisionPreventionTest.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/07d656e971a72d1202651dfd3b4642736fb078d7/src%2Flib%2FCollisionPrevention%2FCollisionPreventionTest.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Flib%2FCollisionPrevention%2FCollisionPreventionTest.cpp?ref=07d656e971a72d1202651dfd3b4642736fb078d7","patch":"@@ -60,6 +60,15 @@ class TestCollisionPrevention : public CollisionPrevention\n \t{\n \t\t_addObstacleSensorData(obstacle, attitude);\n \t}\n+\tvoid test_adaptSetpointDirection(matrix::Vector2f &setpoint_dir, int &setpoint_index,\n+\t\t\t\t\t float vehicle_yaw_angle_rad)\n+\t{\n+\t\t_adaptSetpointDirection(setpoint_dir, setpoint_index, vehicle_yaw_angle_rad);\n+\t}\n+\tbool test_enterData(int map_index, float sensor_range, float sensor_reading)\n+\t{\n+\t\treturn _enterData(map_index, sensor_range, sensor_reading);\n+\t}\n };\n \n class TestTimingCollisionPrevention : public TestCollisionPrevention\n@@ -176,7 +185,7 @@ TEST_F(CollisionPreventionTest, testBehaviorOnWithObstacleMessage)\n \tEXPECT_FLOAT_EQ(cp.getObstacleMap().max_distance, 10000);\n \n \tEXPECT_FLOAT_EQ(0.f, modified_setpoint1.norm()) << modified_setpoint1(0) << \",\" << modified_setpoint1(1);\n-\tEXPECT_EQ(original_setpoint2, modified_setpoint2);\n+\tEXPECT_FLOAT_EQ(original_setpoint2.norm(), modified_setpoint2.norm());\n }\n \n TEST_F(CollisionPreventionTest, testBehaviorOnWithDistanceMessage)\n@@ -303,7 +312,8 @@ TEST_F(CollisionPreventionTest, testPurgeOldData)\n \n \t\tif (i < 6) {\n \t\t\t// THEN: If the data is new enough, the velocity setpoint should stay the same as the input\n-\t\t\tEXPECT_EQ(original_setpoint, modified_setpoint);\n+\t\t\t// Note: direction will change slightly due to guidance\n+\t\t\tEXPECT_EQ(original_setpoint.norm(), modified_setpoint.norm());\n \n \t\t} else {\n \t\t\t// THEN: If the data is expired, the velocity setpoint should be cut down to zero because there is no data\n@@ -404,16 +414,16 @@ TEST_F(CollisionPreventionTest, outsideFOV)\n \t\torb_publish(ORB_ID(obstacle_distance), obstacle_distance_pub, &message);\n \t\tcp.modifySetpoint(modified_setpoint, max_speed, curr_pos, curr_vel);\n \n-\t\tif (angle_deg > 50.f && angle_deg < 230.f) {\n-\t\t\t// THEN: inside the FOV the setpoint should be limited\n-\t\t\tEXPECT_GT(modified_setpoint.norm(), 0.f);\n-\t\t\tEXPECT_LT(modified_setpoint.norm(), 10.f);\n+\t\t//THEN: if the resulting setpoint demands velocities bigger zero, it must lie inside the FOV\n+\t\tfloat setpoint_length = modified_setpoint.norm();\n \n-\t\t} else {\n-\t\t\t// THEN: outside the FOV the setpoint should be clamped to zero\n-\t\t\tEXPECT_FLOAT_EQ(modified_setpoint.norm(), 0.f);\n+\t\tif (setpoint_length > 0.f) {\n+\t\t\tmatrix::Vector2f setpoint_dir = modified_setpoint / setpoint_length;\n+\t\t\tfloat sp_angle_body_frame = atan2(setpoint_dir(1), setpoint_dir(0));\n+\t\t\tfloat sp_angle_deg = math::degrees(matrix::wrap_2pi(sp_angle_body_frame));\n+\t\t\tEXPECT_GT(sp_angle_deg, 45.f);\n+\t\t\tEXPECT_LT(sp_angle_deg, 225.f);\n \t\t}\n-\n \t}\n \n \torb_unadvertise(obstacle_distance_pub);\n@@ -804,3 +814,249 @@ TEST_F(CollisionPreventionTest, addObstacleSensorData_resolution_offset)\n \t\tcp.getObstacleMap().distances[i] = UINT16_MAX;\n \t}\n }\n+\n+TEST_F(CollisionPreventionTest, adaptSetpointDirection_distinct_minimum)\n+{\n+\t// GIVEN: a vehicle attitude and obstacle distance message\n+\tTestCollisionPrevention cp;\n+\tcp.getObstacleMap().increment = 10.f;\n+\tobstacle_distance_s obstacle_msg {};\n+\tobstacle_msg.frame = obstacle_msg.MAV_FRAME_GLOBAL; //north aligned\n+\tobstacle_msg.increment = 10.f;\n+\tobstacle_msg.min_distance = 20;\n+\tobstacle_msg.max_distance = 2000;\n+\tobstacle_msg.angle_offset = 0.f;\n+\n+\tmatrix::Quaternion<float> vehicle_attitude(1, 0, 0, 0); //unit transform\n+\tfloat vehicle_yaw_angle_rad = matrix::Eulerf(vehicle_attitude).psi();\n+\n+\t//obstacle at 0-30 deg world frame, distance 5 meters\n+\tmemset(&obstacle_msg.distances[0], UINT16_MAX, sizeof(obstacle_msg.distances));\n+\n+\tfor (int i = 0; i < 7 ; i++) {\n+\t\tobstacle_msg.distances[i] = 500;\n+\t}\n+\n+\tobstacle_msg.distances[2] = 1000;\n+\n+\t//define setpoint\n+\tmatrix::Vector2f setpoint_dir(1, 0);\n+\tfloat sp_angle_body_frame = atan2f(setpoint_dir(1), setpoint_dir(0)) - vehicle_yaw_angle_rad;\n+\tfloat sp_angle_with_offset_deg = matrix::wrap(math::degrees(sp_angle_body_frame) - cp.getObstacleMap().angle_offset,\n+\t\t\t\t\t 0.f, 360.f);\n+\tint sp_index = floor(sp_angle_with_offset_deg / cp.getObstacleMap().increment);\n+\n+\t//set parameter\n+\tparam_t param = param_handle(px4::params::MPC_COL_PREV_D);\n+\tfloat value = 3; // try to keep 10m away from obstacles\n+\tparam_set(param, &value);\n+\tcp.paramsChanged();\n+\n+\t//WHEN: we add distance sensor data\n+\tcp.test_addObstacleSensorData(obstacle_msg, vehicle_attitude);\n+\tcp.test_adaptSetpointDirection(setpoint_dir, sp_index, vehicle_yaw_angle_rad);\n+\n+\t//THEN: the setpoint direction should be modified correctly\n+\tEXPECT_EQ(sp_index, 2);\n+\tEXPECT_FLOAT_EQ(setpoint_dir(0), 0.93969262);\n+\tEXPECT_FLOAT_EQ(setpoint_dir(1), 0.34202012);\n+}\n+\n+TEST_F(CollisionPreventionTest, adaptSetpointDirection_flat_minimum)\n+{\n+\t// GIVEN: a vehicle attitude and obstacle distance message\n+\tTestCollisionPrevention cp;\n+\tcp.getObstacleMap().increment = 10.f;\n+\tobstacle_distance_s obstacle_msg {};\n+\tobstacle_msg.frame = obstacle_msg.MAV_FRAME_GLOBAL; //north aligned\n+\tobstacle_msg.increment = 10.f;\n+\tobstacle_msg.min_distance = 20;\n+\tobstacle_msg.max_distance = 2000;\n+\tobstacle_msg.angle_offset = 0.f;\n+\n+\tmatrix::Quaternion<float> vehicle_attitude(1, 0, 0, 0); //unit transform\n+\tfloat vehicle_yaw_angle_rad = matrix::Eulerf(vehicle_attitude).psi();\n+\n+\t//obstacle at 0-30 deg world frame, distance 5 meters\n+\tmemset(&obstacle_msg.distances[0], UINT16_MAX, sizeof(obstacle_msg.distances));\n+\n+\tfor (int i = 0; i < 7 ; i++) {\n+\t\tobstacle_msg.distances[i] = 500;\n+\t}\n+\n+\tobstacle_msg.distances[1] = 1000;\n+\tobstacle_msg.distances[2] = 1000;\n+\tobstacle_msg.distances[3] = 1000;\n+\n+\t//define setpoint\n+\tmatrix::Vector2f setpoint_dir(1, 0);\n+\tfloat sp_angle_body_frame = atan2f(setpoint_dir(1), setpoint_dir(0)) - vehicle_yaw_angle_rad;\n+\tfloat sp_angle_with_offset_deg = matrix::wrap(math::degrees(sp_angle_body_frame) - cp.getObstacleMap().angle_offset,\n+\t\t\t\t\t 0.f, 360.f);\n+\tint sp_index = floor(sp_angle_with_offset_deg / cp.getObstacleMap().increment);\n+\n+\t//set parameter\n+\tparam_t param = param_handle(px4::params::MPC_COL_PREV_D);\n+\tfloat value = 3; // try to keep 10m away from obstacles\n+\tparam_set(param, &value);\n+\tcp.paramsChanged();\n+\n+\t//WHEN: we add distance sensor data\n+\tcp.test_addObstacleSensorData(obstacle_msg, vehicle_attitude);\n+\tcp.test_adaptSetpointDirection(setpoint_dir, sp_index, vehicle_yaw_angle_rad);\n+\n+\t//THEN: the setpoint direction should be modified correctly\n+\tEXPECT_EQ(sp_index, 2);\n+\tEXPECT_FLOAT_EQ(setpoint_dir(0), 0.93969262);\n+\tEXPECT_FLOAT_EQ(setpoint_dir(1), 0.34202012);\n+}\n+\n+TEST_F(CollisionPreventionTest, overlappingSensors)\n+{\n+\t// GIVEN: a simple setup condition\n+\tTestCollisionPrevention cp;\n+\tmatrix::Vector2f original_setpoint(10, 0);\n+\tfloat max_speed = 3;\n+\tmatrix::Vector2f curr_pos(0, 0);\n+\tmatrix::Vector2f curr_vel(2, 0);\n+\tvehicle_attitude_s attitude;\n+\tattitude.timestamp = hrt_absolute_time();\n+\tattitude.q[0] = 1.0f;\n+\tattitude.q[1] = 0.0f;\n+\tattitude.q[2] = 0.0f;\n+\tattitude.q[3] = 0.0f;\n+\n+\t// AND: a parameter handle\n+\tparam_t param = param_handle(px4::params::MPC_COL_PREV_D);\n+\tfloat value = 10; // try to keep 10m distance\n+\tparam_set(param, &value);\n+\tcp.paramsChanged();\n+\n+\t// AND: an obstacle message for a short range and a long range sensor\n+\tobstacle_distance_s short_range_msg, short_range_msg_no_obstacle, long_range_msg;\n+\tmemset(&short_range_msg, 0xDEAD, sizeof(short_range_msg));\n+\tshort_range_msg.frame = short_range_msg.MAV_FRAME_GLOBAL; //north aligned\n+\tshort_range_msg.angle_offset = 0;\n+\tshort_range_msg.timestamp = hrt_absolute_time();\n+\tint distances_array_size = sizeof(short_range_msg.distances) / sizeof(short_range_msg.distances[0]);\n+\tshort_range_msg.increment = 360 / distances_array_size;\n+\tlong_range_msg = short_range_msg;\n+\tlong_range_msg.min_distance = 100;\n+\tlong_range_msg.max_distance = 1000;\n+\tshort_range_msg.min_distance = 20;\n+\tshort_range_msg.max_distance = 200;\n+\tshort_range_msg_no_obstacle = short_range_msg;\n+\n+\n+\tfor (int i = 0; i < distances_array_size; i++) {\n+\t\tif (i < 10) {\n+\t\t\tshort_range_msg_no_obstacle.distances[i] = 201;\n+\t\t\tshort_range_msg.distances[i] = 150;\n+\t\t\tlong_range_msg.distances[i] = 500;\n+\n+\t\t} else {\n+\t\t\tshort_range_msg_no_obstacle.distances[i] = UINT16_MAX;\n+\t\t\tshort_range_msg.distances[i] = UINT16_MAX;\n+\t\t\tlong_range_msg.distances[i] = UINT16_MAX;\n+\t\t}\n+\t}\n+\n+\n+\t// CASE 1\n+\t//WHEN: we publish the long range sensor message\n+\torb_advert_t obstacle_distance_pub = orb_advertise(ORB_ID(obstacle_distance), &long_range_msg);\n+\torb_advert_t vehicle_attitude_pub = orb_advertise(ORB_ID(vehicle_attitude), &attitude);\n+\torb_publish(ORB_ID(obstacle_distance), obstacle_distance_pub, &long_range_msg);\n+\torb_publish(ORB_ID(vehicle_attitude), vehicle_attitude_pub, &attitude);\n+\tmatrix::Vector2f modified_setpoint = original_setpoint;\n+\tcp.modifySetpoint(modified_setpoint, max_speed, curr_pos, curr_vel);\n+\n+\t// THEN: the internal map data should contain the long range measurement\n+\tEXPECT_EQ(500, cp.getObstacleMap().distances[2]);\n+\n+\t// CASE 2\n+\t// WHEN: we publish the short range message followed by a long range message\n+\tshort_range_msg.timestamp = hrt_absolute_time();\n+\torb_publish(ORB_ID(obstacle_distance), obstacle_distance_pub, &short_range_msg);\n+\tcp.modifySetpoint(modified_setpoint, max_speed, curr_pos, curr_vel);\n+\tlong_range_msg.timestamp = hrt_absolute_time();\n+\torb_publish(ORB_ID(obstacle_distance), obstacle_distance_pub, &long_range_msg);\n+\tcp.modifySetpoint(modified_setpoint, max_speed, curr_pos, curr_vel);\n+\n+\t// THEN: the internal map data should contain the short range measurement\n+\tEXPECT_EQ(150, cp.getObstacleMap().distances[2]);\n+\n+\t// CASE 3\n+\t// WHEN: we publish the short range message with values out of range followed by a long range message\n+\tshort_range_msg_no_obstacle.timestamp = hrt_absolute_time();\n+\torb_publish(ORB_ID(obstacle_distance), obstacle_distance_pub, &short_range_msg_no_obstacle);\n+\tcp.modifySetpoint(modified_setpoint, max_speed, curr_pos, curr_vel);\n+\tlong_range_msg.timestamp = hrt_absolute_time();\n+\torb_publish(ORB_ID(obstacle_distance), obstacle_distance_pub, &long_range_msg);\n+\tcp.modifySetpoint(modified_setpoint, max_speed, curr_pos, curr_vel);\n+\n+\t// THEN: the internal map data should contain the short range measurement\n+\tEXPECT_EQ(500, cp.getObstacleMap().distances[2]);\n+\n+\torb_unadvertise(obstacle_distance_pub);\n+\torb_unadvertise(vehicle_attitude_pub);\n+}\n+\n+TEST_F(CollisionPreventionTest, enterData)\n+{\n+\t// GIVEN: a simple setup condition\n+\tTestCollisionPrevention cp;\n+\tcp.getObstacleMap().increment = 10.f;\n+\tmatrix::Quaternion<float> vehicle_attitude(1, 0, 0, 0); //unit transform\n+\n+\t//THEN: just after initialization all bins are at UINT16_MAX and any data should be accepted\n+\tEXPECT_TRUE(cp.test_enterData(8, 2.f, 1.5f)); //shorter range, reading in range\n+\tEXPECT_TRUE(cp.test_enterData(8, 2.f, 3.f)); //shorter range, reading out of range\n+\tEXPECT_TRUE(cp.test_enterData(8, 20.f, 1.5f)); //same range, reading in range\n+\tEXPECT_TRUE(cp.test_enterData(8, 20.f, 21.f)); //same range, reading out of range\n+\tEXPECT_TRUE(cp.test_enterData(8, 30.f, 1.5f)); //longer range, reading in range\n+\tEXPECT_TRUE(cp.test_enterData(8, 30.f, 31.f)); //longer range, reading out of range\n+\n+\t//WHEN: we add distance sensor data to the right with a valid reading\n+\tdistance_sensor_s distance_sensor {};\n+\tdistance_sensor.min_distance = 0.2f;\n+\tdistance_sensor.max_distance = 20.f;\n+\tdistance_sensor.orientation = distance_sensor_s::ROTATION_RIGHT_FACING;\n+\tdistance_sensor.h_fov = math::radians(19.99f);\n+\tdistance_sensor.current_distance = 5.f;\n+\tcp.test_addDistanceSensorData(distance_sensor, vehicle_attitude);\n+\n+\t//THEN: the internal map should contain the distance sensor readings\n+\tEXPECT_EQ(500, cp.getObstacleMap().distances[8]);\n+\tEXPECT_EQ(500, cp.getObstacleMap().distances[9]);\n+\n+\t//THEN: bins 8 & 9 contain valid readings\n+\t// a valid reading should only be accepted from sensors with shorter or equal range\n+\t// a out of range reading should only be accepted from sensors with the same range\n+\n+\tEXPECT_TRUE(cp.test_enterData(8, 2.f, 1.5f)); //shorter range, reading in range\n+\tEXPECT_FALSE(cp.test_enterData(8, 2.f, 3.f)); //shorter range, reading out of range\n+\tEXPECT_TRUE(cp.test_enterData(8, 20.f, 1.5f)); //same range, reading in range\n+\tEXPECT_TRUE(cp.test_enterData(8, 20.f, 21.f)); //same range, reading out of range\n+\tEXPECT_FALSE(cp.test_enterData(8, 30.f, 1.5f)); //longer range, reading in range\n+\tEXPECT_FALSE(cp.test_enterData(8, 30.f, 31.f)); //longer range, reading out of range\n+\n+\t//WHEN: we add distance sensor data to the right with an out of range reading\n+\tdistance_sensor.current_distance = 21.f;\n+\tcp.test_addDistanceSensorData(distance_sensor, vehicle_attitude);\n+\n+\t//THEN: the internal map should contain the distance sensor readings\n+\tEXPECT_EQ(2000, cp.getObstacleMap().distances[8]);\n+\tEXPECT_EQ(2000, cp.getObstacleMap().distances[9]);\n+\n+\t//THEN: bins 8 & 9 contain readings out of range\n+\t// a reading in range will be accepted in any case\n+\t// out of range readings will only be accepted from sensors with bigger or equal range\n+\n+\tEXPECT_TRUE(cp.test_enterData(8, 2.f, 1.5f)); //shorter range, reading in range\n+\tEXPECT_FALSE(cp.test_enterData(8, 2.f, 3.f)); //shorter range, reading out of range\n+\tEXPECT_TRUE(cp.test_enterData(8, 20.f, 1.5f)); //same range, reading in range\n+\tEXPECT_TRUE(cp.test_enterData(8, 20.f, 21.f)); //same range, reading out of range\n+\tEXPECT_TRUE(cp.test_enterData(8, 30.f, 1.5f)); //longer range, reading in range\n+\tEXPECT_TRUE(cp.test_enterData(8, 30.f, 31.f)); //longer range, reading out of range\n+}"},{"sha":"cbc734b6dc49c51b04f33af763aca1f775425497","filename":"src/lib/CollisionPrevention/collisionprevention_params.c","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/07d656e971a72d1202651dfd3b4642736fb078d7/src%2Flib%2FCollisionPrevention%2Fcollisionprevention_params.c","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/07d656e971a72d1202651dfd3b4642736fb078d7/src%2Flib%2FCollisionPrevention%2Fcollisionprevention_params.c","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Flib%2FCollisionPrevention%2Fcollisionprevention_params.c?ref=07d656e971a72d1202651dfd3b4642736fb078d7","patch":"@@ -42,7 +42,7 @@\n /**\n  * Minimum distance the vehicle should keep to all obstacles\n  *\n- * Only used in Position mode. Collision avoidace is disabled by setting this parameter to a negative value\n+ * Only used in Position mode. Collision avoidance is disabled by setting this parameter to a negative value\n  *\n  * @min -1\n  * @max 15\n@@ -52,7 +52,7 @@\n PARAM_DEFINE_FLOAT(MPC_COL_PREV_D, -1.0f);\n \n /**\n- * Average delay of the range sensor message in seconds\n+ * Average delay of the range sensor message plus the tracking delay of the position controller in seconds\n  *\n  * Only used in Position mode.\n  *\n@@ -61,10 +61,10 @@ PARAM_DEFINE_FLOAT(MPC_COL_PREV_D, -1.0f);\n  * @unit seconds\n  * @group Multicopter Position Control\n  */\n-PARAM_DEFINE_FLOAT(MPC_COL_PREV_DLY, 0.f);\n+PARAM_DEFINE_FLOAT(MPC_COL_PREV_DLY, 0.4f);\n \n /**\n- * Angle left/right from the commanded setpoint in which the range data is used to calculate speed limitations. All data further from the commanded direction is not considered.\n+ * Angle left/right from the commanded setpoint by which the collision prevention algorithm can choose to change the setpoint direction\n  *\n  * Only used in Position mode.\n  *\n@@ -73,4 +73,4 @@ PARAM_DEFINE_FLOAT(MPC_COL_PREV_DLY, 0.f);\n  * @unit [deg]\n  * @group Multicopter Position Control\n  */\n-PARAM_DEFINE_FLOAT(MPC_COL_PREV_ANG, 45.f);\n+PARAM_DEFINE_FLOAT(MPC_COL_PREV_CNG, 30.f);"}]}