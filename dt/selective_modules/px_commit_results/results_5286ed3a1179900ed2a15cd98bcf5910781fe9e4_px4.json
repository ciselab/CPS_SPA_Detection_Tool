{"sha":"5286ed3a1179900ed2a15cd98bcf5910781fe9e4","node_id":"MDY6Q29tbWl0NTI5ODc5MDo1Mjg2ZWQzYTExNzk5MDBlZDJhMTVjZDk4YmNmNTkxMDc4MWZlOWU0","commit":{"author":{"name":"Daniel Agar","email":"daniel@agar.ca","date":"2020-06-02T17:25:42Z"},"committer":{"name":"Daniel Agar","email":"daniel@agar.ca","date":"2020-06-06T01:28:37Z"},"message":"imu/invensense/mpu6000: minor improvements\n\n - at start perform full sensor signal path reset and wait for max time\n - issue full sensor reset on any error\n - only allocate DRDY perf counter if GPIO is available\n - allow running faster than accel ODR (safe limit of 2 kHz in place)","tree":{"sha":"081154096a6e23c9671639597aae9fe97cb746e2","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/081154096a6e23c9671639597aae9fe97cb746e2"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/5286ed3a1179900ed2a15cd98bcf5910781fe9e4","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/5286ed3a1179900ed2a15cd98bcf5910781fe9e4","html_url":"https://github.com/PX4/PX4-Autopilot/commit/5286ed3a1179900ed2a15cd98bcf5910781fe9e4","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/5286ed3a1179900ed2a15cd98bcf5910781fe9e4/comments","author":{"login":"dagar","id":84712,"node_id":"MDQ6VXNlcjg0NzEy","avatar_url":"https://avatars.githubusercontent.com/u/84712?v=4","gravatar_id":"","url":"https://api.github.com/users/dagar","html_url":"https://github.com/dagar","followers_url":"https://api.github.com/users/dagar/followers","following_url":"https://api.github.com/users/dagar/following{/other_user}","gists_url":"https://api.github.com/users/dagar/gists{/gist_id}","starred_url":"https://api.github.com/users/dagar/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dagar/subscriptions","organizations_url":"https://api.github.com/users/dagar/orgs","repos_url":"https://api.github.com/users/dagar/repos","events_url":"https://api.github.com/users/dagar/events{/privacy}","received_events_url":"https://api.github.com/users/dagar/received_events","type":"User","site_admin":false},"committer":{"login":"dagar","id":84712,"node_id":"MDQ6VXNlcjg0NzEy","avatar_url":"https://avatars.githubusercontent.com/u/84712?v=4","gravatar_id":"","url":"https://api.github.com/users/dagar","html_url":"https://github.com/dagar","followers_url":"https://api.github.com/users/dagar/followers","following_url":"https://api.github.com/users/dagar/following{/other_user}","gists_url":"https://api.github.com/users/dagar/gists{/gist_id}","starred_url":"https://api.github.com/users/dagar/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dagar/subscriptions","organizations_url":"https://api.github.com/users/dagar/orgs","repos_url":"https://api.github.com/users/dagar/repos","events_url":"https://api.github.com/users/dagar/events{/privacy}","received_events_url":"https://api.github.com/users/dagar/received_events","type":"User","site_admin":false},"parents":[{"sha":"01f4486b32964312deaeaf170089c39c5a00abac","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/01f4486b32964312deaeaf170089c39c5a00abac","html_url":"https://github.com/PX4/PX4-Autopilot/commit/01f4486b32964312deaeaf170089c39c5a00abac"}],"stats":{"total":373,"additions":198,"deletions":175},"files":[{"sha":"89134d9c189504c132e4a265bfa18ddf26489bb2","filename":"src/drivers/imu/invensense/mpu6000/InvenSense_MPU6000_registers.hpp","status":"modified","additions":17,"deletions":34,"changes":51,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/5286ed3a1179900ed2a15cd98bcf5910781fe9e4/src%2Fdrivers%2Fimu%2Finvensense%2Fmpu6000%2FInvenSense_MPU6000_registers.hpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/5286ed3a1179900ed2a15cd98bcf5910781fe9e4/src%2Fdrivers%2Fimu%2Finvensense%2Fmpu6000%2FInvenSense_MPU6000_registers.hpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Fimu%2Finvensense%2Fmpu6000%2FInvenSense_MPU6000_registers.hpp?ref=5286ed3a1179900ed2a15cd98bcf5910781fe9e4","patch":"@@ -64,30 +64,27 @@ static constexpr float TEMPERATURE_SENSITIVITY = 340.f; // LSB/C\n static constexpr float TEMPERATURE_OFFSET = 36.53f; // C\n \n enum class Register : uint8_t {\n-\tCONFIG        = 0x1A,\n-\tGYRO_CONFIG   = 0x1B,\n-\tACCEL_CONFIG  = 0x1C,\n+\tCONFIG            = 0x1A,\n+\tGYRO_CONFIG       = 0x1B,\n+\tACCEL_CONFIG      = 0x1C,\n \n-\tFIFO_EN       = 0x23,\n-\tI2C_MST_CTRL  = 0x24,\n+\tFIFO_EN           = 0x23,\n \n-\tINT_PIN_CFG   = 0x37,\n-\tINT_ENABLE    = 0x38,\n+\tINT_PIN_CFG       = 0x37,\n+\tINT_ENABLE        = 0x38,\n \n-\tINT_STATUS    = 0x3A,\n-\n-\tTEMP_OUT_H    = 0x41,\n-\tTEMP_OUT_L    = 0x42,\n+\tTEMP_OUT_H        = 0x41,\n+\tTEMP_OUT_L        = 0x42,\n \n \tSIGNAL_PATH_RESET = 0x68,\n \n-\tUSER_CTRL     = 0x6A,\n-\tPWR_MGMT_1    = 0x6B,\n+\tUSER_CTRL         = 0x6A,\n+\tPWR_MGMT_1        = 0x6B,\n \n-\tFIFO_COUNTH   = 0x72,\n-\tFIFO_COUNTL   = 0x73,\n-\tFIFO_R_W      = 0x74,\n-\tWHO_AM_I      = 0x75,\n+\tFIFO_COUNTH       = 0x72,\n+\tFIFO_COUNTL       = 0x73,\n+\tFIFO_R_W          = 0x74,\n+\tWHO_AM_I          = 0x75,\n };\n \n // CONFIG\n@@ -124,22 +121,12 @@ enum FIFO_EN_BIT : uint8_t {\n \n // INT_PIN_CFG\n enum INT_PIN_CFG_BIT : uint8_t {\n-\tINT_LEVEL    = Bit7,\n-\n-\tINT_RD_CLEAR = Bit4,\n-\n+\tINT_LEVEL = Bit7,\n };\n \n // INT_ENABLE\n enum INT_ENABLE_BIT : uint8_t {\n-\tFIFO_OFLOW_EN   = Bit4,\n-\tDATA_RDY_INT_EN = Bit0\n-};\n-\n-// INT_STATUS\n-enum INT_STATUS_BIT : uint8_t {\n-\tFIFO_OFLOW_INT = Bit4,\n-\tDATA_RDY_INT   = Bit0,\n+\tDATA_RDY_INT_EN = Bit0,\n };\n \n // SIGNAL_PATH_RESET\n@@ -152,11 +139,8 @@ enum SIGNAL_PATH_RESET_BIT : uint8_t {\n // USER_CTRL\n enum USER_CTRL_BIT : uint8_t {\n \tFIFO_EN        = Bit6,\n-\tI2C_MST_EN     = Bit5,\n \tI2C_IF_DIS     = Bit4,\n-\n \tFIFO_RESET     = Bit2,\n-\n \tSIG_COND_RESET = Bit0,\n };\n \n@@ -165,8 +149,7 @@ enum PWR_MGMT_1_BIT : uint8_t {\n \tDEVICE_RESET = Bit7,\n \tSLEEP        = Bit6,\n \n-\tCLKSEL_2     = Bit2,\n-\tCLKSEL_1     = Bit1,\n+\t// CLKSEL[2:0]\n \tCLKSEL_0     = Bit0,\n };\n "},{"sha":"857bf6d2d0dce4953aad1d011f8eb1b2e0626f8d","filename":"src/drivers/imu/invensense/mpu6000/MPU6000.cpp","status":"modified","additions":161,"deletions":122,"changes":283,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/5286ed3a1179900ed2a15cd98bcf5910781fe9e4/src%2Fdrivers%2Fimu%2Finvensense%2Fmpu6000%2FMPU6000.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/5286ed3a1179900ed2a15cd98bcf5910781fe9e4/src%2Fdrivers%2Fimu%2Finvensense%2Fmpu6000%2FMPU6000.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Fimu%2Finvensense%2Fmpu6000%2FMPU6000.cpp?ref=5286ed3a1179900ed2a15cd98bcf5910781fe9e4","patch":"@@ -48,6 +48,10 @@ MPU6000::MPU6000(I2CSPIBusOption bus_option, int bus, uint32_t device, enum Rota\n \t_px4_accel(get_device_id(), ORB_PRIO_HIGH, rotation),\n \t_px4_gyro(get_device_id(), ORB_PRIO_HIGH, rotation)\n {\n+\tif (drdy_gpio != 0) {\n+\t\t_drdy_interval_perf = perf_alloc(PC_INTERVAL, MODULE_NAME\": DRDY interval\");\n+\t}\n+\n \tConfigureSampleRate(_px4_gyro.get_max_rate_hz());\n }\n \n@@ -77,6 +81,7 @@ int MPU6000::init()\n bool MPU6000::Reset()\n {\n \t_state = STATE::RESET;\n+\tDataReadyInterruptDisable();\n \tScheduleClear();\n \tScheduleNow();\n \treturn true;\n@@ -91,8 +96,8 @@ void MPU6000::exit_and_cleanup()\n void MPU6000::print_status()\n {\n \tI2CSPIDriverBase::print_status();\n-\tPX4_INFO(\"FIFO empty interval: %d us (%.3f Hz)\", _fifo_empty_interval_us,\n-\t\t static_cast<double>(1000000 / _fifo_empty_interval_us));\n+\n+\tPX4_INFO(\"FIFO empty interval: %d us (%.3f Hz)\", _fifo_empty_interval_us, 1e6 / _fifo_empty_interval_us);\n \n \tperf_print_counter(_transfer_perf);\n \tperf_print_counter(_bad_register_perf);\n@@ -120,13 +125,17 @@ int MPU6000::probe()\n \n void MPU6000::RunImpl()\n {\n+\tconst hrt_abstime now = hrt_absolute_time();\n+\n \tswitch (_state) {\n \tcase STATE::RESET:\n \t\t// PWR_MGMT_1: Device Reset\n \t\tRegisterWrite(Register::PWR_MGMT_1, PWR_MGMT_1_BIT::DEVICE_RESET);\n-\t\t_reset_timestamp = hrt_absolute_time();\n+\t\t_reset_timestamp = now;\n+\t\t_consecutive_failures = 0;\n+\t\t_total_failures = 0;\n \t\t_state = STATE::WAIT_FOR_RESET;\n-\t\tScheduleDelayed(100_ms);\n+\t\tScheduleDelayed(100_ms); // Wait 100ms (Document Number: RM-MPU-6000A-00 Page 41 of 46)\n \t\tbreak;\n \n \tcase STATE::WAIT_FOR_RESET:\n@@ -136,17 +145,19 @@ void MPU6000::RunImpl()\n \t\tif ((RegisterRead(Register::WHO_AM_I) == WHOAMI)\n \t\t    && (RegisterRead(Register::PWR_MGMT_1) == 0x40)) {\n \n-\t\t\t// SIGNAL_PATH_RESET: ensure the reset is performed properly\n+\t\t\t// Wakeup and reset digital signal path\n+\t\t\tRegisterWrite(Register::PWR_MGMT_1, 0);\n \t\t\tRegisterWrite(Register::SIGNAL_PATH_RESET,\n \t\t\t\t      SIGNAL_PATH_RESET_BIT::GYRO_RESET | SIGNAL_PATH_RESET_BIT::ACCEL_RESET | SIGNAL_PATH_RESET_BIT::TEMP_RESET);\n+\t\t\tRegisterSetAndClearBits(Register::USER_CTRL, USER_CTRL_BIT::SIG_COND_RESET, USER_CTRL_BIT::I2C_IF_DIS);\n \n \t\t\t// if reset succeeded then configure\n \t\t\t_state = STATE::CONFIGURE;\n-\t\t\tScheduleDelayed(100_ms);\n+\t\t\tScheduleDelayed(100_ms); // Wait another 100ms (Document Number: RM-MPU-6000A-00 Page 41 of 46)\n \n \t\t} else {\n \t\t\t// RESET not complete\n-\t\t\tif (hrt_elapsed_time(&_reset_timestamp) > 100_ms) {\n+\t\t\tif (hrt_elapsed_time(&_reset_timestamp) > 1000_ms) {\n \t\t\t\tPX4_DEBUG(\"Reset failed, retrying\");\n \t\t\t\t_state = STATE::RESET;\n \t\t\t\tScheduleDelayed(100_ms);\n@@ -168,7 +179,7 @@ void MPU6000::RunImpl()\n \t\t\t\t_data_ready_interrupt_enabled = true;\n \n \t\t\t\t// backup schedule as a watchdog timeout\n-\t\t\t\tScheduleDelayed(10_ms);\n+\t\t\t\tScheduleDelayed(100_ms);\n \n \t\t\t} else {\n \t\t\t\t_data_ready_interrupt_enabled = false;\n@@ -178,73 +189,87 @@ void MPU6000::RunImpl()\n \t\t\tFIFOReset();\n \n \t\t} else {\n-\t\t\tPX4_DEBUG(\"Configure failed, retrying\");\n-\t\t\t// try again in 10 ms\n+\t\t\t// CONFIGURE not complete\n+\t\t\tif (hrt_elapsed_time(&_reset_timestamp) > 1000_ms) {\n+\t\t\t\tPX4_DEBUG(\"Configure failed, resetting\");\n+\t\t\t\t_state = STATE::RESET;\n+\n+\t\t\t} else {\n+\t\t\t\tPX4_DEBUG(\"Configure failed, retrying\");\n+\t\t\t}\n+\n \t\t\tScheduleDelayed(10_ms);\n \t\t}\n \n \t\tbreak;\n \n \tcase STATE::FIFO_READ: {\n-\t\t\thrt_abstime timestamp_sample = 0;\n-\n \t\t\tif (_data_ready_interrupt_enabled) {\n-\t\t\t\t// re-schedule as watchdog timeout\n-\t\t\t\tScheduleDelayed(10_ms);\n-\t\t\t}\n-\n-\t\t\tif (_data_ready_interrupt_enabled && (hrt_elapsed_time(&timestamp_sample) < (_fifo_empty_interval_us / 2))) {\n-\t\t\t\t// use timestamp from data ready interrupt if enabled and seems valid\n-\t\t\t\ttimestamp_sample = _fifo_watermark_interrupt_timestamp;\n+\t\t\t\t// scheduled from interrupt if _drdy_fifo_read_samples was set\n+\t\t\t\tif (_drdy_fifo_read_samples.fetch_and(0) == _fifo_gyro_samples) {\n+\t\t\t\t\tperf_count_interval(_drdy_interval_perf, now);\n+\t\t\t\t}\n \n-\t\t\t} else {\n-\t\t\t\t// use the time now roughly corresponding with the last sample we'll pull from the FIFO\n-\t\t\t\ttimestamp_sample = hrt_absolute_time();\n+\t\t\t\t// push backup schedule back\n+\t\t\t\tScheduleDelayed(_fifo_empty_interval_us * 2);\n \t\t\t}\n \n+\t\t\t// always check current FIFO count\n+\t\t\tbool success = false;\n \t\t\tconst uint16_t fifo_count = FIFOReadCount();\n-\t\t\tconst uint8_t samples = (fifo_count / sizeof(FIFO::DATA) / SAMPLES_PER_TRANSFER) *\n-\t\t\t\t\t\tSAMPLES_PER_TRANSFER; // round down to nearest\n \n-\t\t\tbool failure = false;\n-\n-\t\t\tif (samples > FIFO_MAX_SAMPLES) {\n-\t\t\t\t// not technically an overflow, but more samples than we expected or can publish\n-\t\t\t\tperf_count(_fifo_overflow_perf);\n-\t\t\t\tfailure = true;\n+\t\t\tif (fifo_count >= FIFO::SIZE) {\n \t\t\t\tFIFOReset();\n+\t\t\t\tperf_count(_fifo_overflow_perf);\n \n-\t\t\t} else if (samples >= SAMPLES_PER_TRANSFER) {\n-\t\t\t\t// require at least SAMPLES_PER_TRANSFER (we want at least 1 new accel sample per transfer)\n-\t\t\t\tif (!FIFORead(timestamp_sample, samples)) {\n-\t\t\t\t\tfailure = true;\n-\t\t\t\t\t_px4_accel.increase_error_count();\n-\t\t\t\t\t_px4_gyro.increase_error_count();\n+\t\t\t} else if (fifo_count == 0) {\n+\t\t\t\tperf_count(_fifo_empty_perf);\n+\n+\t\t\t} else {\n+\t\t\t\t// FIFO count (size in bytes) should be a multiple of the FIFO::DATA structure\n+\t\t\t\tconst uint8_t samples = fifo_count / sizeof(FIFO::DATA);\n+\n+\t\t\t\tif (samples > FIFO_MAX_SAMPLES) {\n+\t\t\t\t\t// not technically an overflow, but more samples than we expected or can publish\n+\t\t\t\t\tFIFOReset();\n+\t\t\t\t\tperf_count(_fifo_overflow_perf);\n+\n+\t\t\t\t} else if (samples >= 1) {\n+\t\t\t\t\tif (FIFORead(now, samples)) {\n+\t\t\t\t\t\tsuccess = true;\n+\t\t\t\t\t\t_consecutive_failures = 0;\n+\t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t}\n \n-\t\t\t} else if (samples == 0) {\n-\t\t\t\tfailure = true;\n-\t\t\t\tperf_count(_fifo_empty_perf);\n+\t\t\tif (!success) {\n+\t\t\t\t_consecutive_failures++;\n+\t\t\t\t_total_failures++;\n+\n+\t\t\t\t// full reset if things are failing consistently\n+\t\t\t\tif (_consecutive_failures > 100 || _total_failures > 1000) {\n+\t\t\t\t\tReset();\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n \t\t\t}\n \n-\t\t\tif (failure || hrt_elapsed_time(&_last_config_check_timestamp) > 10_ms) {\n-\t\t\t\t// check registers incrementally\n-\t\t\t\tif (RegisterCheck(_register_cfg[_checked_register], true)) {\n-\t\t\t\t\t_last_config_check_timestamp = timestamp_sample;\n+\t\t\tif (!success || hrt_elapsed_time(&_last_config_check_timestamp) > 10_ms) {\n+\t\t\t\t// check configuration registers periodically or immediately following any failure\n+\t\t\t\tif (RegisterCheck(_register_cfg[_checked_register])) {\n+\t\t\t\t\t_last_config_check_timestamp = now;\n \t\t\t\t\t_checked_register = (_checked_register + 1) % size_register_cfg;\n \n \t\t\t\t} else {\n-\t\t\t\t\t// register check failed, force reconfigure\n-\t\t\t\t\tPX4_DEBUG(\"Health check failed, reconfiguring\");\n-\t\t\t\t\t_state = STATE::CONFIGURE;\n-\t\t\t\t\tScheduleNow();\n+\t\t\t\t\t// register check failed, force reset\n+\t\t\t\t\tperf_count(_bad_register_perf);\n+\t\t\t\t\tReset();\n \t\t\t\t}\n \n \t\t\t} else {\n-\t\t\t\t// periodically update temperature (1 Hz)\n-\t\t\t\tif (hrt_elapsed_time(&_temperature_update_timestamp) > 1_s) {\n+\t\t\t\t// periodically update temperature (~1 Hz)\n+\t\t\t\tif (hrt_elapsed_time(&_temperature_update_timestamp) >= 1_s) {\n \t\t\t\t\tUpdateTemperature();\n-\t\t\t\t\t_temperature_update_timestamp = timestamp_sample;\n+\t\t\t\t\t_temperature_update_timestamp = now;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -259,23 +284,23 @@ void MPU6000::ConfigureAccel()\n \n \tswitch (AFS_SEL) {\n \tcase AFS_SEL_2G:\n-\t\t_px4_accel.set_scale(CONSTANTS_ONE_G / 16384);\n-\t\t_px4_accel.set_range(2 * CONSTANTS_ONE_G);\n+\t\t_px4_accel.set_scale(CONSTANTS_ONE_G / 16384.f);\n+\t\t_px4_accel.set_range(2.f * CONSTANTS_ONE_G);\n \t\tbreak;\n \n \tcase AFS_SEL_4G:\n-\t\t_px4_accel.set_scale(CONSTANTS_ONE_G / 8192);\n-\t\t_px4_accel.set_range(4 * CONSTANTS_ONE_G);\n+\t\t_px4_accel.set_scale(CONSTANTS_ONE_G / 8192.f);\n+\t\t_px4_accel.set_range(4.f * CONSTANTS_ONE_G);\n \t\tbreak;\n \n \tcase AFS_SEL_8G:\n-\t\t_px4_accel.set_scale(CONSTANTS_ONE_G / 4096);\n-\t\t_px4_accel.set_range(8 * CONSTANTS_ONE_G);\n+\t\t_px4_accel.set_scale(CONSTANTS_ONE_G / 4096.f);\n+\t\t_px4_accel.set_range(8.f * CONSTANTS_ONE_G);\n \t\tbreak;\n \n \tcase AFS_SEL_16G:\n-\t\t_px4_accel.set_scale(CONSTANTS_ONE_G / 2048);\n-\t\t_px4_accel.set_range(16 * CONSTANTS_ONE_G);\n+\t\t_px4_accel.set_scale(CONSTANTS_ONE_G / 2048.f);\n+\t\t_px4_accel.set_range(16.f * CONSTANTS_ONE_G);\n \t\tbreak;\n \t}\n }\n@@ -310,27 +335,31 @@ void MPU6000::ConfigureGyro()\n void MPU6000::ConfigureSampleRate(int sample_rate)\n {\n \tif (sample_rate == 0) {\n-\t\tsample_rate = 800; // default to 800 Hz\n+\t\tsample_rate = 1000; // default to 1000 Hz\n \t}\n \n-\t// round down to nearest FIFO sample dt * SAMPLES_PER_TRANSFER\n-\tconst float min_interval = SAMPLES_PER_TRANSFER * FIFO_SAMPLE_DT;\n+\t// round down to nearest FIFO sample dt\n+\tconst float min_interval = FIFO_SAMPLE_DT * 4; // limit to 2 kHz (500 us interval)\n \t_fifo_empty_interval_us = math::max(roundf((1e6f / (float)sample_rate) / min_interval) * min_interval, min_interval);\n \n-\t_fifo_gyro_samples = math::min((float)_fifo_empty_interval_us / (1e6f / GYRO_RATE), (float)FIFO_MAX_SAMPLES);\n+\t_fifo_gyro_samples = roundf(math::min((float)_fifo_empty_interval_us / (1e6f / GYRO_RATE), (float)FIFO_MAX_SAMPLES));\n \n \t// recompute FIFO empty interval (us) with actual gyro sample limit\n \t_fifo_empty_interval_us = _fifo_gyro_samples * (1e6f / GYRO_RATE);\n-\n-\t_fifo_accel_samples = math::min(_fifo_empty_interval_us / (1e6f / ACCEL_RATE), (float)FIFO_MAX_SAMPLES);\n }\n \n bool MPU6000::Configure()\n {\n+\t// first set and clear all configured register bits\n+\tfor (const auto &reg_cfg : _register_cfg) {\n+\t\tRegisterSetAndClearBits(reg_cfg.reg, reg_cfg.set_bits, reg_cfg.clear_bits);\n+\t}\n+\n+\t// now check that all are configured\n \tbool success = true;\n \n-\tfor (const auto &reg : _register_cfg) {\n-\t\tif (!RegisterCheck(reg)) {\n+\tfor (const auto &reg_cfg : _register_cfg) {\n+\t\tif (!RegisterCheck(reg_cfg)) {\n \t\t\tsuccess = false;\n \t\t}\n \t}\n@@ -349,12 +378,13 @@ int MPU6000::DataReadyInterruptCallback(int irq, void *context, void *arg)\n \n void MPU6000::DataReady()\n {\n-\tperf_count(_drdy_interval_perf);\n+\tconst uint8_t count = _drdy_count.fetch_add(1) + 1;\n+\n+\tuint8_t expected = 0;\n \n-\tif (_data_ready_count.fetch_add(1) >= (_fifo_gyro_samples - 1)) {\n-\t\t_data_ready_count.store(0);\n-\t\t_fifo_watermark_interrupt_timestamp = hrt_absolute_time();\n-\t\t_fifo_read_samples.store(_fifo_gyro_samples);\n+\t// at least the required number of samples in the FIFO\n+\tif ((count >= _fifo_gyro_samples) && _drdy_fifo_read_samples.compare_exchange(&expected, _fifo_gyro_samples)) {\n+\t\t_drdy_count.store(0);\n \t\tScheduleNow();\n \t}\n }\n@@ -366,7 +396,7 @@ bool MPU6000::DataReadyInterruptConfigure()\n \t}\n \n \t// Setup data ready on falling edge\n-\treturn px4_arch_gpiosetevent(_drdy_gpio, false, true, true, &MPU6000::DataReadyInterruptCallback, this) == 0;\n+\treturn px4_arch_gpiosetevent(_drdy_gpio, false, true, true, &DataReadyInterruptCallback, this) == 0;\n }\n \n bool MPU6000::DataReadyInterruptDisable()\n@@ -378,7 +408,7 @@ bool MPU6000::DataReadyInterruptDisable()\n \treturn px4_arch_gpiosetevent(_drdy_gpio, false, false, false, nullptr, nullptr) == 0;\n }\n \n-bool MPU6000::RegisterCheck(const register_config_t &reg_cfg, bool notify)\n+bool MPU6000::RegisterCheck(const register_config_t &reg_cfg)\n {\n \tbool success = true;\n \n@@ -394,16 +424,6 @@ bool MPU6000::RegisterCheck(const register_config_t &reg_cfg, bool notify)\n \t\tsuccess = false;\n \t}\n \n-\tif (!success) {\n-\t\tRegisterSetAndClearBits(reg_cfg.reg, reg_cfg.set_bits, reg_cfg.clear_bits);\n-\n-\t\tif (notify) {\n-\t\t\tperf_count(_bad_register_perf);\n-\t\t\t_px4_accel.increase_error_count();\n-\t\t\t_px4_gyro.increase_error_count();\n-\t\t}\n-\t}\n-\n \treturn success;\n }\n \n@@ -426,17 +446,12 @@ void MPU6000::RegisterWrite(Register reg, uint8_t value)\n void MPU6000::RegisterSetAndClearBits(Register reg, uint8_t setbits, uint8_t clearbits)\n {\n \tconst uint8_t orig_val = RegisterRead(reg);\n-\tuint8_t val = orig_val;\n \n-\tif (setbits) {\n-\t\tval |= setbits;\n-\t}\n+\tuint8_t val = (orig_val & ~clearbits) | setbits;\n \n-\tif (clearbits) {\n-\t\tval &= ~clearbits;\n+\tif (orig_val != val) {\n+\t\tRegisterWrite(reg, val);\n \t}\n-\n-\tRegisterWrite(reg, val);\n }\n \n uint16_t MPU6000::FIFOReadCount()\n@@ -454,10 +469,9 @@ uint16_t MPU6000::FIFOReadCount()\n \treturn combine(fifo_count_buf[1], fifo_count_buf[2]);\n }\n \n-bool MPU6000::FIFORead(const hrt_abstime &timestamp_sample, uint16_t samples)\n+bool MPU6000::FIFORead(const hrt_abstime &timestamp_sample, uint8_t samples)\n {\n \tperf_begin(_transfer_perf);\n-\n \tFIFOTransferBuffer buffer{};\n \tconst size_t transfer_size = math::min(samples * sizeof(FIFO::DATA) + 1, FIFO::SIZE);\n \tset_frequency(SPI_SPEED_SENSOR);\n@@ -470,8 +484,8 @@ bool MPU6000::FIFORead(const hrt_abstime &timestamp_sample, uint16_t samples)\n \n \tperf_end(_transfer_perf);\n \n-\tProcessGyro(timestamp_sample, buffer, samples);\n-\treturn ProcessAccel(timestamp_sample, buffer, samples);\n+\tProcessGyro(timestamp_sample, buffer.f, samples);\n+\treturn ProcessAccel(timestamp_sample, buffer.f, samples);\n }\n \n void MPU6000::FIFOReset()\n@@ -485,9 +499,8 @@ void MPU6000::FIFOReset()\n \tRegisterSetAndClearBits(Register::USER_CTRL, USER_CTRL_BIT::FIFO_RESET, USER_CTRL_BIT::FIFO_EN);\n \n \t// reset while FIFO is disabled\n-\t_data_ready_count.store(0);\n-\t_fifo_watermark_interrupt_timestamp = 0;\n-\t_fifo_read_samples.store(0);\n+\t_drdy_count.store(0);\n+\t_drdy_fifo_read_samples.store(0);\n \n \t// FIFO_EN: enable both gyro and accel\n \t// USER_CTRL: re-enable FIFO\n@@ -498,51 +511,74 @@ void MPU6000::FIFOReset()\n \t}\n }\n \n-bool MPU6000::ProcessAccel(const hrt_abstime &timestamp_sample, const FIFOTransferBuffer &buffer, const uint8_t samples)\n+static bool fifo_accel_equal(const FIFO::DATA &f0, const FIFO::DATA &f1)\n+{\n+\treturn (memcmp(&f0.ACCEL_XOUT_H, &f1.ACCEL_XOUT_H, 6) == 0);\n+}\n+\n+bool MPU6000::ProcessAccel(const hrt_abstime &timestamp_sample, const FIFO::DATA fifo[], const uint8_t samples)\n {\n \tPX4Accelerometer::FIFOSample accel;\n \taccel.timestamp_sample = timestamp_sample;\n-\taccel.dt = _fifo_empty_interval_us / _fifo_accel_samples;\n+\taccel.samples = 0;\n+\taccel.dt = FIFO_SAMPLE_DT * SAMPLES_PER_TRANSFER;\n \n \tbool bad_data = false;\n \n \t// FIFO contains 8 duplicated accel samples per gyro sample\n-\tint accel_samples = 0;\n-\n-\tfor (int i = 0; i < samples; i = i + 8) {\n-\t\tconst FIFO::DATA &fifo_sample = buffer.f[i];\n-\t\tint16_t accel_x = combine(fifo_sample.ACCEL_XOUT_H, fifo_sample.ACCEL_XOUT_L);\n-\t\tint16_t accel_y = combine(fifo_sample.ACCEL_YOUT_H, fifo_sample.ACCEL_YOUT_L);\n-\t\tint16_t accel_z = combine(fifo_sample.ACCEL_ZOUT_H, fifo_sample.ACCEL_ZOUT_L);\n+\tfor (int i = 0; i < samples; i++) {\n+\t\t_fifo_accel_samples_count++;\n+\n+\t\t// only process new FIFO samples (1 every 8 samples expected)\n+\t\tconst bool new_sample = !fifo_accel_equal(fifo[i], _fifo_sample_last_new_accel);\n+\n+\t\t// process every 8th sample\n+\t\tif (_fifo_accel_samples_count == SAMPLES_PER_TRANSFER) {\n+\t\t\tint16_t accel_x = combine(fifo[i].ACCEL_XOUT_H, fifo[i].ACCEL_XOUT_L);\n+\t\t\tint16_t accel_y = combine(fifo[i].ACCEL_YOUT_H, fifo[i].ACCEL_YOUT_L);\n+\t\t\tint16_t accel_z = combine(fifo[i].ACCEL_ZOUT_H, fifo[i].ACCEL_ZOUT_L);\n+\n+\t\t\t// sensor's frame is +x forward, +y left, +z up\n+\t\t\t//  flip y & z to publish right handed with z down (x forward, y right, z down)\n+\t\t\taccel.x[accel.samples] = accel_x;\n+\t\t\taccel.y[accel.samples] = (accel_y == INT16_MIN) ? INT16_MAX : -accel_y;\n+\t\t\taccel.z[accel.samples] = (accel_z == INT16_MIN) ? INT16_MAX : -accel_z;\n+\t\t\taccel.samples++;\n+\n+\t\t} else if (new_sample && (_fifo_accel_samples_count > 1)) {\n+\t\t\t// a new unique sample after fewer than 8 samples is an error\n+\t\t\tbad_data = true;\n+\t\t\tperf_count(_bad_transfer_perf);\n+\t\t}\n \n-\t\t// sensor's frame is +x forward, +y left, +z up\n-\t\t//  flip y & z to publish right handed with z down (x forward, y right, z down)\n-\t\taccel.x[accel_samples] = accel_x;\n-\t\taccel.y[accel_samples] = (accel_y == INT16_MIN) ? INT16_MAX : -accel_y;\n-\t\taccel.z[accel_samples] = (accel_z == INT16_MIN) ? INT16_MAX : -accel_z;\n-\t\taccel_samples++;\n+\t\t// reset previous unique sample and counter\n+\t\tif (new_sample || (_fifo_accel_samples_count == SAMPLES_PER_TRANSFER)) {\n+\t\t\t_fifo_accel_samples_count = 0;\n+\t\t\t_fifo_sample_last_new_accel = fifo[i];\n+\t\t}\n \t}\n \n-\taccel.samples = accel_samples;\n+\t_px4_accel.set_error_count(perf_event_count(_bad_register_perf) + perf_event_count(_bad_transfer_perf) +\n+\t\t\t\t   perf_event_count(_fifo_empty_perf) + perf_event_count(_fifo_overflow_perf));\n \n-\t_px4_accel.updateFIFO(accel);\n+\tif (accel.samples > 0) {\n+\t\t_px4_accel.updateFIFO(accel);\n+\t}\n \n \treturn !bad_data;\n }\n \n-void MPU6000::ProcessGyro(const hrt_abstime &timestamp_sample, const FIFOTransferBuffer &buffer, const uint8_t samples)\n+void MPU6000::ProcessGyro(const hrt_abstime &timestamp_sample, const FIFO::DATA fifo[], const uint8_t samples)\n {\n \tPX4Gyroscope::FIFOSample gyro;\n \tgyro.timestamp_sample = timestamp_sample;\n \tgyro.samples = samples;\n-\tgyro.dt = _fifo_empty_interval_us / _fifo_gyro_samples;\n+\tgyro.dt = FIFO_SAMPLE_DT;\n \n \tfor (int i = 0; i < samples; i++) {\n-\t\tconst FIFO::DATA &fifo_sample = buffer.f[i];\n-\n-\t\tconst int16_t gyro_x = combine(fifo_sample.GYRO_XOUT_H, fifo_sample.GYRO_XOUT_L);\n-\t\tconst int16_t gyro_y = combine(fifo_sample.GYRO_YOUT_H, fifo_sample.GYRO_YOUT_L);\n-\t\tconst int16_t gyro_z = combine(fifo_sample.GYRO_ZOUT_H, fifo_sample.GYRO_ZOUT_L);\n+\t\tconst int16_t gyro_x = combine(fifo[i].GYRO_XOUT_H, fifo[i].GYRO_XOUT_L);\n+\t\tconst int16_t gyro_y = combine(fifo[i].GYRO_YOUT_H, fifo[i].GYRO_YOUT_L);\n+\t\tconst int16_t gyro_z = combine(fifo[i].GYRO_ZOUT_H, fifo[i].GYRO_ZOUT_L);\n \n \t\t// sensor's frame is +x forward, +y left, +z up\n \t\t//  flip y & z to publish right handed with z down (x forward, y right, z down)\n@@ -551,6 +587,9 @@ void MPU6000::ProcessGyro(const hrt_abstime &timestamp_sample, const FIFOTransfe\n \t\tgyro.z[i] = (gyro_z == INT16_MIN) ? INT16_MAX : -gyro_z;\n \t}\n \n+\t_px4_gyro.set_error_count(perf_event_count(_bad_register_perf) + perf_event_count(_bad_transfer_perf) +\n+\t\t\t\t  perf_event_count(_fifo_empty_perf) + perf_event_count(_fifo_overflow_perf));\n+\n \t_px4_gyro.updateFIFO(gyro);\n }\n "},{"sha":"94548daa8e70fbd1d5388d6e8b05fdd49338c19d","filename":"src/drivers/imu/invensense/mpu6000/MPU6000.hpp","status":"modified","additions":20,"deletions":19,"changes":39,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/5286ed3a1179900ed2a15cd98bcf5910781fe9e4/src%2Fdrivers%2Fimu%2Finvensense%2Fmpu6000%2FMPU6000.hpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/5286ed3a1179900ed2a15cd98bcf5910781fe9e4/src%2Fdrivers%2Fimu%2Finvensense%2Fmpu6000%2FMPU6000.hpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Fimu%2Finvensense%2Fmpu6000%2FMPU6000.hpp?ref=5286ed3a1179900ed2a15cd98bcf5910781fe9e4","patch":"@@ -73,10 +73,10 @@ class MPU6000 : public device::SPI, public I2CSPIDriver<MPU6000>\n \tvoid exit_and_cleanup() override;\n \n \t// Sensor Configuration\n-\tstatic constexpr float FIFO_SAMPLE_DT{125.f};\n-\tstatic constexpr uint32_t SAMPLES_PER_TRANSFER{8};       // ensure at least 1 new accel sample per transfer\n-\tstatic constexpr float GYRO_RATE{1e6f / FIFO_SAMPLE_DT}; // 8 kHz gyro\n-\tstatic constexpr float ACCEL_RATE{GYRO_RATE / 8.f};      // 1 kHz accel\n+\tstatic constexpr float FIFO_SAMPLE_DT{1e6f / 8000.f};\n+\tstatic constexpr uint32_t SAMPLES_PER_TRANSFER{8};                   // ensure at least 1 new accel sample per transfer\n+\tstatic constexpr float GYRO_RATE{1e6f / FIFO_SAMPLE_DT};             // 8000 Hz gyro\n+\tstatic constexpr float ACCEL_RATE{GYRO_RATE / SAMPLES_PER_TRANSFER}; // 1000 Hz accel\n \n \tstatic constexpr uint32_t FIFO_MAX_SAMPLES{math::min(FIFO::SIZE / sizeof(FIFO::DATA), sizeof(PX4Gyroscope::FIFOSample::x) / sizeof(PX4Gyroscope::FIFOSample::x[0]))};\n \n@@ -108,20 +108,18 @@ class MPU6000 : public device::SPI, public I2CSPIDriver<MPU6000>\n \tbool DataReadyInterruptConfigure();\n \tbool DataReadyInterruptDisable();\n \n-\tbool RegisterCheck(const register_config_t &reg_cfg, bool notify = false);\n+\tbool RegisterCheck(const register_config_t &reg_cfg);\n \n \tuint8_t RegisterRead(Register reg);\n \tvoid RegisterWrite(Register reg, uint8_t value);\n \tvoid RegisterSetAndClearBits(Register reg, uint8_t setbits, uint8_t clearbits);\n-\tvoid RegisterSetBits(Register reg, uint8_t setbits) { RegisterSetAndClearBits(reg, setbits, 0); }\n-\tvoid RegisterClearBits(Register reg, uint8_t clearbits) { RegisterSetAndClearBits(reg, 0, clearbits); }\n \n \tuint16_t FIFOReadCount();\n-\tbool FIFORead(const hrt_abstime &timestamp_sample, uint16_t samples);\n+\tbool FIFORead(const hrt_abstime &timestamp_sample, uint8_t samples);\n \tvoid FIFOReset();\n \n-\tbool ProcessAccel(const hrt_abstime &timestamp_sample, const FIFOTransferBuffer &buffer, const uint8_t samples);\n-\tvoid ProcessGyro(const hrt_abstime &timestamp_sample, const FIFOTransferBuffer &buffer, const uint8_t samples);\n+\tbool ProcessAccel(const hrt_abstime &timestamp_sample, const FIFO::DATA fifo[], const uint8_t samples);\n+\tvoid ProcessGyro(const hrt_abstime &timestamp_sample, const FIFO::DATA fifo[], const uint8_t samples);\n \tvoid UpdateTemperature();\n \n \tconst spi_drdy_gpio_t _drdy_gpio;\n@@ -135,15 +133,19 @@ class MPU6000 : public device::SPI, public I2CSPIDriver<MPU6000>\n \tperf_counter_t _fifo_empty_perf{perf_alloc(PC_COUNT, MODULE_NAME\": FIFO empty\")};\n \tperf_counter_t _fifo_overflow_perf{perf_alloc(PC_COUNT, MODULE_NAME\": FIFO overflow\")};\n \tperf_counter_t _fifo_reset_perf{perf_alloc(PC_COUNT, MODULE_NAME\": FIFO reset\")};\n-\tperf_counter_t _drdy_interval_perf{perf_alloc(PC_INTERVAL, MODULE_NAME\": DRDY interval\")};\n+\tperf_counter_t _drdy_interval_perf{nullptr};\n \n \thrt_abstime _reset_timestamp{0};\n \thrt_abstime _last_config_check_timestamp{0};\n-\thrt_abstime _fifo_watermark_interrupt_timestamp{0};\n \thrt_abstime _temperature_update_timestamp{0};\n+\tunsigned _consecutive_failures{0};\n+\tunsigned _total_failures{0};\n \n-\tpx4::atomic<uint8_t> _data_ready_count{0};\n-\tpx4::atomic<uint8_t> _fifo_read_samples{0};\n+\tFIFO::DATA _fifo_sample_last_new_accel{};\n+\tint _fifo_accel_samples_count{0};\n+\n+\tpx4::atomic<uint8_t> _drdy_fifo_read_samples{0};\n+\tpx4::atomic<uint8_t> _drdy_count{0};\n \tbool _data_ready_interrupt_enabled{false};\n \n \tenum class STATE : uint8_t {\n@@ -157,18 +159,17 @@ class MPU6000 : public device::SPI, public I2CSPIDriver<MPU6000>\n \n \tuint16_t _fifo_empty_interval_us{1250}; // default 1250 us / 800 Hz transfer interval\n \tuint8_t _fifo_gyro_samples{static_cast<uint8_t>(_fifo_empty_interval_us / (1000000 / GYRO_RATE))};\n-\tuint8_t _fifo_accel_samples{static_cast<uint8_t>(_fifo_empty_interval_us / (1000000 / ACCEL_RATE))};\n \n \tuint8_t _checked_register{0};\n \tstatic constexpr uint8_t size_register_cfg{7};\n \tregister_config_t _register_cfg[size_register_cfg] {\n \t\t// Register               | Set bits, Clear bits\n-\t\t{ Register::PWR_MGMT_1,    PWR_MGMT_1_BIT::CLKSEL_0, PWR_MGMT_1_BIT::DEVICE_RESET | PWR_MGMT_1_BIT::SLEEP },\n-\t\t{ Register::ACCEL_CONFIG,  ACCEL_CONFIG_BIT::AFS_SEL_16G, 0 },\n \t\t{ Register::GYRO_CONFIG,   GYRO_CONFIG_BIT::FS_SEL_2000_DPS, 0 },\n-\t\t{ Register::USER_CTRL,     USER_CTRL_BIT::FIFO_EN | USER_CTRL_BIT::I2C_IF_DIS, USER_CTRL_BIT::I2C_MST_EN},\n+\t\t{ Register::ACCEL_CONFIG,  ACCEL_CONFIG_BIT::AFS_SEL_16G, 0 },\n \t\t{ Register::FIFO_EN,       FIFO_EN_BIT::XG_FIFO_EN | FIFO_EN_BIT::YG_FIFO_EN | FIFO_EN_BIT::ZG_FIFO_EN | FIFO_EN_BIT::ACCEL_FIFO_EN, FIFO_EN_BIT::TEMP_FIFO_EN },\n \t\t{ Register::INT_PIN_CFG,   INT_PIN_CFG_BIT::INT_LEVEL, 0 },\n-\t\t{ Register::INT_ENABLE,    INT_ENABLE_BIT::DATA_RDY_INT_EN, 0 }\n+\t\t{ Register::INT_ENABLE,    INT_ENABLE_BIT::DATA_RDY_INT_EN, 0 },\n+\t\t{ Register::USER_CTRL,     USER_CTRL_BIT::FIFO_EN | USER_CTRL_BIT::I2C_IF_DIS, 0 },\n+\t\t{ Register::PWR_MGMT_1,    PWR_MGMT_1_BIT::CLKSEL_0, PWR_MGMT_1_BIT::DEVICE_RESET | PWR_MGMT_1_BIT::SLEEP },\n \t};\n };"}]}