{"sha":"a4b0e3ecbe2d012eac7545cce14829866bacc813","node_id":"MDY6Q29tbWl0NTI5ODc5MDphNGIwZTNlY2JlMmQwMTJlYWM3NTQ1Y2NlMTQ4Mjk4NjZiYWNjODEz","commit":{"author":{"name":"px4dev","email":"px4@purgatory.org","date":"2013-07-06T05:54:44Z"},"committer":{"name":"px4dev","email":"px4@purgatory.org","date":"2013-07-06T05:54:44Z"},"message":"Add retry-on-error for non-protocol errors.\n\nAdd more performance counters; run test #1 faster.","tree":{"sha":"705e2c06df0d511543a99c7e06539bde81777e23","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/705e2c06df0d511543a99c7e06539bde81777e23"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/a4b0e3ecbe2d012eac7545cce14829866bacc813","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/a4b0e3ecbe2d012eac7545cce14829866bacc813","html_url":"https://github.com/PX4/PX4-Autopilot/commit/a4b0e3ecbe2d012eac7545cce14829866bacc813","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/a4b0e3ecbe2d012eac7545cce14829866bacc813/comments","author":{"login":"px4dev","id":2095699,"node_id":"MDQ6VXNlcjIwOTU2OTk=","avatar_url":"https://avatars.githubusercontent.com/u/2095699?v=4","gravatar_id":"","url":"https://api.github.com/users/px4dev","html_url":"https://github.com/px4dev","followers_url":"https://api.github.com/users/px4dev/followers","following_url":"https://api.github.com/users/px4dev/following{/other_user}","gists_url":"https://api.github.com/users/px4dev/gists{/gist_id}","starred_url":"https://api.github.com/users/px4dev/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/px4dev/subscriptions","organizations_url":"https://api.github.com/users/px4dev/orgs","repos_url":"https://api.github.com/users/px4dev/repos","events_url":"https://api.github.com/users/px4dev/events{/privacy}","received_events_url":"https://api.github.com/users/px4dev/received_events","type":"User","site_admin":false},"committer":{"login":"px4dev","id":2095699,"node_id":"MDQ6VXNlcjIwOTU2OTk=","avatar_url":"https://avatars.githubusercontent.com/u/2095699?v=4","gravatar_id":"","url":"https://api.github.com/users/px4dev","html_url":"https://github.com/px4dev","followers_url":"https://api.github.com/users/px4dev/followers","following_url":"https://api.github.com/users/px4dev/following{/other_user}","gists_url":"https://api.github.com/users/px4dev/gists{/gist_id}","starred_url":"https://api.github.com/users/px4dev/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/px4dev/subscriptions","organizations_url":"https://api.github.com/users/px4dev/orgs","repos_url":"https://api.github.com/users/px4dev/repos","events_url":"https://api.github.com/users/px4dev/events{/privacy}","received_events_url":"https://api.github.com/users/px4dev/received_events","type":"User","site_admin":false},"parents":[{"sha":"6871d2909b5be7eb93bf23aea771a86aa1b0ae3f","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/6871d2909b5be7eb93bf23aea771a86aa1b0ae3f","html_url":"https://github.com/PX4/PX4-Autopilot/commit/6871d2909b5be7eb93bf23aea771a86aa1b0ae3f"}],"stats":{"total":150,"additions":98,"deletions":52},"files":[{"sha":"7e4a54ea54621d6494e4dbfb0c2ed9c5150d94b5","filename":"src/drivers/px4io/interface_serial.cpp","status":"modified","additions":98,"deletions":52,"changes":150,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/a4b0e3ecbe2d012eac7545cce14829866bacc813/src%2Fdrivers%2Fpx4io%2Finterface_serial.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/a4b0e3ecbe2d012eac7545cce14829866bacc813/src%2Fdrivers%2Fpx4io%2Finterface_serial.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Fpx4io%2Finterface_serial.cpp?ref=a4b0e3ecbe2d012eac7545cce14829866bacc813","patch":"@@ -172,14 +172,16 @@ class PX4IO_serial : public PX4IO_interface\n \t/**\n \t * Performance counters.\n \t */\n+\tperf_counter_t\t\t_pc_txns;\n \tperf_counter_t\t\t_pc_dmasetup;\n+\tperf_counter_t\t\t_pc_retries;\n \tperf_counter_t\t\t_pc_timeouts;\n \tperf_counter_t\t\t_pc_crcerrs;\n \tperf_counter_t\t\t_pc_dmaerrs;\n \tperf_counter_t\t\t_pc_protoerrs;\n+\tperf_counter_t\t\t_pc_uerrs;\n \tperf_counter_t\t\t_pc_idle;\n \tperf_counter_t\t\t_pc_badidle;\n-\tperf_counter_t\t\t_pc_txns;\n \n };\n \n@@ -195,14 +197,16 @@ PX4IO_serial::PX4IO_serial() :\n \t_tx_dma(nullptr),\n \t_rx_dma(nullptr),\n \t_rx_dma_status(_dma_status_inactive),\n+\t_pc_txns(perf_alloc(PC_ELAPSED,\t\t\"txns     \")),\n \t_pc_dmasetup(perf_alloc(PC_ELAPSED,\t\"dmasetup \")),\n+\t_pc_retries(perf_alloc(PC_COUNT,\t\"retries  \")),\n \t_pc_timeouts(perf_alloc(PC_COUNT,\t\"timeouts \")),\n \t_pc_crcerrs(perf_alloc(PC_COUNT,\t\"crcerrs  \")),\n \t_pc_dmaerrs(perf_alloc(PC_COUNT,\t\"dmaerrs  \")),\n \t_pc_protoerrs(perf_alloc(PC_COUNT,\t\"protoerrs\")),\n+\t_pc_uerrs(perf_alloc(PC_COUNT,\t\t\"uarterrs \")),\n \t_pc_idle(perf_alloc(PC_COUNT,\t\t\"idle     \")),\n-\t_pc_badidle(perf_alloc(PC_COUNT,\t\"badidle  \")),\n-\t_pc_txns(perf_alloc(PC_ELAPSED,\t\t\"txns     \"))\n+\t_pc_badidle(perf_alloc(PC_COUNT,\t\"badidle  \"))\n {\n \t/* allocate DMA */\n \t_tx_dma = stm32_dmachannel(PX4IO_SERIAL_TX_DMAMAP);\n@@ -272,14 +276,16 @@ PX4IO_serial::~PX4IO_serial()\n \tsem_destroy(&_completion_semaphore);\n \tsem_destroy(&_bus_semaphore);\n \n+\tperf_free(_pc_txns);\n \tperf_free(_pc_dmasetup);\n+\tperf_free(_pc_retries);\n \tperf_free(_pc_timeouts);\n \tperf_free(_pc_crcerrs);\n \tperf_free(_pc_dmaerrs);\n \tperf_free(_pc_protoerrs);\n+\tperf_free(_pc_uerrs);\n \tperf_free(_pc_idle);\n \tperf_free(_pc_badidle);\n-\tperf_free(_pc_txns);\n \n \tif (g_interface == this)\n \t\tg_interface = nullptr;\n@@ -317,26 +323,29 @@ PX4IO_serial::test(unsigned mode)\n \t\treturn 0;\n \n \tcase 1:\n-\t\tlowsyslog(\"test 1\\n\");\n \t\t{\n+\t\t\tunsigned fails = 0;\n \t\t\tfor (unsigned count = 0;; count++) {\n \t\t\t\tuint16_t value = count & 0xffff;\n \n-\t\t\t\tset_reg(PX4IO_PAGE_TEST, PX4IO_P_TEST_LED, &value, 1);\n-\t\t\t\t/* ignore errors */\n+\t\t\t\tif (set_reg(PX4IO_PAGE_TEST, PX4IO_P_TEST_LED, &value, 1) != 0)\n+\t\t\t\t\tfails++;\n \t\t\t\t\t\n-\t\t\t\tif (count >= 100) {\n+\t\t\t\tif (count >= 1000) {\n+\t\t\t\t\tlowsyslog(\"==== test 1 : %u failures ====\\n\", fails);\n+\t\t\t\t\tperf_print_counter(_pc_txns);\n \t\t\t\t\tperf_print_counter(_pc_dmasetup);\n+\t\t\t\t\tperf_print_counter(_pc_retries);\n \t\t\t\t\tperf_print_counter(_pc_timeouts);\n \t\t\t\t\tperf_print_counter(_pc_crcerrs);\n \t\t\t\t\tperf_print_counter(_pc_dmaerrs);\n \t\t\t\t\tperf_print_counter(_pc_protoerrs);\n+\t\t\t\t\tperf_print_counter(_pc_uerrs);\n \t\t\t\t\tperf_print_counter(_pc_idle);\n \t\t\t\t\tperf_print_counter(_pc_badidle);\n-\t\t\t\t\tperf_print_counter(_pc_txns);\n \t\t\t\t\tcount = 0;\n \t\t\t\t}\n-\t\t\t\tusleep(10000);\n+\t\t\t\tusleep(1000);\n \t\t\t}\n \t\t\treturn 0;\n \t\t}\n@@ -350,22 +359,44 @@ PX4IO_serial::test(unsigned mode)\n int\n PX4IO_serial::set_reg(uint8_t page, uint8_t offset, const uint16_t *values, unsigned num_values)\n {\n-\tif (num_values > PKT_MAX_REGS)\n-\t\treturn -EINVAL;\n+\tif (num_values > PKT_MAX_REGS) {\n+\t\terrno = EINVAL;\n+\t\treturn -1;\n+\t}\n \n \tsem_wait(&_bus_semaphore);\n \n-\t_dma_buffer.count_code = num_values | PKT_CODE_WRITE;\n-\t_dma_buffer.page = page;\n-\t_dma_buffer.offset = offset;\n-\tmemcpy((void *)&_dma_buffer.regs[0], (void *)values, (2 * num_values));\n-\tfor (unsigned i = num_values; i < PKT_MAX_REGS; i++)\n-\t\t_dma_buffer.regs[i] = 0x55aa;\n+\tint result;\n+\tfor (unsigned retries = 0; retries < 3; retries++) {\n+\n+\t\t_dma_buffer.count_code = num_values | PKT_CODE_WRITE;\n+\t\t_dma_buffer.page = page;\n+\t\t_dma_buffer.offset = offset;\n+\t\tmemcpy((void *)&_dma_buffer.regs[0], (void *)values, (2 * num_values));\n+\t\tfor (unsigned i = num_values; i < PKT_MAX_REGS; i++)\n+\t\t\t_dma_buffer.regs[i] = 0x55aa;\n+\n+\t\t/* XXX implement check byte */\n \n-\t/* XXX implement check byte */\n+\t\t/* start the transaction and wait for it to complete */\n+\t\tresult = _wait_complete();\n \n-\t/* start the transaction and wait for it to complete */\n-\tint result = _wait_complete();\n+\t\t/* successful transaction? */\n+\t\tif (result == OK) {\n+\n+\t\t\t/* check result in packet */\n+\t\t\tif (PKT_CODE(_dma_buffer) == PKT_CODE_ERROR) {\n+\n+\t\t\t\t/* IO didn't like it - no point retrying */\n+\t\t\t\terrno = EINVAL;\n+\t\t\t\tresult = -1;\n+\t\t\t\tperf_count(_pc_protoerrs);\n+\t\t\t}\n+\n+\t\t\tbreak;\n+\t\t}\n+\t\tperf_count(_pc_retries);\n+\t}\n \n \tsem_post(&_bus_semaphore);\n \treturn result;\n@@ -379,23 +410,45 @@ PX4IO_serial::get_reg(uint8_t page, uint8_t offset, uint16_t *values, unsigned n\n \n \tsem_wait(&_bus_semaphore);\n \n-\t_dma_buffer.count_code = num_values | PKT_CODE_READ;\n-\t_dma_buffer.page = page;\n-\t_dma_buffer.offset = offset;\n+\tint result;\n+\tfor (unsigned retries = 0; retries < 3; retries++) {\n \n-\t/* start the transaction and wait for it to complete */\n-\tint result = _wait_complete();\n-\tif (result != OK)\n-\t\tgoto out;\n+\t\t_dma_buffer.count_code = num_values | PKT_CODE_READ;\n+\t\t_dma_buffer.page = page;\n+\t\t_dma_buffer.offset = offset;\n \n-\t/* compare the received count with the expected count */\n-\tif (PKT_COUNT(_dma_buffer) != num_values) {\n-\t\tresult = -EIO;\n-\t\tgoto out;\n-\t} else {\n-\t\t/* XXX implement check byte */\n-\t\t/* copy back the result */\n-\t\tmemcpy(values, &_dma_buffer.regs[0], (2 * num_values));\n+\t\t/* start the transaction and wait for it to complete */\n+\t\tresult = _wait_complete();\n+\n+\t\t/* successful transaction? */\n+\t\tif (result == OK) {\n+\n+\t\t\t/* check result in packet */\n+\t\t\tif (PKT_CODE(_dma_buffer) == PKT_CODE_ERROR) {\n+\n+\t\t\t\t/* IO didn't like it - no point retrying */\n+\t\t\t\terrno = EINVAL;\n+\t\t\t\tresult = -1;\n+\t\t\t\tperf_count(_pc_protoerrs);\n+\n+\t\t\t/* compare the received count with the expected count */\n+\t\t\t} else if (PKT_COUNT(_dma_buffer) != num_values) {\n+\n+\t\t\t\t/* IO returned the wrong number of registers - no point retrying */\n+\t\t\t\terrno = EIO;\n+\t\t\t\tresult = -1;\n+\t\t\t\tperf_count(_pc_protoerrs);\n+\n+\t\t\t/* successful read */\t\t\t\t\n+\t\t\t} else {\n+\n+\t\t\t\t/* copy back the result */\n+\t\t\t\tmemcpy(values, &_dma_buffer.regs[0], (2 * num_values));\n+\t\t\t}\n+\n+\t\t\tbreak;\n+\t\t}\n+\t\tperf_count(_pc_retries);\n \t}\n out:\n \tsem_post(&_bus_semaphore);\n@@ -463,11 +516,11 @@ PX4IO_serial::_wait_complete()\n \t/* compute the deadline for a 5ms timeout */\n \tstruct timespec abstime;\n \tclock_gettime(CLOCK_REALTIME, &abstime);\n-#if 1\n+#if 0\n \tabstime.tv_sec++;\t\t/* long timeout for testing */\n #else\n-\tabstime.tv_nsec += 5000000;\t/* 5ms timeout */\n-\twhile (abstime.tv_nsec > 1000000000) {\n+\tabstime.tv_nsec += 10000000;\t/* 0ms timeout */\n+\tif (abstime.tv_nsec > 1000000000) {\n \t\tabstime.tv_sec++;\n \t\tabstime.tv_nsec -= 1000000000;\n \t}\n@@ -487,32 +540,25 @@ PX4IO_serial::_wait_complete()\n \t\t\t\tbreak;\n \t\t\t}\n \n-\t\t\t/* check packet CRC */\n+\t\t\t/* check packet CRC - corrupt packet errors mean IO receive CRC error */\n \t\t\tuint8_t crc = _dma_buffer.crc;\n \t\t\t_dma_buffer.crc = 0;\n-\t\t\tif (crc != crc_packet(_dma_buffer)) {\n+\t\t\tif ((crc != crc_packet(_dma_buffer)) | (PKT_CODE(_dma_buffer) == PKT_CODE_CORRUPT)) {\n \t\t\t\tperf_count(_pc_crcerrs);\n \t\t\t\tret = -1;\n \t\t\t\terrno = EIO;\n \t\t\t\tbreak;\n \t\t\t}\n \n-\t\t\t/* check packet response code */\n-\t\t\tif (PKT_CODE(_dma_buffer) != PKT_CODE_SUCCESS) {\n-\t\t\t\tperf_count(_pc_protoerrs);\n-\t\t\t\tret = -1;\n-\t\t\t\terrno = EIO;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\n-\t\t\t/* successful txn */\n+\t\t\t/* successful txn (may still be reporting an error) */\n \t\t\tbreak;\n \t\t}\n \n \t\tif (errno == ETIMEDOUT) {\n \t\t\t/* something has broken - clear out any partial DMA state and reconfigure */\n \t\t\t_abort_dma();\n \t\t\tperf_count(_pc_timeouts);\n+\t\t\tperf_cancel(_pc_txns);\t\t/* don't count this as a transaction */\n \t\t\tbreak;\n \t\t}\n \n@@ -577,7 +623,6 @@ PX4IO_serial::_do_interrupt()\n \tuint32_t sr = rSR;\t/* get UART status register */\n \t(void)rDR;\t\t/* read DR to clear status */\n \n-#if 0\n \tif (sr & (USART_SR_ORE |\t/* overrun error - packet was too big for DMA or DMA was too slow */\n \t\tUSART_SR_NE |\t\t/* noise error - we have lost a byte due to noise */\n \t\tUSART_SR_FE)) {\t\t/* framing error - start/stop bit lost or line break */\n@@ -588,6 +633,7 @@ PX4IO_serial::_do_interrupt()\n \t\t */\n \t\tif (_rx_dma_status == _dma_status_waiting) {\n \t\t\t_abort_dma();\n+\t\t\tperf_count(_pc_uerrs);\n \n \t\t\t/* complete DMA as though in error */\n \t\t\t_do_rx_dma_callback(DMA_STATUS_TEIF);\n@@ -600,7 +646,7 @@ PX4IO_serial::_do_interrupt()\n \t\t/* don't attempt to handle IDLE if it's set - things went bad */\n \t\treturn;\n \t}\n-#endif\n+\n \tif (sr & USART_SR_IDLE) {\n \n \t\t/* if there is DMA reception going on, this is a short packet */"}]}