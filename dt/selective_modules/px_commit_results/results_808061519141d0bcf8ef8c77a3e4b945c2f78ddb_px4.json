{"sha":"808061519141d0bcf8ef8c77a3e4b945c2f78ddb","node_id":"MDY6Q29tbWl0NTI5ODc5MDo4MDgwNjE1MTkxNDFkMGJjZjhlZjhjNzdhM2U0Yjk0NWMyZjc4ZGRi","commit":{"author":{"name":"bresch","email":"brescianimathieu@gmail.com","date":"2019-12-24T09:48:36Z"},"committer":{"name":"Daniel Agar","email":"daniel@agar.ca","date":"2019-12-24T18:18:47Z"},"message":"PreFlightChecker: add spike limit argument for innovation check and\nincrease optical flow test limits.","tree":{"sha":"816ed56113528efbf6b838dc86d8c908a95fdbff","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/816ed56113528efbf6b838dc86d8c908a95fdbff"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/808061519141d0bcf8ef8c77a3e4b945c2f78ddb","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/808061519141d0bcf8ef8c77a3e4b945c2f78ddb","html_url":"https://github.com/PX4/PX4-Autopilot/commit/808061519141d0bcf8ef8c77a3e4b945c2f78ddb","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/808061519141d0bcf8ef8c77a3e4b945c2f78ddb/comments","author":{"login":"bresch","id":14822839,"node_id":"MDQ6VXNlcjE0ODIyODM5","avatar_url":"https://avatars.githubusercontent.com/u/14822839?v=4","gravatar_id":"","url":"https://api.github.com/users/bresch","html_url":"https://github.com/bresch","followers_url":"https://api.github.com/users/bresch/followers","following_url":"https://api.github.com/users/bresch/following{/other_user}","gists_url":"https://api.github.com/users/bresch/gists{/gist_id}","starred_url":"https://api.github.com/users/bresch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bresch/subscriptions","organizations_url":"https://api.github.com/users/bresch/orgs","repos_url":"https://api.github.com/users/bresch/repos","events_url":"https://api.github.com/users/bresch/events{/privacy}","received_events_url":"https://api.github.com/users/bresch/received_events","type":"User","site_admin":false},"committer":{"login":"dagar","id":84712,"node_id":"MDQ6VXNlcjg0NzEy","avatar_url":"https://avatars.githubusercontent.com/u/84712?v=4","gravatar_id":"","url":"https://api.github.com/users/dagar","html_url":"https://github.com/dagar","followers_url":"https://api.github.com/users/dagar/followers","following_url":"https://api.github.com/users/dagar/following{/other_user}","gists_url":"https://api.github.com/users/dagar/gists{/gist_id}","starred_url":"https://api.github.com/users/dagar/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dagar/subscriptions","organizations_url":"https://api.github.com/users/dagar/orgs","repos_url":"https://api.github.com/users/dagar/repos","events_url":"https://api.github.com/users/dagar/events{/privacy}","received_events_url":"https://api.github.com/users/dagar/received_events","type":"User","site_admin":false},"parents":[{"sha":"b6b8a9a76e45ed93367604cd9fab51cd8a02362c","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/b6b8a9a76e45ed93367604cd9fab51cd8a02362c","html_url":"https://github.com/PX4/PX4-Autopilot/commit/b6b8a9a76e45ed93367604cd9fab51cd8a02362c"}],"stats":{"total":44,"additions":24,"deletions":20},"files":[{"sha":"bdb70498fad4d254aa4c1b1f0e17f4bf4d30beb9","filename":"src/modules/ekf2/Utility/PreFlightChecker.cpp","status":"modified","additions":11,"deletions":9,"changes":20,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/808061519141d0bcf8ef8c77a3e4b945c2f78ddb/src%2Fmodules%2Fekf2%2FUtility%2FPreFlightChecker.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/808061519141d0bcf8ef8c77a3e4b945c2f78ddb/src%2Fmodules%2Fekf2%2FUtility%2FPreFlightChecker.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fekf2%2FUtility%2FPreFlightChecker.cpp?ref=808061519141d0bcf8ef8c77a3e4b945c2f78ddb","patch":"@@ -55,7 +55,7 @@ bool PreFlightChecker::preFlightCheckHeadingFailed(const estimator_innovations_s\n \n \tconst float heading_innov_lpf = _filter_heading_innov.update(innov.heading, alpha, heading_innov_spike_lim);\n \n-\treturn checkInnovFailed(innov.heading, heading_innov_lpf, heading_test_limit);\n+\treturn checkInnovFailed(heading_innov_lpf, innov.heading, heading_test_limit, heading_innov_spike_lim);\n }\n \n float PreFlightChecker::selectHeadingTestLimit()\n@@ -79,15 +79,15 @@ bool PreFlightChecker::preFlightCheckHorizVelFailed(const estimator_innovations_\n \t\tVector2f vel_ne_innov_lpf;\n \t\tvel_ne_innov_lpf(0) = _filter_vel_n_innov.update(vel_ne_innov(0), alpha, _vel_innov_spike_lim);\n \t\tvel_ne_innov_lpf(1) = _filter_vel_n_innov.update(vel_ne_innov(1), alpha, _vel_innov_spike_lim);\n-\t\thas_failed |= checkInnov2DFailed(vel_ne_innov, vel_ne_innov_lpf, _vel_innov_test_lim);\n+\t\thas_failed |= checkInnov2DFailed(vel_ne_innov_lpf, vel_ne_innov, _vel_innov_test_lim, _vel_innov_spike_lim);\n \t}\n \n \tif (_is_using_flow_aiding) {\n \t\tconst Vector2f flow_innov = Vector2f(innov.flow);\n \t\tVector2f flow_innov_lpf;\n \t\tflow_innov_lpf(0) = _filter_flow_x_innov.update(flow_innov(0), alpha, _flow_innov_spike_lim);\n \t\tflow_innov_lpf(1) = _filter_flow_x_innov.update(flow_innov(1), alpha, _flow_innov_spike_lim);\n-\t\thas_failed |= checkInnov2DFailed(flow_innov, flow_innov_lpf, _flow_innov_test_lim);\n+\t\thas_failed |= checkInnov2DFailed(flow_innov_lpf, flow_innov, _flow_innov_test_lim, 5.f * _flow_innov_spike_lim);\n \t}\n \n \treturn has_failed;\n@@ -97,26 +97,28 @@ bool PreFlightChecker::preFlightCheckVertVelFailed(const estimator_innovations_s\n {\n \tconst float vel_d_innov = fmaxf(fabsf(innov.gps_vvel), fabs(innov.ev_vvel));     // only temporary solution\n \tconst float vel_d_innov_lpf = _filter_vel_d_innov.update(vel_d_innov, alpha, _vel_innov_spike_lim);\n-\treturn checkInnovFailed(vel_d_innov, vel_d_innov_lpf, _vel_innov_test_lim);\n+\treturn checkInnovFailed(vel_d_innov_lpf, vel_d_innov, _vel_innov_test_lim, _vel_innov_spike_lim);\n }\n \n bool PreFlightChecker::preFlightCheckHeightFailed(const estimator_innovations_s &innov, const float alpha)\n {\n \tconst float hgt_innov = fmaxf(fabsf(innov.gps_vpos), fmaxf(fabs(innov.ev_vpos),\n \t\t\t\t      fabs(innov.rng_vpos)));    // only temporary solution\n \tconst float hgt_innov_lpf = _filter_hgt_innov.update(hgt_innov, alpha, _hgt_innov_spike_lim);\n-\treturn checkInnovFailed(hgt_innov, hgt_innov_lpf, _hgt_innov_test_lim);\n+\treturn checkInnovFailed(hgt_innov_lpf, hgt_innov, _hgt_innov_test_lim, _hgt_innov_spike_lim);\n }\n \n-bool PreFlightChecker::checkInnovFailed(const float innov, const float innov_lpf, const float test_limit)\n+bool PreFlightChecker::checkInnovFailed(const float innov_lpf, const float innov, const float test_limit,\n+\t\t\t\t\tconst float spike_limit)\n {\n-\treturn fabsf(innov_lpf) > test_limit || fabsf(innov) > 2.0f * test_limit;\n+\treturn fabsf(innov_lpf) > test_limit || fabsf(innov) > spike_limit;\n }\n \n-bool PreFlightChecker::checkInnov2DFailed(const Vector2f &innov, const Vector2f &innov_lpf, const float test_limit)\n+bool PreFlightChecker::checkInnov2DFailed(const Vector2f &innov_lpf, const Vector2f &innov, const float test_limit,\n+\t\tconst float spike_limit)\n {\n \treturn innov_lpf.norm_squared() > sq(test_limit)\n-\t       || innov.norm_squared() > sq(2.0f * test_limit);\n+\t       || innov.norm_squared() > sq(spike_limit);\n }\n \n void PreFlightChecker::reset()"},{"sha":"4a7b962e7d4f3b808295e8c8c2ba1fb2d3df5618","filename":"src/modules/ekf2/Utility/PreFlightChecker.hpp","status":"modified","additions":13,"deletions":11,"changes":24,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/808061519141d0bcf8ef8c77a3e4b945c2f78ddb/src%2Fmodules%2Fekf2%2FUtility%2FPreFlightChecker.hpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/808061519141d0bcf8ef8c77a3e4b945c2f78ddb/src%2Fmodules%2Fekf2%2FUtility%2FPreFlightChecker.hpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fekf2%2FUtility%2FPreFlightChecker.hpp?ref=808061519141d0bcf8ef8c77a3e4b945c2f78ddb","patch":"@@ -104,26 +104,28 @@ class PreFlightChecker\n \t/*\n \t * Check if the innovation fails the test\n \t * To pass the test, the following conditions should be true:\n-\t * innov <= test_limit\n-\t * innov_lpf <= 2 * test_limit\n-\t * @param innov the current unfiltered innovation\n+\t * innov_lpf <= test_limit\n+\t * innov <= spike_limit\n \t * @param innov_lpf the low-pass filtered innovation\n-\t * @param test_limit the magnitude test limit\n+\t * @param innov the current unfiltered innovation\n+\t * @param test_limit the magnitude test limit for innov_lpf\n+\t * @param spike_limit the magnitude test limit for innov\n \t * @return true if the check failed the test, false otherwise\n \t */\n-\tstatic bool checkInnovFailed(float innov, float innov_lpf, float test_limit);\n+\tstatic bool checkInnovFailed(float innov_lpf, float innov, float test_limit, float spike_limit);\n \n \t/*\n \t * Check if the a innovation of a 2D vector fails the test\n \t * To pass the test, the following conditions should be true:\n-\t * innov <= test_limit\n-\t * innov_lpf <= 2 * test_limit\n-\t * @param innov the current unfiltered innovation\n+\t * innov_lpf <= test_limit\n+\t * innov <= spike_limit\n \t * @param innov_lpf the low-pass filtered innovation\n-\t * @param test_limit the magnitude test limit\n+\t * @param innov the current unfiltered innovation\n+\t * @param test_limit the magnitude test limit for innov_lpf\n+\t * @param spike_limit the magnitude test limit for innov\n \t * @return true if the check failed the test, false otherwise\n \t */\n-\tstatic bool checkInnov2DFailed(const Vector2f &innov, const Vector2f &innov_lpf, float test_limit);\n+\tstatic bool checkInnov2DFailed(const Vector2f &innov_lpf, const Vector2f &innov, float test_limit, float spike_limit);\n \n \tstatic constexpr float sq(float var) { return var * var; }\n \n@@ -168,7 +170,7 @@ class PreFlightChecker\n \t// Maximum permissible yaw innovation to pass pre-flight checks when not aiding inertial nav using NE frame observations (rad)\n \tstatic constexpr float _heading_innov_test_lim = 0.52f;\n \t// Maximum permissible flow innovation to pass pre-flight checks\n-\tstatic constexpr float _flow_innov_test_lim = 0.1f;\n+\tstatic constexpr float _flow_innov_test_lim = 0.25f;\n \t// Preflight velocity innovation spike limit (m/sec)\n \tstatic constexpr float _vel_innov_spike_lim = 2.0f * _vel_innov_test_lim;\n \t// Preflight position innovation spike limit (m)"}]}