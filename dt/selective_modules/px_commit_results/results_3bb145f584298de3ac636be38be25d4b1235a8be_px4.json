{"sha":"3bb145f584298de3ac636be38be25d4b1235a8be","node_id":"MDY6Q29tbWl0NTI5ODc5MDozYmIxNDVmNTg0Mjk4ZGUzYWM2MzZiZTM4YmUyNWQ0YjEyMzVhOGJl","commit":{"author":{"name":"Lorenz Meier","email":"lm@inf.ethz.ch","date":"2013-01-09T08:39:51Z"},"committer":{"name":"Lorenz Meier","email":"lm@inf.ethz.ch","date":"2013-01-09T08:39:51Z"},"message":"Enabled and tested ring buffer, logging at full 250 Hz sensor rate","tree":{"sha":"31fb30bcbe0c35f8e576948ee2082be17e5d7596","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/31fb30bcbe0c35f8e576948ee2082be17e5d7596"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/3bb145f584298de3ac636be38be25d4b1235a8be","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/3bb145f584298de3ac636be38be25d4b1235a8be","html_url":"https://github.com/PX4/PX4-Autopilot/commit/3bb145f584298de3ac636be38be25d4b1235a8be","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/3bb145f584298de3ac636be38be25d4b1235a8be/comments","author":{"login":"LorenzMeier","id":1208119,"node_id":"MDQ6VXNlcjEyMDgxMTk=","avatar_url":"https://avatars.githubusercontent.com/u/1208119?v=4","gravatar_id":"","url":"https://api.github.com/users/LorenzMeier","html_url":"https://github.com/LorenzMeier","followers_url":"https://api.github.com/users/LorenzMeier/followers","following_url":"https://api.github.com/users/LorenzMeier/following{/other_user}","gists_url":"https://api.github.com/users/LorenzMeier/gists{/gist_id}","starred_url":"https://api.github.com/users/LorenzMeier/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/LorenzMeier/subscriptions","organizations_url":"https://api.github.com/users/LorenzMeier/orgs","repos_url":"https://api.github.com/users/LorenzMeier/repos","events_url":"https://api.github.com/users/LorenzMeier/events{/privacy}","received_events_url":"https://api.github.com/users/LorenzMeier/received_events","type":"User","site_admin":false},"committer":{"login":"LorenzMeier","id":1208119,"node_id":"MDQ6VXNlcjEyMDgxMTk=","avatar_url":"https://avatars.githubusercontent.com/u/1208119?v=4","gravatar_id":"","url":"https://api.github.com/users/LorenzMeier","html_url":"https://github.com/LorenzMeier","followers_url":"https://api.github.com/users/LorenzMeier/followers","following_url":"https://api.github.com/users/LorenzMeier/following{/other_user}","gists_url":"https://api.github.com/users/LorenzMeier/gists{/gist_id}","starred_url":"https://api.github.com/users/LorenzMeier/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/LorenzMeier/subscriptions","organizations_url":"https://api.github.com/users/LorenzMeier/orgs","repos_url":"https://api.github.com/users/LorenzMeier/repos","events_url":"https://api.github.com/users/LorenzMeier/events{/privacy}","received_events_url":"https://api.github.com/users/LorenzMeier/received_events","type":"User","site_admin":false},"parents":[{"sha":"b78a430424f6cfef1a6889a729043688634059a1","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/b78a430424f6cfef1a6889a729043688634059a1","html_url":"https://github.com/PX4/PX4-Autopilot/commit/b78a430424f6cfef1a6889a729043688634059a1"}],"stats":{"total":174,"additions":115,"deletions":59},"files":[{"sha":"997acc47ad0782c299022a4b3608f5ff3d6726e0","filename":"apps/sdlog/sdlog.c","status":"modified","additions":115,"deletions":59,"changes":174,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/3bb145f584298de3ac636be38be25d4b1235a8be/apps%2Fsdlog%2Fsdlog.c","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/3bb145f584298de3ac636be38be25d4b1235a8be/apps%2Fsdlog%2Fsdlog.c","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/apps%2Fsdlog%2Fsdlog.c?ref=3bb145f584298de3ac636be38be25d4b1235a8be","patch":"@@ -36,12 +36,14 @@\n  * @file sdlog.c\n  * @author Lorenz Meier <lm@inf.ethz.ch>\n  *\n- * Simple SD logger for flight data\n+ * Simple SD logger for flight data. Buffers new sensor values and\n+ * does the heavy SD I/O in a low-priority worker thread.\n  */\n \n #include <nuttx/config.h>\n #include <sys/types.h>\n #include <sys/stat.h>\n+#include <sys/prctl.h>\n #include <fcntl.h>\n #include <errno.h>\n #include <unistd.h>\n@@ -81,6 +83,10 @@ static const char *mfile_in = \"/etc/logging/logconv.m\";\n int sysvector_file = -1;\n struct sdlog_logbuffer lb;\n \n+/* mutex / condition to synchronize threads */\n+pthread_mutex_t sysvector_mutex;\n+pthread_cond_t sysvector_cond;\n+\n /**\n  * System state vector log buffer writing\n  */\n@@ -246,15 +252,32 @@ int create_logfolder(char *folder_path)\n static void *\n sdlog_sysvector_write_thread(void *arg)\n {\n+\t/* set name */\n+\tprctl(PR_SET_NAME, \"sdlog microSD I/O\", 0);\n+\n \tstruct sdlog_logbuffer *logbuf = (struct sdlog_logbuffer *)arg;\n \n \tint poll_count = 0;\n \tstruct sdlog_sysvector sysvect;\n \tmemset(&sysvect, 0, sizeof(sysvect));\n \n \twhile (!thread_should_exit) {\n-\t\t//pthread_mutex..\n-\t\tif (sdlog_logbuffer_read(logbuf, &sysvect) == OK) {\n+\t\t\n+\t\t/* make sure threads are synchronized */\n+\t\tpthread_mutex_lock(&sysvector_mutex);\n+\n+\t\t/* only wait if no data is available to process */\n+\t\tif (sdlog_logbuffer_is_empty(logbuf)) {\n+\t\t\t/* blocking wait for new data at this line */\n+\t\t\tpthread_cond_wait(&sysvector_cond, &sysvector_mutex);\n+\t\t}\n+\n+\t\t/* only quickly load data, do heavy I/O a few lines down */\n+\t\tint ret = sdlog_logbuffer_read(logbuf, &sysvect);\n+\t\t/* continue */\n+\t\tpthread_mutex_unlock(&sysvector_mutex);\n+\n+\t\tif (ret == OK) {\n \t\t\tsysvector_bytes += write(sysvector_file, (const char *)&sysvect, sizeof(sysvect));\n \t\t}\n \n@@ -263,7 +286,6 @@ sdlog_sysvector_write_thread(void *arg)\n \t\t}\n \n \t\tpoll_count++;\n-\t\tusleep(3000);\n \t}\n \n \tfsync(sysvector_file);\n@@ -287,6 +309,8 @@ sysvector_write_start(struct sdlog_logbuffer *logbuf)\n \tpthread_t thread;\n \tpthread_create(&thread, &receiveloop_attr, sdlog_sysvector_write_thread, logbuf);\n \treturn thread;\n+\n+\t// XXX we have to destroy the attr at some point\n }\n \n \n@@ -504,23 +528,64 @@ int sdlog_thread_main(int argc, char *argv[])\n \n \tthread_running = true;\n \n-\t/* Initialize log buffer with a size of 5 */\n-\tsdlog_logbuffer_init(&lb, 5);\n+\t/* initialize log buffer with a size of 10 */\n+\tsdlog_logbuffer_init(&lb, 10);\n+\n+\t/* initialize thread synchronization */\n+\tpthread_mutex_init(&sysvector_mutex, NULL);\n+  \tpthread_cond_init(&sysvector_cond, NULL);\n+\n \t/* start logbuffer emptying thread */\n \tpthread_t sysvector_pthread = sysvector_write_start(&lb);\n \n \tstarttime = hrt_absolute_time();\n \n+\t// XXX clock the log for now with the gyro output rate / 2\n+\tstruct pollfd gyro_fd;\n+\tgyro_fd.fd = subs.sensor_sub;\n+\tgyro_fd.events = POLLIN;\n+\n+\t/* log every 2nd value (skip one) */\n+\tint skip_value = 0;\n+\t/* track skipping */\n+\tint skip_count = 0;\n+\n \twhile (!thread_should_exit) {\n \n+\t\t// XXX only use gyro for now\n+\t\tint poll_ret = poll(&gyro_fd, 1, 1000);\n+\n \t\t// int poll_ret = poll(fds, fdsc_count, timeout);\n \n-\t\t// /* handle the poll result */\n-\t\t// if (poll_ret == 0) {\n-\t\t// \t/* XXX this means none of our providers is giving us data - might be an error? */\n-\t\t// } else if (poll_ret < 0) {\n-\t\t// \t/* XXX this is seriously bad - should be an emergency */\n-\t\t// } else {\n+\t\t/* handle the poll result */\n+\t\tif (poll_ret == 0) {\n+\t\t\t/* XXX this means none of our providers is giving us data - might be an error? */\n+\t\t} else if (poll_ret < 0) {\n+\t\t\t/* XXX this is seriously bad - should be an emergency */\n+\t\t} else {\n+\n+\t\t\t/* always copy sensors raw data into local buffer, since poll flags won't clear else */\n+\t\t\torb_copy(ORB_ID(sensor_combined), subs.sensor_sub, &buf.raw);\n+\t\t\torb_copy(ORB_ID_VEHICLE_ATTITUDE_CONTROLS, subs.controls_0_sub, &buf.act_controls);\n+\t\t\torb_copy(ORB_ID_VEHICLE_ATTITUDE_CONTROLS_EFFECTIVE, subs.controls_effective_0_sub, &buf.act_controls_effective);\n+\t\t\t/* copy actuator data into local buffer */\n+\t\t\torb_copy(ORB_ID(actuator_outputs_0), subs.act_0_sub, &buf.act_outputs);\n+\t\t\torb_copy(ORB_ID(vehicle_attitude_setpoint), subs.spa_sub, &buf.att_sp);\n+\t\t\torb_copy(ORB_ID(vehicle_gps_position), subs.gps_pos_sub, &buf.gps_pos);\n+\t\t\torb_copy(ORB_ID(vehicle_local_position), subs.local_pos_sub, &buf.local_pos);\n+\t\t\torb_copy(ORB_ID(vehicle_global_position), subs.global_pos_sub, &buf.global_pos);\n+\t\t\torb_copy(ORB_ID(vehicle_attitude), subs.att_sub, &buf.att);\n+\t\t\torb_copy(ORB_ID(vehicle_vicon_position), subs.vicon_pos_sub, &buf.vicon_pos);\n+\t\t\torb_copy(ORB_ID(optical_flow), subs.flow_sub, &buf.flow);\n+\n+\t\t\tif (skip_count < skip_value) {\n+\t\t\t\tskip_count++;\n+\t\t\t\t/* do not log data */\n+\t\t\t\tcontinue;\n+\t\t\t} else {\n+\t\t\t\t/* log data, reset */\n+\t\t\t\tskip_count = 0;\n+\t\t\t}\n \n \t\t// \tint ifds = 0;\n \n@@ -581,60 +646,51 @@ int sdlog_thread_main(int argc, char *argv[])\n \t\t// \t\t/* write out */\n \t\t// \t\tactuator_controls_bytes += write(actuator_controls_file, (const char*)&buf.act_controls, sizeof(buf.act_controls));\n \t\t// \t}\n-\t\t// }\n-\n-\n-\t\t/* copy sensors raw data into local buffer */\n-\t\torb_copy(ORB_ID(sensor_combined), subs.sensor_sub, &buf.raw);\n-\t\torb_copy(ORB_ID_VEHICLE_ATTITUDE_CONTROLS, subs.controls_0_sub, &buf.act_controls);\n-\t\torb_copy(ORB_ID_VEHICLE_ATTITUDE_CONTROLS_EFFECTIVE, subs.controls_effective_0_sub, &buf.act_controls_effective);\n-\t\t/* copy actuator data into local buffer */\n-\t\torb_copy(ORB_ID(actuator_outputs_0), subs.act_0_sub, &buf.act_outputs);\n-\t\torb_copy(ORB_ID(vehicle_attitude_setpoint), subs.spa_sub, &buf.att_sp);\n-\t\torb_copy(ORB_ID(vehicle_gps_position), subs.gps_pos_sub, &buf.gps_pos);\n-\t\torb_copy(ORB_ID(vehicle_local_position), subs.local_pos_sub, &buf.local_pos);\n-\t\torb_copy(ORB_ID(vehicle_global_position), subs.global_pos_sub, &buf.global_pos);\n-\t\torb_copy(ORB_ID(vehicle_attitude), subs.att_sub, &buf.att);\n-\t\torb_copy(ORB_ID(vehicle_vicon_position), subs.vicon_pos_sub, &buf.vicon_pos);\n-\t\torb_copy(ORB_ID(optical_flow), subs.flow_sub, &buf.flow);\n-\n-\t\tstruct sdlog_sysvector sysvect = {\n-\t\t\t.timestamp = buf.raw.timestamp,\n-\t\t\t.gyro = {buf.raw.gyro_rad_s[0], buf.raw.gyro_rad_s[1], buf.raw.gyro_rad_s[2]},\n-\t\t\t.accel = {buf.raw.accelerometer_m_s2[0], buf.raw.accelerometer_m_s2[1], buf.raw.accelerometer_m_s2[2]},\n-\t\t\t.mag = {buf.raw.magnetometer_ga[0], buf.raw.magnetometer_ga[1], buf.raw.magnetometer_ga[2]},\n-\t\t\t.baro = buf.raw.baro_pres_mbar,\n-\t\t\t.baro_alt = buf.raw.baro_alt_meter,\n-\t\t\t.baro_temp = buf.raw.baro_temp_celcius,\n-\t\t\t.control = {buf.act_controls.control[0], buf.act_controls.control[1], buf.act_controls.control[2], buf.act_controls.control[3]},\n-\t\t\t.actuators = {\n-\t\t\t\tbuf.act_outputs.output[0], buf.act_outputs.output[1], buf.act_outputs.output[2], buf.act_outputs.output[3],\n-\t\t\t\tbuf.act_outputs.output[4], buf.act_outputs.output[5], buf.act_outputs.output[6], buf.act_outputs.output[7]\n-\t\t\t},\n-\t\t\t.vbat = 0.0f, /* XXX use battery_status uORB topic */\n-\t\t\t.adc = {buf.raw.adc_voltage_v[0], buf.raw.adc_voltage_v[1], buf.raw.adc_voltage_v[2]},\n-\t\t\t.local_position = {buf.local_pos.x, buf.local_pos.y, buf.local_pos.z},\n-\t\t\t.gps_raw_position = {buf.gps_pos.lat, buf.gps_pos.lon, buf.gps_pos.alt},\n-\t\t\t.attitude = {buf.att.pitch, buf.att.roll, buf.att.yaw},\n-\t\t\t.rotMatrix = {buf.att.R[0][0], buf.att.R[0][1], buf.att.R[0][2], buf.att.R[1][0], buf.att.R[1][1], buf.att.R[1][2], buf.att.R[2][0], buf.att.R[2][1], buf.att.R[2][2]},\n-\t\t\t.vicon = {buf.vicon_pos.x, buf.vicon_pos.y, buf.vicon_pos.z, buf.vicon_pos.roll, buf.vicon_pos.pitch, buf.vicon_pos.yaw},\n-\t\t\t.control_effective = {buf.act_controls_effective.control_effective[0], buf.act_controls_effective.control_effective[1], buf.act_controls_effective.control_effective[2], buf.act_controls_effective.control_effective[3]},\n-\t\t\t.flow = {buf.flow.flow_raw_x, buf.flow.flow_raw_y, buf.flow.flow_comp_x_m, buf.flow.flow_comp_y_m, buf.flow.ground_distance_m, buf.flow.quality}\n-\t\t\t/* XXX add calculated airspeed */\n-\t\t};\n-\n-\t\t/* put into buffer for later IO */\n-\t\tsdlog_logbuffer_write(&lb, &sysvect);\n-\t\t// XXX notify writing thread through pthread mutex\n-\n-\t\tusleep(3500);   // roughly 150 Hz\n+\n+\t\t\tstruct sdlog_sysvector sysvect = {\n+\t\t\t\t.timestamp = buf.raw.timestamp,\n+\t\t\t\t.gyro = {buf.raw.gyro_rad_s[0], buf.raw.gyro_rad_s[1], buf.raw.gyro_rad_s[2]},\n+\t\t\t\t.accel = {buf.raw.accelerometer_m_s2[0], buf.raw.accelerometer_m_s2[1], buf.raw.accelerometer_m_s2[2]},\n+\t\t\t\t.mag = {buf.raw.magnetometer_ga[0], buf.raw.magnetometer_ga[1], buf.raw.magnetometer_ga[2]},\n+\t\t\t\t.baro = buf.raw.baro_pres_mbar,\n+\t\t\t\t.baro_alt = buf.raw.baro_alt_meter,\n+\t\t\t\t.baro_temp = buf.raw.baro_temp_celcius,\n+\t\t\t\t.control = {buf.act_controls.control[0], buf.act_controls.control[1], buf.act_controls.control[2], buf.act_controls.control[3]},\n+\t\t\t\t.actuators = {\n+\t\t\t\t\tbuf.act_outputs.output[0], buf.act_outputs.output[1], buf.act_outputs.output[2], buf.act_outputs.output[3],\n+\t\t\t\t\tbuf.act_outputs.output[4], buf.act_outputs.output[5], buf.act_outputs.output[6], buf.act_outputs.output[7]\n+\t\t\t\t},\n+\t\t\t\t.vbat = 0.0f, /* XXX use battery_status uORB topic */\n+\t\t\t\t.adc = {buf.raw.adc_voltage_v[0], buf.raw.adc_voltage_v[1], buf.raw.adc_voltage_v[2]},\n+\t\t\t\t.local_position = {buf.local_pos.x, buf.local_pos.y, buf.local_pos.z},\n+\t\t\t\t.gps_raw_position = {buf.gps_pos.lat, buf.gps_pos.lon, buf.gps_pos.alt},\n+\t\t\t\t.attitude = {buf.att.pitch, buf.att.roll, buf.att.yaw},\n+\t\t\t\t.rotMatrix = {buf.att.R[0][0], buf.att.R[0][1], buf.att.R[0][2], buf.att.R[1][0], buf.att.R[1][1], buf.att.R[1][2], buf.att.R[2][0], buf.att.R[2][1], buf.att.R[2][2]},\n+\t\t\t\t.vicon = {buf.vicon_pos.x, buf.vicon_pos.y, buf.vicon_pos.z, buf.vicon_pos.roll, buf.vicon_pos.pitch, buf.vicon_pos.yaw},\n+\t\t\t\t.control_effective = {buf.act_controls_effective.control_effective[0], buf.act_controls_effective.control_effective[1], buf.act_controls_effective.control_effective[2], buf.act_controls_effective.control_effective[3]},\n+\t\t\t\t.flow = {buf.flow.flow_raw_x, buf.flow.flow_raw_y, buf.flow.flow_comp_x_m, buf.flow.flow_comp_y_m, buf.flow.ground_distance_m, buf.flow.quality}\n+\t\t\t\t/* XXX add calculated airspeed */\n+\t\t\t};\n+\n+\t\t\t/* put into buffer for later IO */\n+\t\t\tpthread_mutex_lock(&sysvector_mutex);\n+\t\t\tsdlog_logbuffer_write(&lb, &sysvect);\n+\t\t\t/* signal the other thread new data, but not yet unlock */\n+\t\t\tpthread_cond_signal(&sysvector_cond);\n+\t\t\t/* unlock, now the writer thread may run */\n+\t\t\tpthread_mutex_unlock(&sysvector_mutex);\n+\t\t}\n+\n \t}\n \n \tprint_sdlog_status();\n \n \t/* wait for write thread to return */\n \t(void)pthread_join(sysvector_pthread, NULL);\n \n+  \tpthread_mutex_destroy(&sysvector_mutex);\n+  \tpthread_cond_destroy(&sysvector_cond);\n+\n \twarnx(\"exiting.\\n\");\n \n \tclose(sensorfile);"}]}