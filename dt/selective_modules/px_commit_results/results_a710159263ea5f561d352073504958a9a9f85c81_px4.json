{"sha":"a710159263ea5f561d352073504958a9a9f85c81","node_id":"MDY6Q29tbWl0NTI5ODc5MDphNzEwMTU5MjYzZWE1ZjU2MWQzNTIwNzM1MDQ5NThhOWE5Zjg1Yzgx","commit":{"author":{"name":"Andrew Tridgell","email":"andrew@tridgell.net","date":"2015-05-07T00:50:37Z"},"committer":{"name":"Andrew Tridgell","email":"andrew@tridgell.net","date":"2015-05-07T05:16:32Z"},"message":"mpu6000: sample at 200usec faster rate to avoid aliasing\n\nthis runs the mpu6000 200usec faster than requested then detects and\ndisccards duplicates by comparing accel values. This avoids a nasty\naliasing issue due to clock drift between the stm32 and mpu6000","tree":{"sha":"2e0137e33ac9f0c53bff878dc6e2f65b21fb1c2f","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/2e0137e33ac9f0c53bff878dc6e2f65b21fb1c2f"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/a710159263ea5f561d352073504958a9a9f85c81","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/a710159263ea5f561d352073504958a9a9f85c81","html_url":"https://github.com/PX4/PX4-Autopilot/commit/a710159263ea5f561d352073504958a9a9f85c81","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/a710159263ea5f561d352073504958a9a9f85c81/comments","author":{"login":"tridge","id":831867,"node_id":"MDQ6VXNlcjgzMTg2Nw==","avatar_url":"https://avatars.githubusercontent.com/u/831867?v=4","gravatar_id":"","url":"https://api.github.com/users/tridge","html_url":"https://github.com/tridge","followers_url":"https://api.github.com/users/tridge/followers","following_url":"https://api.github.com/users/tridge/following{/other_user}","gists_url":"https://api.github.com/users/tridge/gists{/gist_id}","starred_url":"https://api.github.com/users/tridge/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tridge/subscriptions","organizations_url":"https://api.github.com/users/tridge/orgs","repos_url":"https://api.github.com/users/tridge/repos","events_url":"https://api.github.com/users/tridge/events{/privacy}","received_events_url":"https://api.github.com/users/tridge/received_events","type":"User","site_admin":false},"committer":{"login":"tridge","id":831867,"node_id":"MDQ6VXNlcjgzMTg2Nw==","avatar_url":"https://avatars.githubusercontent.com/u/831867?v=4","gravatar_id":"","url":"https://api.github.com/users/tridge","html_url":"https://github.com/tridge","followers_url":"https://api.github.com/users/tridge/followers","following_url":"https://api.github.com/users/tridge/following{/other_user}","gists_url":"https://api.github.com/users/tridge/gists{/gist_id}","starred_url":"https://api.github.com/users/tridge/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/tridge/subscriptions","organizations_url":"https://api.github.com/users/tridge/orgs","repos_url":"https://api.github.com/users/tridge/repos","events_url":"https://api.github.com/users/tridge/events{/privacy}","received_events_url":"https://api.github.com/users/tridge/received_events","type":"User","site_admin":false},"parents":[{"sha":"3ac95fb5816dcbdce4a269767c3f6019c434811f","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/3ac95fb5816dcbdce4a269767c3f6019c434811f","html_url":"https://github.com/PX4/PX4-Autopilot/commit/3ac95fb5816dcbdce4a269767c3f6019c434811f"}],"stats":{"total":58,"additions":53,"deletions":5},"files":[{"sha":"9880544ecbf59d8ba64bfca18743b00acbacf136","filename":"src/drivers/mpu6000/mpu6000.cpp","status":"modified","additions":53,"deletions":5,"changes":58,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/a710159263ea5f561d352073504958a9a9f85c81/src%2Fdrivers%2Fmpu6000%2Fmpu6000.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/a710159263ea5f561d352073504958a9a9f85c81/src%2Fdrivers%2Fmpu6000%2Fmpu6000.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Fmpu6000%2Fmpu6000.cpp?ref=a710159263ea5f561d352073504958a9a9f85c81","patch":"@@ -189,6 +189,14 @@\n #define MPU6000_LOW_BUS_SPEED\t\t\t\t1000*1000\n #define MPU6000_HIGH_BUS_SPEED\t\t\t\t11*1000*1000 /* will be rounded to 10.4 MHz, within margins for MPU6K */\n \n+/*\n+  we set the timer interrupt to run a bit faster than the desired\n+  sample rate and then throw away duplicates by comparing\n+  accelerometer values. This time reduction is enough to cope with\n+  worst case timing jitter due to other timers\n+ */\n+#define MPU6000_TIMER_REDUCTION\t\t\t\t200\n+\n class MPU6000_gyro;\n \n class MPU6000 : public device::SPI\n@@ -257,6 +265,7 @@ class MPU6000 : public device::SPI\n \tperf_counter_t\t\t_bad_registers;\n \tperf_counter_t\t\t_good_transfers;\n \tperf_counter_t\t\t_reset_retries;\n+\tperf_counter_t\t\t_duplicates;\n \tperf_counter_t\t\t_system_latency_perf;\n \tperf_counter_t\t\t_controller_latency_perf;\n \n@@ -287,6 +296,10 @@ class MPU6000 : public device::SPI\n \t// last temperature reading for print_info()\n \tfloat\t\t\t_last_temperature;\n \n+\t// keep last accel reading for duplicate detection\n+\tuint16_t\t\t_last_accel[3];\n+\tbool\t\t\t_got_duplicate;\n+\n \t/**\n \t * Start automatic measurement.\n \t */\n@@ -509,6 +522,7 @@ MPU6000::MPU6000(int bus, const char *path_accel, const char *path_gyro, spi_dev\n \t_bad_registers(perf_alloc(PC_COUNT, \"mpu6000_bad_registers\")),\n \t_good_transfers(perf_alloc(PC_COUNT, \"mpu6000_good_transfers\")),\n \t_reset_retries(perf_alloc(PC_COUNT, \"mpu6000_reset_retries\")),\n+\t_duplicates(perf_alloc(PC_COUNT, \"mpu6000_duplicates\")),\n \t_system_latency_perf(perf_alloc_once(PC_ELAPSED, \"sys_latency\")),\n \t_controller_latency_perf(perf_alloc_once(PC_ELAPSED, \"ctrl_latency\")),\n \t_register_wait(0),\n@@ -522,7 +536,9 @@ MPU6000::MPU6000(int bus, const char *path_accel, const char *path_gyro, spi_dev\n \t_rotation(rotation),\n \t_checked_next(0),\n \t_in_factory_test(false),\n-\t_last_temperature(0)\n+\t_last_temperature(0),\n+\t_last_accel{},\n+\t_got_duplicate(false)\n {\n \t// disable debug() calls\n \t_debug_enabled = false;\n@@ -576,6 +592,8 @@ MPU6000::~MPU6000()\n \tperf_free(_bad_transfers);\n \tperf_free(_bad_registers);\n \tperf_free(_good_transfers);\n+\tperf_free(_reset_retries);\n+\tperf_free(_duplicates);\n }\n \n int\n@@ -1198,7 +1216,15 @@ MPU6000::ioctl(struct file *filp, int cmd, unsigned long arg)\n \n \t\t\t\t\t/* update interval for next measurement */\n \t\t\t\t\t/* XXX this is a bit shady, but no other way to adjust... */\n-\t\t\t\t\t_call.period = _call_interval = ticks;\n+\t\t\t\t\t_call_interval = ticks;\n+\n+                                        /*\n+                                          set call interval faster then the sample time. We\n+                                          then detect when we have duplicate samples and reject\n+                                          them. This prevents aliasing due to a beat between the\n+                                          stm32 clock and the mpu6000 clock\n+                                         */\n+                                        _call.period = _call_interval - MPU6000_TIMER_REDUCTION;\n \n \t\t\t\t\t/* if we need to start the poll state machine, do it */\n \t\t\t\t\tif (want_start)\n@@ -1476,7 +1502,10 @@ MPU6000::start()\n \t_gyro_reports->flush();\n \n \t/* start polling at the specified rate */\n-\thrt_call_every(&_call, 1000, _call_interval, (hrt_callout)&MPU6000::measure_trampoline, this);\n+\thrt_call_every(&_call,\n+                       1000,\n+                       _call_interval-MPU6000_TIMER_REDUCTION,\n+                       (hrt_callout)&MPU6000::measure_trampoline, this);\n }\n \n void\n@@ -1578,14 +1607,32 @@ MPU6000::measure()\n \t */\n \tmpu_report.cmd = DIR_READ | MPUREG_INT_STATUS;\n \n-\tcheck_registers();\n-\n         // sensor transfer at high clock speed\n         set_frequency(MPU6000_HIGH_BUS_SPEED);\n \n \tif (OK != transfer((uint8_t *)&mpu_report, ((uint8_t *)&mpu_report), sizeof(mpu_report)))\n \t\treturn;\n \n+        check_registers();\n+\n+\t/*\n+\t   see if this is duplicate accelerometer data. Note that we\n+\t   can't use the data ready interrupt status bit in the status\n+\t   register as that also goes high on new gyro data, and when\n+\t   we run with BITS_DLPF_CFG_256HZ_NOLPF2 the gyro is being\n+\t   sampled at 8kHz, so we would incorrectly think we have new\n+\t   data when we are in fact getting duplicate accelerometer data.\n+\t*/\n+        if (!_got_duplicate && memcmp(&mpu_report.accel_x[0], &_last_accel[0], 6) == 0) {\n+\t\t// it isn't new data - wait for next timer\n+\t\tperf_end(_sample_perf);\n+\t\tperf_count(_duplicates);\n+\t\t_got_duplicate = true;\n+\t\treturn;\n+\t}\n+\tmemcpy(&_last_accel[0], &mpu_report.accel_x[0], 6);\n+\t_got_duplicate = false;\n+\n \t/*\n \t * Convert from big to little endian\n \t */\n@@ -1766,6 +1813,7 @@ MPU6000::print_info()\n \tperf_print_counter(_bad_registers);\n \tperf_print_counter(_good_transfers);\n \tperf_print_counter(_reset_retries);\n+\tperf_print_counter(_duplicates);\n \t_accel_reports->print_info(\"accel queue\");\n \t_gyro_reports->print_info(\"gyro queue\");\n         ::printf(\"checked_next: %u\\n\", _checked_next);"}]}