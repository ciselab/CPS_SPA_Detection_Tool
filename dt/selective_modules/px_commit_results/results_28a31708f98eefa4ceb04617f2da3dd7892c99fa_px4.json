{"sha":"28a31708f98eefa4ceb04617f2da3dd7892c99fa","node_id":"MDY6Q29tbWl0NTI5ODc5MDoyOGEzMTcwOGY5OGVlZmE0Y2ViMDQ2MTdmMmRhM2RkNzg5MmM5OWZh","commit":{"author":{"name":"Lorenz Meier","email":"lm@inf.ethz.ch","date":"2014-06-29T22:46:29Z"},"committer":{"name":"Lorenz Meier","email":"lm@inf.ethz.ch","date":"2014-06-29T22:46:29Z"},"message":"Merged estimator fixes and mavlink rate config bits","tree":{"sha":"b96ffb29110b72d164a7b6dd45ec481612a05e6a","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/b96ffb29110b72d164a7b6dd45ec481612a05e6a"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/28a31708f98eefa4ceb04617f2da3dd7892c99fa","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/28a31708f98eefa4ceb04617f2da3dd7892c99fa","html_url":"https://github.com/PX4/PX4-Autopilot/commit/28a31708f98eefa4ceb04617f2da3dd7892c99fa","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/28a31708f98eefa4ceb04617f2da3dd7892c99fa/comments","author":{"login":"LorenzMeier","id":1208119,"node_id":"MDQ6VXNlcjEyMDgxMTk=","avatar_url":"https://avatars.githubusercontent.com/u/1208119?v=4","gravatar_id":"","url":"https://api.github.com/users/LorenzMeier","html_url":"https://github.com/LorenzMeier","followers_url":"https://api.github.com/users/LorenzMeier/followers","following_url":"https://api.github.com/users/LorenzMeier/following{/other_user}","gists_url":"https://api.github.com/users/LorenzMeier/gists{/gist_id}","starred_url":"https://api.github.com/users/LorenzMeier/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/LorenzMeier/subscriptions","organizations_url":"https://api.github.com/users/LorenzMeier/orgs","repos_url":"https://api.github.com/users/LorenzMeier/repos","events_url":"https://api.github.com/users/LorenzMeier/events{/privacy}","received_events_url":"https://api.github.com/users/LorenzMeier/received_events","type":"User","site_admin":false},"committer":{"login":"LorenzMeier","id":1208119,"node_id":"MDQ6VXNlcjEyMDgxMTk=","avatar_url":"https://avatars.githubusercontent.com/u/1208119?v=4","gravatar_id":"","url":"https://api.github.com/users/LorenzMeier","html_url":"https://github.com/LorenzMeier","followers_url":"https://api.github.com/users/LorenzMeier/followers","following_url":"https://api.github.com/users/LorenzMeier/following{/other_user}","gists_url":"https://api.github.com/users/LorenzMeier/gists{/gist_id}","starred_url":"https://api.github.com/users/LorenzMeier/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/LorenzMeier/subscriptions","organizations_url":"https://api.github.com/users/LorenzMeier/orgs","repos_url":"https://api.github.com/users/LorenzMeier/repos","events_url":"https://api.github.com/users/LorenzMeier/events{/privacy}","received_events_url":"https://api.github.com/users/LorenzMeier/received_events","type":"User","site_admin":false},"parents":[{"sha":"6f75d1a20f6c66a8bfb87032048d1369d01fbb5e","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/6f75d1a20f6c66a8bfb87032048d1369d01fbb5e","html_url":"https://github.com/PX4/PX4-Autopilot/commit/6f75d1a20f6c66a8bfb87032048d1369d01fbb5e"},{"sha":"afb5271bfb2f2645f0d48a802ed15b8f6509cd58","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/afb5271bfb2f2645f0d48a802ed15b8f6509cd58","html_url":"https://github.com/PX4/PX4-Autopilot/commit/afb5271bfb2f2645f0d48a802ed15b8f6509cd58"}],"stats":{"total":4489,"additions":3714,"deletions":775},"files":[{"sha":"f70e0ed77fe6cbb0c25666d59cd0eb9cbff1c28d","filename":"ROMFS/px4fmu_common/init.d/rcS","status":"modified","additions":4,"deletions":5,"changes":9,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/ROMFS%2Fpx4fmu_common%2Finit.d%2FrcS","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/ROMFS%2Fpx4fmu_common%2Finit.d%2FrcS","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/ROMFS%2Fpx4fmu_common%2Finit.d%2FrcS?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -428,11 +428,10 @@ then\n \t#\n \tsh /etc/init.d/rc.sensors\n \n-\tif [ $HIL == no ]\n-\tthen\n-\t\techo \"[init] Start logging\"\n-\t\tsh /etc/init.d/rc.logging\n-\tfi\n+\t#\n+\t# Start logging in all modes, including HIL\n+\t#\n+\tsh /etc/init.d/rc.logging\n \n \tif [ $GPS == yes ]\n \tthen"},{"sha":"0edec3d0eec3d3b735c6d31383cae3f9c91180bf","filename":"src/drivers/mpu6000/mpu6000.cpp","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fdrivers%2Fmpu6000%2Fmpu6000.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fdrivers%2Fmpu6000%2Fmpu6000.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Fmpu6000%2Fmpu6000.cpp?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -544,7 +544,7 @@ void MPU6000::reset()\n \twrite_reg(MPUREG_USER_CTRL, BIT_I2C_IF_DIS);\n         irqrestore(state);\n \n-\tup_udelay(1000);\n+\tusleep(1000);\n \n \t// SAMPLE RATE\n \t_set_sample_rate(_sample_rate);"},{"sha":"bb42889ea0d3814e30e07ffd213ab144348f1bdf","filename":"src/modules/commander/commander.cpp","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fcommander%2Fcommander.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fcommander%2Fcommander.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fcommander%2Fcommander.cpp?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -1591,7 +1591,6 @@ set_main_state_rc(struct vehicle_status_s *status, struct manual_control_setpoin\n \tswitch (sp_man->mode_switch) {\n \tcase SWITCH_POS_NONE:\n \t\tres = TRANSITION_NOT_CHANGED;\n-\t\twarnx(\"NONE\");\n \t\tbreak;\n \n \tcase SWITCH_POS_OFF:\t\t// MANUAL"},{"sha":"e4f805dc04d660d788cfdfebd47cd69652de629a","filename":"src/modules/ekf_att_pos_estimator/ekf_att_pos_estimator_main.cpp","status":"modified","additions":568,"deletions":405,"changes":973,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Fekf_att_pos_estimator_main.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Fekf_att_pos_estimator_main.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fekf_att_pos_estimator%2Fekf_att_pos_estimator_main.cpp?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -49,11 +49,11 @@\n #include <math.h>\n #include <poll.h>\n #include <time.h>\n-#include <drivers/drv_hrt.h>\n+#include <float.h>\n \n #define SENSOR_COMBINED_SUB\n \n-\n+#include <drivers/drv_hrt.h>\n #include <drivers/drv_gyro.h>\n #include <drivers/drv_accel.h>\n #include <drivers/drv_mag.h>\n@@ -83,7 +83,7 @@\n #include <mathlib/mathlib.h>\n #include <mavlink/mavlink_log.h>\n \n-#include \"estimator.h\"\n+#include \"estimator_23states.h\"\n \n \n \n@@ -96,7 +96,6 @@ extern \"C\" __EXPORT int ekf_att_pos_estimator_main(int argc, char *argv[]);\n \n __EXPORT uint32_t millis();\n \n-static uint64_t last_run = 0;\n static uint64_t IMUmsec = 0;\n static const uint64_t FILTER_INIT_DELAY = 1 * 1000 * 1000;\n \n@@ -121,7 +120,7 @@ class FixedwingEstimator\n \t/**\n \t * Start the sensors task.\n \t *\n-\t * @return\t\tOK on success.\n+\t * @return\tOK on success.\n \t */\n \tint\t\tstart();\n \n@@ -135,6 +134,20 @@ class FixedwingEstimator\n \t */\n \tint\t\ttrip_nan();\n \n+\t/**\n+\t * Enable logging.\n+\t *\n+\t * @param\tenable Set to true to enable logging, false to disable\n+\t */\n+\tint\t\tenable_logging(bool enable);\n+\n+\t/**\n+\t * Set debug level.\n+\t *\n+\t * @param\tdebug Desired debug level - 0 to disable.\n+\t */\n+\tint\t\tset_debuglevel(unsigned debug) { _debug = debug; return 0; }\n+\n private:\n \n \tbool\t\t_task_should_exit;\t\t/**< if true, sensor task should exit */\n@@ -184,24 +197,28 @@ class FixedwingEstimator\n \tstruct map_projection_reference_s\t_pos_ref;\n \n \tfloat\t\t\t\t\t\t_baro_ref;\t\t/**< barometer reference altitude */\n-\tfloat\t\t\t\t\t\t_baro_gps_offset;\t/**< offset between GPS and baro */\n+\tfloat\t\t\t\t\t\t_baro_ref_offset;\t/**< offset between initial baro reference and GPS init baro altitude */\n+\tfloat\t\t\t\t\t\t_baro_gps_offset;\t/**< offset between baro altitude (at GPS init time) and GPS altitude */\n \n-\tperf_counter_t\t_loop_perf;\t\t\t/**< loop performance counter */\n+\tperf_counter_t\t_loop_perf;\t\t\t///< loop performance counter\n \tperf_counter_t\t_perf_gyro;\t\t\t///<local performance counter for gyro updates\n-\tperf_counter_t\t_perf_accel;\t\t\t///<local performance counter for accel updates\n \tperf_counter_t\t_perf_mag;\t\t\t///<local performance counter for mag updates\n \tperf_counter_t\t_perf_gps;\t\t\t///<local performance counter for gps updates\n \tperf_counter_t\t_perf_baro;\t\t\t///<local performance counter for baro updates\n \tperf_counter_t\t_perf_airspeed;\t\t\t///<local performance counter for airspeed updates\n+\tperf_counter_t\t_perf_reset;\t\t\t///<local performance counter for filter resets\n \n-\tbool\t\t\t\t\t\t_initialized;\n \tbool\t\t\t\t\t\t_baro_init;\n \tbool\t\t\t\t\t\t_gps_initialized;\n-\tuint64_t\t\t\t\t\t_gps_start_time;\n-\tuint64_t\t\t\t\t\t_filter_start_time;\n+\thrt_abstime\t\t\t\t\t_gps_start_time;\n+\thrt_abstime\t\t\t\t\t_filter_start_time;\n+\thrt_abstime\t\t\t\t\t_last_sensor_timestamp;\n+\thrt_abstime\t\t\t\t\t_last_run;\n \tbool\t\t\t\t\t\t_gyro_valid;\n \tbool\t\t\t\t\t\t_accel_valid;\n \tbool\t\t\t\t\t\t_mag_valid;\n+\tbool\t\t\t\t\t\t_ekf_logging;\t\t///< log EKF state\n+\tunsigned\t\t\t\t\t_debug;\t\t\t///< debug level - default 0\n \n \tint\t\t\t\t\t\t_mavlink_fd;\n \n@@ -275,9 +292,16 @@ class FixedwingEstimator\n \tstatic void\ttask_main_trampoline(int argc, char *argv[]);\n \n \t/**\n-\t * Main sensor collection task.\n+\t * Main filter task.\n \t */\n \tvoid\t\ttask_main();\n+\n+\t/**\n+\t * Check filter sanity state\n+\t *\n+\t * @return zero if ok, non-zero for a filter error condition.\n+\t */\n+\tint\t\tcheck_filter_state();\n };\n \n namespace estimator\n@@ -342,32 +366,34 @@ FixedwingEstimator::FixedwingEstimator() :\n \t#endif\n \n \t_baro_ref(0.0f),\n+\t_baro_ref_offset(0.0f),\n \t_baro_gps_offset(0.0f),\n \n /* performance counters */\n-\t_loop_perf(perf_alloc(PC_COUNT, \"ekf_att_pos_estimator\")),\n-\t_perf_gyro(perf_alloc(PC_COUNT, \"ekf_att_pos_gyro_upd\")),\n-\t_perf_accel(perf_alloc(PC_COUNT, \"ekf_att_pos_accel_upd\")),\n-\t_perf_mag(perf_alloc(PC_COUNT, \"ekf_att_pos_mag_upd\")),\n-\t_perf_gps(perf_alloc(PC_COUNT, \"ekf_att_pos_gps_upd\")),\n-\t_perf_baro(perf_alloc(PC_COUNT, \"ekf_att_pos_baro_upd\")),\n-\t_perf_airspeed(perf_alloc(PC_COUNT, \"ekf_att_pos_aspd_upd\")),\n+\t_loop_perf(perf_alloc(PC_ELAPSED, \"ekf_att_pos_estimator\")),\n+\t_perf_gyro(perf_alloc(PC_INTERVAL, \"ekf_att_pos_gyro_upd\")),\n+\t_perf_mag(perf_alloc(PC_INTERVAL, \"ekf_att_pos_mag_upd\")),\n+\t_perf_gps(perf_alloc(PC_INTERVAL, \"ekf_att_pos_gps_upd\")),\n+\t_perf_baro(perf_alloc(PC_INTERVAL, \"ekf_att_pos_baro_upd\")),\n+\t_perf_airspeed(perf_alloc(PC_INTERVAL, \"ekf_att_pos_aspd_upd\")),\n+\t_perf_reset(perf_alloc(PC_COUNT, \"ekf_att_pos_reset\")),\n \n /* states */\n-\t_initialized(false),\n \t_baro_init(false),\n \t_gps_initialized(false),\n \t_gyro_valid(false),\n \t_accel_valid(false),\n \t_mag_valid(false),\n+\t_ekf_logging(true),\n+\t_debug(0),\n \t_mavlink_fd(-1),\n \t_ekf(nullptr),\n \t_velocity_xy_filtered(0.0f),\n \t_velocity_z_filtered(0.0f),\n \t_airspeed_filtered(0.0f)\n {\n \n-\tlast_run = hrt_absolute_time();\n+\t_last_run = hrt_absolute_time();\n \n \t_parameter_handles.vel_delay_ms = param_find(\"PE_VEL_DELAY_MS\");\n \t_parameter_handles.pos_delay_ms = param_find(\"PE_POS_DELAY_MS\");\n@@ -451,9 +477,19 @@ FixedwingEstimator::~FixedwingEstimator()\n \t\t} while (_estimator_task != -1);\n \t}\n \n+\tdelete _ekf;\n+\n \testimator::g_estimator = nullptr;\n }\n \n+int\n+FixedwingEstimator::enable_logging(bool logging)\n+{\n+\t_ekf_logging = logging;\n+\n+\treturn 0;\n+}\n+\n int\n FixedwingEstimator::parameters_update()\n {\n@@ -512,6 +548,151 @@ FixedwingEstimator::vehicle_status_poll()\n \t}\n }\n \n+int\n+FixedwingEstimator::check_filter_state()\n+{\n+\t/*\n+\t *    CHECK IF THE INPUT DATA IS SANE\n+\t */\n+\n+\tstruct ekf_status_report ekf_report;\n+\n+\tint check = _ekf->CheckAndBound(&ekf_report);\n+\n+\tconst char* ekfname = \"att pos estimator: \";\n+\n+\tswitch (check) {\n+\t\tcase 0:\n+\t\t\t/* all ok */\n+\t\t\tbreak;\n+\t\tcase 1:\n+\t\t{\n+\t\t\tconst char* str = \"NaN in states, resetting\";\n+\t\t\twarnx(\"%s\", str);\n+\t\t\tmavlink_log_critical(_mavlink_fd, \"%s%s\", ekfname, str);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase 2:\n+\t\t{\n+\t\t\tconst char* str = \"stale IMU data, resetting\";\n+\t\t\twarnx(\"%s\", str);\n+\t\t\tmavlink_log_critical(_mavlink_fd, \"%s%s\", ekfname, str);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase 3:\n+\t\t{\n+\t\t\tconst char* str = \"switching to dynamic state\";\n+\t\t\twarnx(\"%s\", str);\n+\t\t\tmavlink_log_info(_mavlink_fd, \"%s%s\", ekfname, str);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase 4:\n+\t\t{\n+\t\t\tconst char* str = \"excessive gyro offsets\";\n+\t\t\twarnx(\"%s\", str);\n+\t\t\tmavlink_log_info(_mavlink_fd, \"%s%s\", ekfname, str);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase 5:\n+\t\t{\n+\t\t\tconst char* str = \"GPS velocity divergence\";\n+\t\t\twarnx(\"%s\", str);\n+\t\t\tmavlink_log_info(_mavlink_fd, \"%s%s\", ekfname, str);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase 6:\n+\t\t{\n+\t\t\tconst char* str = \"excessive covariances\";\n+\t\t\twarnx(\"%s\", str);\n+\t\t\tmavlink_log_info(_mavlink_fd, \"%s%s\", ekfname, str);\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tdefault:\n+\t\t{\n+\t\t\tconst char* str = \"unknown reset condition\";\n+\t\t\twarnx(\"%s\", str);\n+\t\t\tmavlink_log_critical(_mavlink_fd, \"%s%s\", ekfname, str);\n+\t\t}\n+\t}\n+\n+\tstruct estimator_status_report rep;\n+\tmemset(&rep, 0, sizeof(rep));\n+\n+\t// If error flag is set, we got a filter reset\n+\tif (check && ekf_report.error) {\n+\n+\t\t// Count the reset condition\n+\t\tperf_count(_perf_reset);\n+\n+\t} else if (_ekf_logging) {\n+\t\t_ekf->GetFilterState(&ekf_report);\n+\t}\n+\n+\tif (_ekf_logging || check) {\n+\t\trep.timestamp = hrt_absolute_time();\n+\n+\t\trep.nan_flags |= (((uint8_t)ekf_report.angNaN)\t\t<< 0);\n+\t\trep.nan_flags |= (((uint8_t)ekf_report.summedDelVelNaN)\t<< 1);\n+\t\trep.nan_flags |= (((uint8_t)ekf_report.KHNaN)\t\t<< 2);\n+\t\trep.nan_flags |= (((uint8_t)ekf_report.KHPNaN)\t\t<< 3);\n+\t\trep.nan_flags |= (((uint8_t)ekf_report.PNaN)\t\t<< 4);\n+\t\trep.nan_flags |= (((uint8_t)ekf_report.covarianceNaN)\t<< 5);\n+\t\trep.nan_flags |= (((uint8_t)ekf_report.kalmanGainsNaN)\t<< 6);\n+\t\trep.nan_flags |= (((uint8_t)ekf_report.statesNaN)\t<< 7);\n+\n+\t\trep.health_flags |= (((uint8_t)ekf_report.velHealth)\t<< 0);\n+\t\trep.health_flags |= (((uint8_t)ekf_report.posHealth)\t<< 1);\n+\t\trep.health_flags |= (((uint8_t)ekf_report.hgtHealth)\t<< 2);\n+\t\trep.health_flags |= (((uint8_t)!ekf_report.gyroOffsetsExcessive)\t<< 3);\n+\n+\t\trep.timeout_flags |= (((uint8_t)ekf_report.velTimeout)\t<< 0);\n+\t\trep.timeout_flags |= (((uint8_t)ekf_report.posTimeout)\t<< 1);\n+\t\trep.timeout_flags |= (((uint8_t)ekf_report.hgtTimeout)\t<< 2);\n+\t\trep.timeout_flags |= (((uint8_t)ekf_report.imuTimeout)\t<< 3);\n+\n+\t\tif (_debug > 10) {\n+\n+\t\t\tif (rep.health_flags < ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3))) {\n+\t\t\t\twarnx(\"health: VEL:%s POS:%s HGT:%s OFFS:%s\",\n+\t\t\t\t\t((rep.health_flags & (1 << 0)) ? \"OK\" : \"ERR\"),\n+\t\t\t\t\t((rep.health_flags & (1 << 1)) ? \"OK\" : \"ERR\"),\n+\t\t\t\t\t((rep.health_flags & (1 << 2)) ? \"OK\" : \"ERR\"),\n+\t\t\t\t\t((rep.health_flags & (1 << 3)) ? \"OK\" : \"ERR\"));\n+\t\t\t}\n+\n+\t\t\tif (rep.timeout_flags) {\n+\t\t\t\twarnx(\"timeout: %s%s%s%s\",\n+\t\t\t\t\t((rep.timeout_flags & (1 << 0)) ? \"VEL \" : \"\"),\n+\t\t\t\t\t((rep.timeout_flags & (1 << 1)) ? \"POS \" : \"\"),\n+\t\t\t\t\t((rep.timeout_flags & (1 << 2)) ? \"HGT \" : \"\"),\n+\t\t\t\t\t((rep.timeout_flags & (1 << 3)) ? \"IMU \" : \"\"));\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Copy all states or at least all that we can fit\n+\t\tunsigned ekf_n_states = ekf_report.n_states;\n+\t\tunsigned max_states = (sizeof(rep.states) / sizeof(rep.states[0]));\n+\t\trep.n_states = (ekf_n_states < max_states) ? ekf_n_states : max_states;\n+\n+\t\tfor (unsigned i = 0; i < rep.n_states; i++) {\n+\t\t\trep.states[i] = ekf_report.states[i];\n+\t\t}\n+\n+\t\tfor (unsigned i = 0; i < rep.n_states; i++) {\n+\t\t\trep.states[i] = ekf_report.states[i];\n+\t\t}\n+\n+\t\tif (_estimator_status_pub > 0) {\n+\t\t\torb_publish(ORB_ID(estimator_status), _estimator_status_pub, &rep);\n+\t\t} else {\n+\t\t\t_estimator_status_pub = orb_advertise(ORB_ID(estimator_status), &rep);\n+\t\t}\n+\t}\n+\n+\treturn check;\n+}\n+\n void\n FixedwingEstimator::task_main_trampoline(int argc, char *argv[])\n {\n@@ -528,7 +709,7 @@ FixedwingEstimator::task_main()\n \t_filter_start_time = hrt_absolute_time();\n \n \tif (!_ekf) {\n-\t\terrx(1, \"failed allocating EKF filter - out of RAM!\");\n+\t\terrx(1, \"OUT OF MEM!\");\n \t}\n \n \t/*\n@@ -556,7 +737,7 @@ FixedwingEstimator::task_main()\n #else\n \t_sensor_combined_sub = orb_subscribe(ORB_ID(sensor_combined));\n \t/* XXX remove this!, BUT increase the data buffer size! */\n-\torb_set_interval(_sensor_combined_sub, 4);\n+\torb_set_interval(_sensor_combined_sub, 9);\n #endif\n \n \t/* sets also parameters in the EKF object */\n@@ -584,6 +765,13 @@ FixedwingEstimator::task_main()\n \tbool newAdsData = false;\n \tbool newDataMag = false;\n \n+\tfloat posNED[3] = {0.0f, 0.0f, 0.0f}; // North, East Down position (m)\n+\n+\tuint64_t last_gps = 0;\n+\t_gps.vel_n_m_s = 0.0f;\n+\t_gps.vel_e_m_s = 0.0f;\n+\t_gps.vel_d_m_s = 0.0f;\n+\n \twhile (!_task_should_exit) {\n \n \t\t/* wait for up to 500ms for data */\n@@ -595,7 +783,7 @@ FixedwingEstimator::task_main()\n \n \t\t/* this is undesirable but not much we can do - might want to flag unhappy status */\n \t\tif (pret < 0) {\n-\t\t\twarn(\"poll error %d, %d\", pret, errno);\n+\t\t\twarn(\"POLL ERR %d, %d\", pret, errno);\n \t\t\tcontinue;\n \t\t}\n \n@@ -621,8 +809,6 @@ FixedwingEstimator::task_main()\n \t\t\tbool accel_updated;\n \t\t\tbool mag_updated;\n \n-\t\t\thrt_abstime last_sensor_timestamp;\n-\n \t\t\tperf_count(_perf_gyro);\n \n \t\t\t/* Reset baro reference if switching to HIL, reset sensor states */\n@@ -646,12 +832,12 @@ FixedwingEstimator::task_main()\n \n \t\t\t\t_baro_init = false;\n \t\t\t\t_gps_initialized = false;\n-\t\t\t\tlast_sensor_timestamp = hrt_absolute_time();\n-\t\t\t\tlast_run = last_sensor_timestamp;\n+\t\t\t\t_last_sensor_timestamp = hrt_absolute_time();\n+\t\t\t\t_last_run = _last_sensor_timestamp;\n \n \t\t\t\t_ekf->ZeroVariables();\n \t\t\t\t_ekf->dtIMU = 0.01f;\n-\t\t\t\t_filter_start_time = last_sensor_timestamp;\n+\t\t\t\t_filter_start_time = _last_sensor_timestamp;\n \n \t\t\t\t/* now skip this loop and get data on the next one, which will also re-init the filter */\n \t\t\t\tcontinue;\n@@ -669,15 +855,14 @@ FixedwingEstimator::task_main()\n \t\t\torb_check(_accel_sub, &accel_updated);\n \n \t\t\tif (accel_updated) {\n-\t\t\t\tperf_count(_perf_accel);\n \t\t\t\torb_copy(ORB_ID(sensor_accel), _accel_sub, &_accel);\n \t\t\t}\n \n-\t\t\tlast_sensor_timestamp = _gyro.timestamp;\n+\t\t\t_last_sensor_timestamp = _gyro.timestamp;\n \t\t\tIMUmsec = _gyro.timestamp / 1e3f;\n \n-\t\t\tfloat deltaT = (_gyro.timestamp - last_run) / 1e6f;\n-\t\t\tlast_run = _gyro.timestamp;\n+\t\t\tfloat deltaT = (_gyro.timestamp - _last_run) / 1e6f;\n+\t\t\t_last_run = _gyro.timestamp;\n \n \t\t\t/* guard against too large deltaT's */\n \t\t\tif (!isfinite(deltaT) || deltaT > 1.0f || deltaT < 0.000001f) {\n@@ -737,17 +922,17 @@ FixedwingEstimator::task_main()\n \n \n \t\t\t// Copy gyro and accel\n-\t\t\tlast_sensor_timestamp = _sensor_combined.timestamp;\n+\t\t\t_last_sensor_timestamp = _sensor_combined.timestamp;\n \t\t\tIMUmsec = _sensor_combined.timestamp / 1e3f;\n \n-\t\t\tfloat deltaT = (_sensor_combined.timestamp - last_run) / 1e6f;\n+\t\t\tfloat deltaT = (_sensor_combined.timestamp - _last_run) / 1e6f;\n \n \t\t\t/* guard against too large deltaT's */\n \t\t\tif (!isfinite(deltaT) || deltaT > 1.0f || deltaT < 0.000001f) {\n \t\t\t\tdeltaT = 0.01f;\n \t\t\t}\n \n-\t\t\tlast_run = _sensor_combined.timestamp;\n+\t\t\t_last_run = _sensor_combined.timestamp;\n \n \t\t\t// Always store data, independent of init status\n \t\t\t/* fill in last data set */\n@@ -765,6 +950,7 @@ FixedwingEstimator::task_main()\n \t\t\t\t}\n \n \t\t\t\t_gyro_valid = true;\n+\t\t\t\tperf_count(_perf_gyro);\n \t\t\t}\n \n \t\t\tif (accel_updated) {\n@@ -796,6 +982,8 @@ FixedwingEstimator::task_main()\n \n #endif\n \n+\t\t\t//warnx(\"dang: %8.4f %8.4f dvel: %8.4f %8.4f\", _ekf->dAngIMU.x, _ekf->dAngIMU.z, _ekf->dVelIMU.x, _ekf->dVelIMU.z);\n+\n \t\t\tbool airspeed_updated;\n \t\t\torb_check(_airspeed_sub, &airspeed_updated);\n \n@@ -815,7 +1003,7 @@ FixedwingEstimator::task_main()\n \n \t\t\tif (gps_updated) {\n \n-\t\t\t\tuint64_t last_gps = _gps.timestamp_position;\n+\t\t\t\tlast_gps = _gps.timestamp_position;\n \n \t\t\t\torb_copy(ORB_ID(vehicle_gps_position), _gps_sub, &_gps);\n \t\t\t\tperf_count(_perf_gps);\n@@ -883,6 +1071,8 @@ FixedwingEstimator::task_main()\n \t\t\t\t\twarnx(\"ALT REF INIT\");\n \t\t\t\t}\n \n+\t\t\t\tperf_count(_perf_baro);\n+\n \t\t\t\tnewHgtData = true;\n \t\t\t} else {\n \t\t\t\tnewHgtData = false;\n@@ -933,127 +1123,39 @@ FixedwingEstimator::task_main()\n \t\t\t\tnewDataMag = false;\n \t\t\t}\n \n-\n-\t\t\t/**\n-\t\t\t *    CHECK IF THE INPUT DATA IS SANE\n+\t\t\t/*\n+\t\t\t *    CHECK IF ITS THE RIGHT TIME TO RUN THINGS ALREADY\n \t\t\t */\n-\t\t\tint check = _ekf->CheckAndBound();\n-\n-\t\t\tconst char* ekfname = \"[ekf] \";\n-\n-\t\t\tswitch (check) {\n-\t\t\t\tcase 0:\n-\t\t\t\t\t/* all ok */\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase 1:\n-\t\t\t\t{\n-\t\t\t\t\tconst char* str = \"NaN in states, resetting\";\n-\t\t\t\t\twarnx(\"%s\", str);\n-\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"%s%s\", ekfname, str);\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tcase 2:\n-\t\t\t\t{\n-\t\t\t\t\tconst char* str = \"stale IMU data, resetting\";\n-\t\t\t\t\twarnx(\"%s\", str);\n-\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"%s%s\", ekfname, str);\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t\tcase 3:\n-\t\t\t\t{\n-\t\t\t\t\tconst char* str = \"switching to dynamic state\";\n-\t\t\t\t\twarnx(\"%s\", str);\n-\t\t\t\t\tmavlink_log_info(_mavlink_fd, \"%s%s\", ekfname, str);\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\n-\t\t\t\tdefault:\n-\t\t\t\t{\n-\t\t\t\t\tconst char* str = \"unknown reset condition\";\n-\t\t\t\t\twarnx(\"%s\", str);\n-\t\t\t\t\tmavlink_log_critical(_mavlink_fd, \"%s%s\", ekfname, str);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// warn on fatal resets\n-\t\t\tif (check == 1) {\n-\t\t\t\twarnx(\"NUMERIC ERROR IN FILTER\");\n-\t\t\t}\n-\n-\t\t\t// If non-zero, we got a filter reset\n-\t\t\tif (check) {\n-\n-\t\t\t\tstruct ekf_status_report ekf_report;\n-\n-\t\t\t\t_ekf->GetLastErrorState(&ekf_report);\n-\n-\t\t\t\tstruct estimator_status_report rep;\n-\t\t\t\tmemset(&rep, 0, sizeof(rep));\n-\t\t\t\trep.timestamp = hrt_absolute_time();\n-\n-\t\t\t\trep.states_nan = ekf_report.statesNaN;\n-\t\t\t\trep.covariance_nan = ekf_report.covarianceNaN;\n-\t\t\t\trep.kalman_gain_nan = ekf_report.kalmanGainsNaN;\n-\n-\t\t\t\t// Copy all states or at least all that we can fit\n-\t\t\t\tunsigned i = 0;\n-\t\t\t\tunsigned ekf_n_states = (sizeof(ekf_report.states) / sizeof(ekf_report.states[0]));\n-\t\t\t\tunsigned max_states = (sizeof(rep.states) / sizeof(rep.states[0]));\n-\t\t\t\trep.n_states = (ekf_n_states < max_states) ? ekf_n_states : max_states;\n-\n-\t\t\t\twhile ((i < ekf_n_states) && (i < max_states)) {\n-\n-\t\t\t\t\trep.states[i] = ekf_report.states[i];\n-\t\t\t\t\ti++;\n-\t\t\t\t}\n-\n-\t\t\t\tif (_estimator_status_pub > 0) {\n-\t\t\t\t\torb_publish(ORB_ID(estimator_status), _estimator_status_pub, &rep);\n-\t\t\t\t} else {\n-\t\t\t\t\t_estimator_status_pub = orb_advertise(ORB_ID(estimator_status), &rep);\n-\t\t\t\t}\n-\n-\t\t\t\t/* set sensors to de-initialized state */\n-\t\t\t\t_gyro_valid = false;\n-\t\t\t\t_accel_valid = false;\n-\t\t\t\t_mag_valid = false;\n-\n-\t\t\t\t_baro_init = false;\n-\t\t\t\t_gps_initialized = false;\n-\t\t\t\tlast_sensor_timestamp = hrt_absolute_time();\n-\t\t\t\tlast_run = last_sensor_timestamp;\n-\n-\t\t\t\t_ekf->ZeroVariables();\n-\t\t\t\t_ekf->dtIMU = 0.01f;\n-\n-\t\t\t\t// Let the system re-initialize itself\n+\t\t\tif (hrt_elapsed_time(&_filter_start_time) < FILTER_INIT_DELAY) {\n \t\t\t\tcontinue;\n-\n \t\t\t}\n \n-\n \t\t\t/**\n \t\t\t *    PART TWO: EXECUTE THE FILTER\n+\t\t\t *\n+\t\t\t *    We run the filter only once all data has been fetched\n \t\t\t **/\n \n-\t\t\tif ((hrt_elapsed_time(&_filter_start_time) > FILTER_INIT_DELAY) && _baro_init && _gyro_valid && _accel_valid && _mag_valid) {\n+\t\t\tif (_baro_init && _gyro_valid && _accel_valid && _mag_valid) {\n \n \t\t\t\tfloat initVelNED[3];\n \n+\t\t\t\t/* Initialize the filter first */\n \t\t\t\tif (!_gps_initialized && _gps.fix_type > 2 && _gps.eph < _parameters.pos_stddev_threshold && _gps.epv < _parameters.pos_stddev_threshold) {\n \n-\t\t\t\t\tinitVelNED[0] = _gps.vel_n_m_s;\n-\t\t\t\t\tinitVelNED[1] = _gps.vel_e_m_s;\n-\t\t\t\t\tinitVelNED[2] = _gps.vel_d_m_s;\n-\n \t\t\t\t\t// GPS is in scaled integers, convert\n \t\t\t\t\tdouble lat = _gps.lat / 1.0e7;\n \t\t\t\t\tdouble lon = _gps.lon / 1.0e7;\n \t\t\t\t\tfloat gps_alt = _gps.alt / 1e3f;\n \n+\t\t\t\t\tinitVelNED[0] = _gps.vel_n_m_s;\n+\t\t\t\t\tinitVelNED[1] = _gps.vel_e_m_s;\n+\t\t\t\t\tinitVelNED[2] = _gps.vel_d_m_s;\n+\n \t\t\t\t\t// Set up height correctly\n \t\t\t\t\torb_copy(ORB_ID(sensor_baro), _baro_sub, &_baro);\n-\t\t\t\t\t_baro_gps_offset = _baro_ref - _baro.altitude;\n+\t\t\t\t\t_baro_ref_offset = _ekf->states[9]; // this should become zero in the local frame\n+\t\t\t\t\t_baro_gps_offset = _baro.altitude - gps_alt;\n \t\t\t\t\t_ekf->baroHgt = _baro.altitude;\n \t\t\t\t\t_ekf->hgtMea = 1.0f * (_ekf->baroHgt - (_baro_ref));\n \n@@ -1077,10 +1179,13 @@ FixedwingEstimator::task_main()\n \n \t\t\t\t\tmap_projection_init(&_pos_ref, lat, lon);\n \t\t\t\t\tmavlink_log_info(_mavlink_fd, \"[ekf] ref: LA %.4f,LO %.4f,ALT %.2f\", lat, lon, (double)gps_alt);\n+\n+\t\t\t\t\t#if 0\n \t\t\t\t\twarnx(\"HOME/REF: LA %8.4f,LO %8.4f,ALT %8.2f V: %8.4f %8.4f %8.4f\", lat, lon, (double)gps_alt,\n \t\t\t\t\t\t(double)_ekf->velNED[0], (double)_ekf->velNED[1], (double)_ekf->velNED[2]);\n-\t\t\t\t\twarnx(\"BARO: %8.4f m / ref: %8.4f m / gps offs: %8.4f m\", (double)_ekf->baroHgt, (double)_baro_ref, (double)_baro_gps_offset);\n+\t\t\t\t\twarnx(\"BARO: %8.4f m / ref: %8.4f m / gps offs: %8.4f m\", (double)_ekf->baroHgt, (double)_baro_ref, (double)_baro_ref_offset);\n \t\t\t\t\twarnx(\"GPS: eph: %8.4f, epv: %8.4f, declination: %8.4f\", (double)_gps.eph, (double)_gps.epv, (double)math::degrees(declination));\n+\t\t\t\t\t#endif\n \n \t\t\t\t\t_gps_initialized = true;\n \n@@ -1089,279 +1194,304 @@ FixedwingEstimator::task_main()\n \t\t\t\t\tinitVelNED[0] = 0.0f;\n \t\t\t\t\tinitVelNED[1] = 0.0f;\n \t\t\t\t\tinitVelNED[2] = 0.0f;\n-\t\t\t\t\t_ekf->posNED[0] = 0.0f;\n-\t\t\t\t\t_ekf->posNED[1] = 0.0f;\n-\t\t\t\t\t_ekf->posNED[2] = 0.0f;\n-\n-\t\t\t\t\t_ekf->posNE[0] = _ekf->posNED[0];\n-\t\t\t\t\t_ekf->posNE[1] = _ekf->posNED[1];\n+\t\t\t\t\t_ekf->posNE[0] = posNED[0];\n+\t\t\t\t\t_ekf->posNE[1] = posNED[1];\n \n \t\t\t\t\t_local_pos.ref_alt = _baro_ref;\n+\t\t\t\t\t_baro_ref_offset = 0.0f;\n \t\t\t\t\t_baro_gps_offset = 0.0f;\n \n \t\t\t\t\t_ekf->InitialiseFilter(initVelNED, 0.0, 0.0, 0.0f, 0.0f);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// If valid IMU data and states initialised, predict states and covariances\n-\t\t\tif (_ekf->statesInitialised) {\n-\t\t\t\t// Run the strapdown INS equations every IMU update\n-\t\t\t\t_ekf->UpdateStrapdownEquationsNED();\n-#if 0\n-\t\t\t\t// debug code - could be tunred into a filter mnitoring/watchdog function\n-\t\t\t\tfloat tempQuat[4];\n-\n-\t\t\t\tfor (uint8_t j = 0; j <= 3; j++) tempQuat[j] = states[j];\n+\t\t\t\t} else if (_ekf->statesInitialised) {\n \n-\t\t\t\tquat2eul(eulerEst, tempQuat);\n+\t\t\t\t\t// We're apparently initialized in this case now\n \n-\t\t\t\tfor (uint8_t j = 0; j <= 2; j++) eulerDif[j] = eulerEst[j] - ahrsEul[j];\n+\t\t\t\t\tint check = check_filter_state();\n \n-\t\t\t\tif (eulerDif[2] > pi) eulerDif[2] -= 2 * pi;\n-\n-\t\t\t\tif (eulerDif[2] < -pi) eulerDif[2] += 2 * pi;\n-\n-#endif\n-\t\t\t\t// store the predicted states for subsequent use by measurement fusion\n-\t\t\t\t_ekf->StoreStates(IMUmsec);\n-\t\t\t\t// Check if on ground - status is used by covariance prediction\n-\t\t\t\t_ekf->OnGroundCheck();\n-\t\t\t\t// sum delta angles and time used by covariance prediction\n-\t\t\t\t_ekf->summedDelAng = _ekf->summedDelAng + _ekf->correctedDelAng;\n-\t\t\t\t_ekf->summedDelVel = _ekf->summedDelVel + _ekf->dVelIMU;\n-\t\t\t\tdt += _ekf->dtIMU;\n-\n-\t\t\t\t// perform a covariance prediction if the total delta angle has exceeded the limit\n-\t\t\t\t// or the time limit will be exceeded at the next IMU update\n-\t\t\t\tif ((dt >= (_ekf->covTimeStepMax - _ekf->dtIMU)) || (_ekf->summedDelAng.length() > _ekf->covDelAngMax)) {\n-\t\t\t\t\t_ekf->CovariancePrediction(dt);\n-\t\t\t\t\t_ekf->summedDelAng.zero();\n-\t\t\t\t\t_ekf->summedDelVel.zero();\n-\t\t\t\t\tdt = 0.0f;\n-\t\t\t\t}\n-\n-\t\t\t\t_initialized = true;\n-\t\t\t}\n-\n-\t\t\t// Fuse GPS Measurements\n-\t\t\tif (newDataGps && _gps_initialized) {\n-\t\t\t\t// Convert GPS measurements to Pos NE, hgt and Vel NED\n-\t\t\t\t_ekf->velNED[0] = _gps.vel_n_m_s;\n-\t\t\t\t_ekf->velNED[1] = _gps.vel_e_m_s;\n-\t\t\t\t_ekf->velNED[2] = _gps.vel_d_m_s;\n-\t\t\t\t_ekf->calcposNED(_ekf->posNED, _ekf->gpsLat, _ekf->gpsLon, _ekf->gpsHgt, _ekf->latRef, _ekf->lonRef, _ekf->hgtRef);\n-\n-\t\t\t\t_ekf->posNE[0] = _ekf->posNED[0];\n-\t\t\t\t_ekf->posNE[1] = _ekf->posNED[1];\n-\t\t\t\t// set fusion flags\n-\t\t\t\t_ekf->fuseVelData = true;\n-\t\t\t\t_ekf->fusePosData = true;\n-\t\t\t\t// recall states stored at time of measurement after adjusting for delays\n-\t\t\t\t_ekf->RecallStates(_ekf->statesAtVelTime, (IMUmsec - _parameters.vel_delay_ms));\n-\t\t\t\t_ekf->RecallStates(_ekf->statesAtPosTime, (IMUmsec - _parameters.pos_delay_ms));\n-\t\t\t\t// run the fusion step\n-\t\t\t\t_ekf->FuseVelposNED();\n-\n-\t\t\t} else if (_ekf->statesInitialised) {\n-\t\t\t\t// Convert GPS measurements to Pos NE, hgt and Vel NED\n-\t\t\t\t_ekf->velNED[0] = 0.0f;\n-\t\t\t\t_ekf->velNED[1] = 0.0f;\n-\t\t\t\t_ekf->velNED[2] = 0.0f;\n-\t\t\t\t_ekf->posNED[0] = 0.0f;\n-\t\t\t\t_ekf->posNED[1] = 0.0f;\n-\t\t\t\t_ekf->posNED[2] = 0.0f;\n-\n-\t\t\t\t_ekf->posNE[0] = _ekf->posNED[0];\n-\t\t\t\t_ekf->posNE[1] = _ekf->posNED[1];\n-\t\t\t\t// set fusion flags\n-\t\t\t\t_ekf->fuseVelData = true;\n-\t\t\t\t_ekf->fusePosData = true;\n-\t\t\t\t// recall states stored at time of measurement after adjusting for delays\n-\t\t\t\t_ekf->RecallStates(_ekf->statesAtVelTime, (IMUmsec - _parameters.vel_delay_ms));\n-\t\t\t\t_ekf->RecallStates(_ekf->statesAtPosTime, (IMUmsec - _parameters.pos_delay_ms));\n-\t\t\t\t// run the fusion step\n-\t\t\t\t_ekf->FuseVelposNED();\n+\t\t\t\t\tif (check) {\n+\t\t\t\t\t\t// Let the system re-initialize itself\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n \n-\t\t\t} else {\n-\t\t\t\t_ekf->fuseVelData = false;\n-\t\t\t\t_ekf->fusePosData = false;\n-\t\t\t}\n \n-\t\t\tif (newHgtData && _ekf->statesInitialised) {\n-\t\t\t\t// Could use a blend of GPS and baro alt data if desired\n-\t\t\t\t_ekf->hgtMea = 1.0f * (_ekf->baroHgt - _baro_ref);\n-\t\t\t\t_ekf->fuseHgtData = true;\n-\t\t\t\t// recall states stored at time of measurement after adjusting for delays\n-\t\t\t\t_ekf->RecallStates(_ekf->statesAtHgtTime, (IMUmsec - _parameters.height_delay_ms));\n-\t\t\t\t// run the fusion step\n-\t\t\t\t_ekf->FuseVelposNED();\n+\t\t\t\t\t// Run the strapdown INS equations every IMU update\n+\t\t\t\t\t_ekf->UpdateStrapdownEquationsNED();\n+\t#if 0\n+\t\t\t\t\t// debug code - could be tunred into a filter mnitoring/watchdog function\n+\t\t\t\t\tfloat tempQuat[4];\n \n-\t\t\t} else {\n-\t\t\t\t_ekf->fuseHgtData = false;\n-\t\t\t}\n+\t\t\t\t\tfor (uint8_t j = 0; j <= 3; j++) tempQuat[j] = states[j];\n \n-\t\t\t// Fuse Magnetometer Measurements\n-\t\t\tif (newDataMag && _ekf->statesInitialised) {\n-\t\t\t\t_ekf->fuseMagData = true;\n-\t\t\t\t_ekf->RecallStates(_ekf->statesAtMagMeasTime, (IMUmsec - _parameters.mag_delay_ms)); // Assume 50 msec avg delay for magnetometer data\n+\t\t\t\t\tquat2eul(eulerEst, tempQuat);\n \n-\t\t\t} else {\n-\t\t\t\t_ekf->fuseMagData = false;\n-\t\t\t}\n+\t\t\t\t\tfor (uint8_t j = 0; j <= 2; j++) eulerDif[j] = eulerEst[j] - ahrsEul[j];\n \n-\t\t\tif (_ekf->statesInitialised) _ekf->FuseMagnetometer();\n+\t\t\t\t\tif (eulerDif[2] > pi) eulerDif[2] -= 2 * pi;\n \n-\t\t\t// Fuse Airspeed Measurements\n-\t\t\tif (newAdsData && _ekf->statesInitialised && _ekf->VtasMeas > 8.0f) {\n-\t\t\t\t_ekf->fuseVtasData = true;\n-\t\t\t\t_ekf->RecallStates(_ekf->statesAtVtasMeasTime, (IMUmsec - _parameters.tas_delay_ms)); // assume 100 msec avg delay for airspeed data\n-\t\t\t\t_ekf->FuseAirspeed();\n+\t\t\t\t\tif (eulerDif[2] < -pi) eulerDif[2] += 2 * pi;\n \n-\t\t\t} else {\n-\t\t\t\t_ekf->fuseVtasData = false;\n-\t\t\t}\n+\t#endif\n+\t\t\t\t\t// store the predicted states for subsequent use by measurement fusion\n+\t\t\t\t\t_ekf->StoreStates(IMUmsec);\n+\t\t\t\t\t// Check if on ground - status is used by covariance prediction\n+\t\t\t\t\t_ekf->OnGroundCheck();\n+\t\t\t\t\t// sum delta angles and time used by covariance prediction\n+\t\t\t\t\t_ekf->summedDelAng = _ekf->summedDelAng + _ekf->correctedDelAng;\n+\t\t\t\t\t_ekf->summedDelVel = _ekf->summedDelVel + _ekf->dVelIMU;\n+\t\t\t\t\tdt += _ekf->dtIMU;\n+\n+\t\t\t\t\t// perform a covariance prediction if the total delta angle has exceeded the limit\n+\t\t\t\t\t// or the time limit will be exceeded at the next IMU update\n+\t\t\t\t\tif ((dt >= (_ekf->covTimeStepMax - _ekf->dtIMU)) || (_ekf->summedDelAng.length() > _ekf->covDelAngMax)) {\n+\t\t\t\t\t\t_ekf->CovariancePrediction(dt);\n+\t\t\t\t\t\t_ekf->summedDelAng.zero();\n+\t\t\t\t\t\t_ekf->summedDelVel.zero();\n+\t\t\t\t\t\tdt = 0.0f;\n+\t\t\t\t\t}\n \n-\t\t\t// Publish results\n-\t\t\tif (_initialized && (check == OK)) {\n-\n-\n-\n-\t\t\t\t// State vector:\n-\t\t\t\t// 0-3: quaternions (q0, q1, q2, q3)\n-\t\t\t\t// 4-6: Velocity - m/sec (North, East, Down)\n-\t\t\t\t// 7-9: Position - m (North, East, Down)\n-\t\t\t\t// 10-12: Delta Angle bias - rad (X,Y,Z)\n-\t\t\t\t// 13-14: Wind Vector  - m/sec (North,East)\n-\t\t\t\t// 15-17: Earth Magnetic Field Vector - milligauss (North, East, Down)\n-\t\t\t\t// 18-20: Body Magnetic Field Vector - milligauss (X,Y,Z)\n-\n-\t\t\t\tmath::Quaternion q(_ekf->states[0], _ekf->states[1], _ekf->states[2], _ekf->states[3]);\n-\t\t\t\tmath::Matrix<3, 3> R = q.to_dcm();\n-\t\t\t\tmath::Vector<3> euler = R.to_euler();\n-\n-\t\t\t\tfor (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++)\n-\t\t\t\t\t\t_att.R[i][j] = R(i, j);\n-\n-\t\t\t\t_att.timestamp = last_sensor_timestamp;\n-\t\t\t\t_att.q[0] = _ekf->states[0];\n-\t\t\t\t_att.q[1] = _ekf->states[1];\n-\t\t\t\t_att.q[2] = _ekf->states[2];\n-\t\t\t\t_att.q[3] = _ekf->states[3];\n-\t\t\t\t_att.q_valid = true;\n-\t\t\t\t_att.R_valid = true;\n-\n-\t\t\t\t_att.timestamp = last_sensor_timestamp;\n-\t\t\t\t_att.roll = euler(0);\n-\t\t\t\t_att.pitch = euler(1);\n-\t\t\t\t_att.yaw = euler(2);\n-\n-\t\t\t\t_att.rollspeed = _ekf->angRate.x - _ekf->states[10];\n-\t\t\t\t_att.pitchspeed = _ekf->angRate.y - _ekf->states[11];\n-\t\t\t\t_att.yawspeed = _ekf->angRate.z - _ekf->states[12];\n-\t\t\t\t// gyro offsets\n-\t\t\t\t_att.rate_offsets[0] = _ekf->states[10];\n-\t\t\t\t_att.rate_offsets[1] = _ekf->states[11];\n-\t\t\t\t_att.rate_offsets[2] = _ekf->states[12];\n-\n-\t\t\t\t/* lazily publish the attitude only once available */\n-\t\t\t\tif (_att_pub > 0) {\n-\t\t\t\t\t/* publish the attitude setpoint */\n-\t\t\t\t\torb_publish(ORB_ID(vehicle_attitude), _att_pub, &_att);\n+\t\t\t\t\t// Fuse GPS Measurements\n+\t\t\t\t\tif (newDataGps && _gps_initialized) {\n+\t\t\t\t\t\t// Convert GPS measurements to Pos NE, hgt and Vel NED\n+\n+\t\t\t\t\t\tfloat gps_dt = (_gps.timestamp_position - last_gps) / 1e6f;\n+\n+\t\t\t\t\t\t// Calculate acceleration predicted by GPS velocity change\n+\t\t\t\t\t\tif (((fabsf(_ekf->velNED[0] - _gps.vel_n_m_s) > FLT_EPSILON) ||\n+\t\t\t\t\t\t\t(fabsf(_ekf->velNED[1] - _gps.vel_e_m_s) > FLT_EPSILON) ||\n+\t\t\t\t\t\t\t(fabsf(_ekf->velNED[2] - _gps.vel_d_m_s) > FLT_EPSILON)) && (gps_dt > 0.00001f)) {\n+\n+\t\t\t\t\t\t\t_ekf->accelGPSNED[0] = (_ekf->velNED[0] - _gps.vel_n_m_s) / gps_dt;\n+\t\t\t\t\t\t\t_ekf->accelGPSNED[1] = (_ekf->velNED[1] - _gps.vel_e_m_s) / gps_dt;\n+\t\t\t\t\t\t\t_ekf->accelGPSNED[2] = (_ekf->velNED[2] - _gps.vel_d_m_s) / gps_dt;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t_ekf->velNED[0] = _gps.vel_n_m_s;\n+\t\t\t\t\t\t_ekf->velNED[1] = _gps.vel_e_m_s;\n+\t\t\t\t\t\t_ekf->velNED[2] = _gps.vel_d_m_s;\n+\t\t\t\t\t\t_ekf->calcposNED(posNED, _ekf->gpsLat, _ekf->gpsLon, _ekf->gpsHgt, _ekf->latRef, _ekf->lonRef, _ekf->hgtRef);\n+\n+\t\t\t\t\t\t_ekf->posNE[0] = posNED[0];\n+\t\t\t\t\t\t_ekf->posNE[1] = posNED[1];\n+\t\t\t\t\t\t// set fusion flags\n+\t\t\t\t\t\t_ekf->fuseVelData = true;\n+\t\t\t\t\t\t_ekf->fusePosData = true;\n+\t\t\t\t\t\t// recall states stored at time of measurement after adjusting for delays\n+\t\t\t\t\t\t_ekf->RecallStates(_ekf->statesAtVelTime, (IMUmsec - _parameters.vel_delay_ms));\n+\t\t\t\t\t\t_ekf->RecallStates(_ekf->statesAtPosTime, (IMUmsec - _parameters.pos_delay_ms));\n+\t\t\t\t\t\t// run the fusion step\n+\t\t\t\t\t\t_ekf->FuseVelposNED();\n+\n+\t\t\t\t\t} else if (_ekf->statesInitialised) {\n+\t\t\t\t\t\t// Convert GPS measurements to Pos NE, hgt and Vel NED\n+\t\t\t\t\t\t_ekf->velNED[0] = 0.0f;\n+\t\t\t\t\t\t_ekf->velNED[1] = 0.0f;\n+\t\t\t\t\t\t_ekf->velNED[2] = 0.0f;\n+\n+\t\t\t\t\t\t_ekf->posNE[0] = 0.0f;\n+\t\t\t\t\t\t_ekf->posNE[1] = 0.0f;\n+\t\t\t\t\t\t// set fusion flags\n+\t\t\t\t\t\t_ekf->fuseVelData = true;\n+\t\t\t\t\t\t_ekf->fusePosData = true;\n+\t\t\t\t\t\t// recall states stored at time of measurement after adjusting for delays\n+\t\t\t\t\t\t_ekf->RecallStates(_ekf->statesAtVelTime, (IMUmsec - _parameters.vel_delay_ms));\n+\t\t\t\t\t\t_ekf->RecallStates(_ekf->statesAtPosTime, (IMUmsec - _parameters.pos_delay_ms));\n+\t\t\t\t\t\t// run the fusion step\n+\t\t\t\t\t\t_ekf->FuseVelposNED();\n \n-\t\t\t\t} else {\n-\t\t\t\t\t/* advertise and publish */\n-\t\t\t\t\t_att_pub = orb_advertise(ORB_ID(vehicle_attitude), &_att);\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t_ekf->fuseVelData = false;\n+\t\t\t\t\t\t_ekf->fusePosData = false;\n+\t\t\t\t\t}\n \n-\t\t\tif (_gps_initialized) {\n-\t\t\t\t_local_pos.timestamp = last_sensor_timestamp;\n-\t\t\t\t_local_pos.x = _ekf->states[7];\n-\t\t\t\t_local_pos.y = _ekf->states[8];\n-\t\t\t\t// XXX need to announce change of Z reference somehow elegantly\n-\t\t\t\t_local_pos.z = _ekf->states[9] - _baro_gps_offset;\n-\n-\t\t\t\t_local_pos.vx = _ekf->states[4];\n-\t\t\t\t_local_pos.vy = _ekf->states[5];\n-\t\t\t\t_local_pos.vz = _ekf->states[6];\n-\n-\t\t\t\t_local_pos.xy_valid = _gps_initialized;\n-\t\t\t\t_local_pos.z_valid = true;\n-\t\t\t\t_local_pos.v_xy_valid = _gps_initialized;\n-\t\t\t\t_local_pos.v_z_valid = true;\n-\t\t\t\t_local_pos.xy_global = true;\n-\n-\t\t\t\t_local_pos.z_global = false;\n-\t\t\t\t_local_pos.yaw = _att.yaw;\n-\n-\t\t\t\t _velocity_xy_filtered = 0.95f*_velocity_xy_filtered + 0.05f*sqrtf(_local_pos.vx*_local_pos.vx + _local_pos.vy*_local_pos.vy);\n-\t\t\t\t _velocity_z_filtered = 0.95f*_velocity_z_filtered + 0.05f*fabsf(_local_pos.vz);\n-\t\t\t\t _airspeed_filtered = 0.95*_airspeed_filtered + + 0.05*_airspeed.true_airspeed_m_s;\n-\n-\n-\t\t\t\t/* crude land detector for fixedwing only,\n-\t\t\t\t * TODO: adapt so that it works for both, maybe move to another location\n-\t\t\t\t */\n-\t\t\t\tif (_velocity_xy_filtered < 5\n-\t\t\t\t\t&& _velocity_z_filtered < 10\n-\t\t\t\t\t&& _airspeed_filtered < 10) {\n-\t\t\t\t\t_local_pos.landed = true;\n-\t\t\t\t} else {\n-\t\t\t\t\t_local_pos.landed = false;\n-\t\t\t\t}\n+\t\t\t\t\tif (newHgtData && _ekf->statesInitialised) {\n+\t\t\t\t\t\t// Could use a blend of GPS and baro alt data if desired\n+\t\t\t\t\t\t_ekf->hgtMea = 1.0f * (_ekf->baroHgt - _baro_ref);\n+\t\t\t\t\t\t_ekf->fuseHgtData = true;\n+\t\t\t\t\t\t// recall states stored at time of measurement after adjusting for delays\n+\t\t\t\t\t\t_ekf->RecallStates(_ekf->statesAtHgtTime, (IMUmsec - _parameters.height_delay_ms));\n+\t\t\t\t\t\t// run the fusion step\n+\t\t\t\t\t\t_ekf->FuseVelposNED();\n \n-\t\t\t\t/* lazily publish the local position only once available */\n-\t\t\t\tif (_local_pos_pub > 0) {\n-\t\t\t\t\t/* publish the attitude setpoint */\n-\t\t\t\t\torb_publish(ORB_ID(vehicle_local_position), _local_pos_pub, &_local_pos);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t_ekf->fuseHgtData = false;\n+\t\t\t\t\t}\n \n-\t\t\t\t} else {\n-\t\t\t\t\t/* advertise and publish */\n-\t\t\t\t\t_local_pos_pub = orb_advertise(ORB_ID(vehicle_local_position), &_local_pos);\n-\t\t\t\t}\n+\t\t\t\t\t// Fuse Magnetometer Measurements\n+\t\t\t\t\tif (newDataMag && _ekf->statesInitialised) {\n+\t\t\t\t\t\t_ekf->fuseMagData = true;\n+\t\t\t\t\t\t_ekf->RecallStates(_ekf->statesAtMagMeasTime, (IMUmsec - _parameters.mag_delay_ms)); // Assume 50 msec avg delay for magnetometer data\n \n-\t\t\t\t_global_pos.timestamp = _local_pos.timestamp;\n+\t\t\t\t\t\t_ekf->magstate.obsIndex = 0;\n+\t\t\t\t\t\t_ekf->FuseMagnetometer();\n+\t\t\t\t\t\t_ekf->FuseMagnetometer();\n+\t\t\t\t\t\t_ekf->FuseMagnetometer();\n \n-\t\t\t\tif (_local_pos.xy_global) {\n-\t\t\t\t\tdouble est_lat, est_lon;\n-\t\t\t\t\tmap_projection_reproject(&_pos_ref, _local_pos.x, _local_pos.y, &est_lat, &est_lon);\n-\t\t\t\t\t_global_pos.lat = est_lat;\n-\t\t\t\t\t_global_pos.lon = est_lon;\n-\t\t\t\t\t_global_pos.time_gps_usec = _gps.time_gps_usec;\n-\t\t\t\t\t_global_pos.eph = _gps.eph;\n-\t\t\t\t\t_global_pos.epv = _gps.epv;\n-\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t_ekf->fuseMagData = false;\n+\t\t\t\t\t}\n \n-\t\t\t\tif (_local_pos.v_xy_valid) {\n-\t\t\t\t\t_global_pos.vel_n = _local_pos.vx;\n-\t\t\t\t\t_global_pos.vel_e = _local_pos.vy;\n-\t\t\t\t} else {\n-\t\t\t\t\t_global_pos.vel_n = 0.0f;\n-\t\t\t\t\t_global_pos.vel_e = 0.0f;\n-\t\t\t\t}\n+\t\t\t\t\t// Fuse Airspeed Measurements\n+\t\t\t\t\tif (newAdsData && _ekf->statesInitialised && _ekf->VtasMeas > 8.0f) {\n+\t\t\t\t\t\t_ekf->fuseVtasData = true;\n+\t\t\t\t\t\t_ekf->RecallStates(_ekf->statesAtVtasMeasTime, (IMUmsec - _parameters.tas_delay_ms)); // assume 100 msec avg delay for airspeed data\n+\t\t\t\t\t\t_ekf->FuseAirspeed();\n \n-\t\t\t\t/* local pos alt is negative, change sign and add alt offsets */\n-\t\t\t\t_global_pos.alt = _local_pos.ref_alt + _baro_gps_offset + (-_local_pos.z);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t_ekf->fuseVtasData = false;\n+\t\t\t\t\t}\n \n-\t\t\t\tif (_local_pos.v_z_valid) {\n-\t\t\t\t\t_global_pos.vel_d = _local_pos.vz;\n-\t\t\t\t}\n \n-\t\t\t\t_global_pos.yaw = _local_pos.yaw;\n+\t\t\t\t\t// Output results\n+\t\t\t\t\tmath::Quaternion q(_ekf->states[0], _ekf->states[1], _ekf->states[2], _ekf->states[3]);\n+\t\t\t\t\tmath::Matrix<3, 3> R = q.to_dcm();\n+\t\t\t\t\tmath::Vector<3> euler = R.to_euler();\n+\n+\t\t\t\t\tfor (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++)\n+\t\t\t\t\t\t\t_att.R[i][j] = R(i, j);\n+\n+\t\t\t\t\t_att.timestamp = _last_sensor_timestamp;\n+\t\t\t\t\t_att.q[0] = _ekf->states[0];\n+\t\t\t\t\t_att.q[1] = _ekf->states[1];\n+\t\t\t\t\t_att.q[2] = _ekf->states[2];\n+\t\t\t\t\t_att.q[3] = _ekf->states[3];\n+\t\t\t\t\t_att.q_valid = true;\n+\t\t\t\t\t_att.R_valid = true;\n+\n+\t\t\t\t\t_att.timestamp = _last_sensor_timestamp;\n+\t\t\t\t\t_att.roll = euler(0);\n+\t\t\t\t\t_att.pitch = euler(1);\n+\t\t\t\t\t_att.yaw = euler(2);\n+\n+\t\t\t\t\t_att.rollspeed = _ekf->angRate.x - _ekf->states[10];\n+\t\t\t\t\t_att.pitchspeed = _ekf->angRate.y - _ekf->states[11];\n+\t\t\t\t\t_att.yawspeed = _ekf->angRate.z - _ekf->states[12];\n+\t\t\t\t\t// gyro offsets\n+\t\t\t\t\t_att.rate_offsets[0] = _ekf->states[10];\n+\t\t\t\t\t_att.rate_offsets[1] = _ekf->states[11];\n+\t\t\t\t\t_att.rate_offsets[2] = _ekf->states[12];\n+\n+\t\t\t\t\t/* lazily publish the attitude only once available */\n+\t\t\t\t\tif (_att_pub > 0) {\n+\t\t\t\t\t\t/* publish the attitude setpoint */\n+\t\t\t\t\t\torb_publish(ORB_ID(vehicle_attitude), _att_pub, &_att);\n \n-\t\t\t\t_global_pos.eph = _gps.eph;\n-\t\t\t\t_global_pos.epv = _gps.epv;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t/* advertise and publish */\n+\t\t\t\t\t\t_att_pub = orb_advertise(ORB_ID(vehicle_attitude), &_att);\n+\t\t\t\t\t}\n \n-\t\t\t\t_global_pos.timestamp = _local_pos.timestamp;\n+\t\t\t\t\tif (_gps_initialized) {\n+\t\t\t\t\t\t_local_pos.timestamp = _last_sensor_timestamp;\n+\t\t\t\t\t\t_local_pos.x = _ekf->states[7];\n+\t\t\t\t\t\t_local_pos.y = _ekf->states[8];\n+\t\t\t\t\t\t// XXX need to announce change of Z reference somehow elegantly\n+\t\t\t\t\t\t_local_pos.z = _ekf->states[9] - _baro_ref_offset;\n+\n+\t\t\t\t\t\t_local_pos.vx = _ekf->states[4];\n+\t\t\t\t\t\t_local_pos.vy = _ekf->states[5];\n+\t\t\t\t\t\t_local_pos.vz = _ekf->states[6];\n+\n+\t\t\t\t\t\t_local_pos.xy_valid = _gps_initialized;\n+\t\t\t\t\t\t_local_pos.z_valid = true;\n+\t\t\t\t\t\t_local_pos.v_xy_valid = _gps_initialized;\n+\t\t\t\t\t\t_local_pos.v_z_valid = true;\n+\t\t\t\t\t\t_local_pos.xy_global = true;\n+\n+\t\t\t\t\t\t_velocity_xy_filtered = 0.95f*_velocity_xy_filtered + 0.05f*sqrtf(_local_pos.vx*_local_pos.vx + _local_pos.vy*_local_pos.vy);\n+\t\t\t\t\t\t_velocity_z_filtered = 0.95f*_velocity_z_filtered + 0.05f*fabsf(_local_pos.vz);\n+\t\t\t\t\t\t_airspeed_filtered = 0.95f*_airspeed_filtered + + 0.05f*_airspeed.true_airspeed_m_s;\n+\n+\n+\t\t\t\t\t\t/* crude land detector for fixedwing only,\n+\t\t\t\t\t\t* TODO: adapt so that it works for both, maybe move to another location\n+\t\t\t\t\t\t*/\n+\t\t\t\t\t\tif (_velocity_xy_filtered < 5\n+\t\t\t\t\t\t\t&& _velocity_z_filtered < 10\n+\t\t\t\t\t\t\t&& _airspeed_filtered < 10) {\n+\t\t\t\t\t\t\t_local_pos.landed = true;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t_local_pos.landed = false;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t_local_pos.z_global = false;\n+\t\t\t\t\t\t_local_pos.yaw = _att.yaw;\n+\n+\t\t\t\t\t\t/* lazily publish the local position only once available */\n+\t\t\t\t\t\tif (_local_pos_pub > 0) {\n+\t\t\t\t\t\t\t/* publish the attitude setpoint */\n+\t\t\t\t\t\t\torb_publish(ORB_ID(vehicle_local_position), _local_pos_pub, &_local_pos);\n+\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t/* advertise and publish */\n+\t\t\t\t\t\t\t_local_pos_pub = orb_advertise(ORB_ID(vehicle_local_position), &_local_pos);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t_global_pos.timestamp = _local_pos.timestamp;\n+\n+\t\t\t\t\t\tif (_local_pos.xy_global) {\n+\t\t\t\t\t\t\tdouble est_lat, est_lon;\n+\t\t\t\t\t\t\tmap_projection_reproject(&_pos_ref, _local_pos.x, _local_pos.y, &est_lat, &est_lon);\n+\t\t\t\t\t\t\t_global_pos.lat = est_lat;\n+\t\t\t\t\t\t\t_global_pos.lon = est_lon;\n+\t\t\t\t\t\t\t_global_pos.time_gps_usec = _gps.time_gps_usec;\n+\t\t\t\t\t\t\t_global_pos.eph = _gps.eph;\n+\t\t\t\t\t\t\t_global_pos.epv = _gps.epv;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif (_local_pos.v_xy_valid) {\n+\t\t\t\t\t\t\t_global_pos.vel_n = _local_pos.vx;\n+\t\t\t\t\t\t\t_global_pos.vel_e = _local_pos.vy;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t_global_pos.vel_n = 0.0f;\n+\t\t\t\t\t\t\t_global_pos.vel_e = 0.0f;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t/* local pos alt is negative, change sign and add alt offsets */\n+\t\t\t\t\t\t_global_pos.alt = _baro_ref + (-_local_pos.z) - _baro_gps_offset;\n+\n+\t\t\t\t\t\tif (_local_pos.v_z_valid) {\n+\t\t\t\t\t\t\t_global_pos.vel_d = _local_pos.vz;\n+\t\t\t\t\t\t}\n+\n+\n+\t\t\t\t\t\t_global_pos.yaw = _local_pos.yaw;\n+\n+\t\t\t\t\t\t_global_pos.eph = _gps.eph;\n+\t\t\t\t\t\t_global_pos.epv = _gps.epv;\n+\n+\t\t\t\t\t\t_global_pos.timestamp = _local_pos.timestamp;\n+\n+\t\t\t\t\t\t/* lazily publish the global position only once available */\n+\t\t\t\t\t\tif (_global_pos_pub > 0) {\n+\t\t\t\t\t\t\t/* publish the global position */\n+\t\t\t\t\t\t\torb_publish(ORB_ID(vehicle_global_position), _global_pos_pub, &_global_pos);\n+\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t/* advertise and publish */\n+\t\t\t\t\t\t\t_global_pos_pub = orb_advertise(ORB_ID(vehicle_global_position), &_global_pos);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif (hrt_elapsed_time(&_wind.timestamp) > 99000) {\n+\t\t\t\t\t\t\t_wind.timestamp = _global_pos.timestamp;\n+\t\t\t\t\t\t\t_wind.windspeed_north = _ekf->states[14];\n+\t\t\t\t\t\t\t_wind.windspeed_east = _ekf->states[15];\n+\t\t\t\t\t\t\t_wind.covariance_north = 0.0f; // XXX get form filter\n+\t\t\t\t\t\t\t_wind.covariance_east = 0.0f;\n+\n+\t\t\t\t\t\t\t/* lazily publish the wind estimate only once available */\n+\t\t\t\t\t\t\tif (_wind_pub > 0) {\n+\t\t\t\t\t\t\t\t/* publish the wind estimate */\n+\t\t\t\t\t\t\t\torb_publish(ORB_ID(wind_estimate), _wind_pub, &_wind);\n+\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t/* advertise and publish */\n+\t\t\t\t\t\t\t\t_wind_pub = orb_advertise(ORB_ID(wind_estimate), &_wind);\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t}\n \n-\t\t\t\t/* lazily publish the global position only once available */\n-\t\t\t\tif (_global_pos_pub > 0) {\n-\t\t\t\t\t/* publish the global position */\n-\t\t\t\t\torb_publish(ORB_ID(vehicle_global_position), _global_pos_pub, &_global_pos);\n+\t\t\t\t\t}\n \n-\t\t\t\t} else {\n-\t\t\t\t\t/* advertise and publish */\n-\t\t\t\t\t_global_pos_pub = orb_advertise(ORB_ID(vehicle_global_position), &_global_pos);\n \t\t\t\t}\n \n \t\t\t\tif (hrt_elapsed_time(&_wind.timestamp) > 99000) {\n@@ -1430,34 +1560,44 @@ FixedwingEstimator::print_status()\n \t// 4-6: Velocity - m/sec (North, East, Down)\n \t// 7-9: Position - m (North, East, Down)\n \t// 10-12: Delta Angle bias - rad (X,Y,Z)\n-\t// 13-14: Wind Vector  - m/sec (North,East)\n-\t// 15-17: Earth Magnetic Field Vector - gauss (North, East, Down)\n-\t// 18-20: Body Magnetic Field Vector - gauss (X,Y,Z)\n+\t// 13:    Accelerometer offset\n+\t// 14-15: Wind Vector  - m/sec (North,East)\n+\t// 16-18: Earth Magnetic Field Vector - gauss (North, East, Down)\n+\t// 19-21: Body Magnetic Field Vector - gauss (X,Y,Z)\n \n \tprintf(\"dtIMU: %8.6f IMUmsec: %d\\n\", (double)_ekf->dtIMU, (int)IMUmsec);\n-\tprintf(\"ref alt: %8.6f\\n\", (double)_local_pos.ref_alt);\n+\tprintf(\"baro alt: %8.4f GPS alt: %8.4f\\n\", (double)_baro.altitude, (double)(_gps.alt / 1e3f));\n+\tprintf(\"ref alt: %8.4f baro ref offset: %8.4f baro GPS offset: %8.4f\\n\", (double)_baro_ref, (double)_baro_ref_offset, (double)_baro_gps_offset);\n \tprintf(\"dvel: %8.6f %8.6f %8.6f accel: %8.6f %8.6f %8.6f\\n\", (double)_ekf->dVelIMU.x, (double)_ekf->dVelIMU.y, (double)_ekf->dVelIMU.z, (double)_ekf->accel.x, (double)_ekf->accel.y, (double)_ekf->accel.z);\n \tprintf(\"dang: %8.4f %8.4f %8.4f dang corr: %8.4f %8.4f %8.4f\\n\" , (double)_ekf->dAngIMU.x, (double)_ekf->dAngIMU.y, (double)_ekf->dAngIMU.z, (double)_ekf->correctedDelAng.x, (double)_ekf->correctedDelAng.y, (double)_ekf->correctedDelAng.z);\n-\tprintf(\"states (quat)        [1-4]: %8.4f, %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[0], (double)_ekf->states[1], (double)_ekf->states[2], (double)_ekf->states[3]);\n-\tprintf(\"states (vel m/s)     [5-7]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[4], (double)_ekf->states[5], (double)_ekf->states[6]);\n-\tprintf(\"states (pos m)      [8-10]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[7], (double)_ekf->states[8], (double)_ekf->states[9]);\n-\tprintf(\"states (delta ang) [11-13]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[10], (double)_ekf->states[11], (double)_ekf->states[12]);\n-\tprintf(\"states (accel offs)   [14]: %8.4f\\n\", (double)_ekf->states[13]);\n-\tprintf(\"states (wind)      [15-16]: %8.4f, %8.4f\\n\", (double)_ekf->states[14], (double)_ekf->states[15]);\n-\tprintf(\"states (earth mag) [17-19]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[16], (double)_ekf->states[17], (double)_ekf->states[18]);\n-\tprintf(\"states (body mag)  [20-22]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[19], (double)_ekf->states[20], (double)_ekf->states[21]);\n-\tprintf(\"states (terrain)      [23]: %8.4f\\n\", (double)_ekf->states[22]);\n+\tprintf(\"states (quat)        [0-3]: %8.4f, %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[0], (double)_ekf->states[1], (double)_ekf->states[2], (double)_ekf->states[3]);\n+\tprintf(\"states (vel m/s)     [4-6]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[4], (double)_ekf->states[5], (double)_ekf->states[6]);\n+\tprintf(\"states (pos m)      [7-9]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[7], (double)_ekf->states[8], (double)_ekf->states[9]);\n+\tprintf(\"states (delta ang) [10-12]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[10], (double)_ekf->states[11], (double)_ekf->states[12]);\n+\n+\tif (n_states == 23) {\n+\t\tprintf(\"states (accel offs)   [13]: %8.4f\\n\", (double)_ekf->states[13]);\n+\t\tprintf(\"states (wind)      [14-15]: %8.4f, %8.4f\\n\", (double)_ekf->states[14], (double)_ekf->states[15]);\n+\t\tprintf(\"states (earth mag) [16-18]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[16], (double)_ekf->states[17], (double)_ekf->states[18]);\n+\t\tprintf(\"states (body mag)  [19-21]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[19], (double)_ekf->states[20], (double)_ekf->states[21]);\n+\t\tprintf(\"states (terrain)      [22]: %8.4f\\n\", (double)_ekf->states[22]);\n+\n+\t} else {\n+\t\tprintf(\"states (wind)      [13-14]: %8.4f, %8.4f\\n\", (double)_ekf->states[13], (double)_ekf->states[14]);\n+\t\tprintf(\"states (earth mag) [15-17]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[15], (double)_ekf->states[16], (double)_ekf->states[17]);\n+\t\tprintf(\"states (body mag)  [18-20]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[18], (double)_ekf->states[19], (double)_ekf->states[20]);\n+\t}\n \tprintf(\"states: %s %s %s %s %s %s %s %s %s %s\\n\",\n-\t       (_ekf->statesInitialised) ? \"INITIALIZED\" : \"NON_INIT\",\n-\t       (_ekf->onGround) ? \"ON_GROUND\" : \"AIRBORNE\",\n-\t       (_ekf->fuseVelData) ? \"FUSE_VEL\" : \"INH_VEL\",\n-\t       (_ekf->fusePosData) ? \"FUSE_POS\" : \"INH_POS\",\n-\t       (_ekf->fuseHgtData) ? \"FUSE_HGT\" : \"INH_HGT\",\n-\t       (_ekf->fuseMagData) ? \"FUSE_MAG\" : \"INH_MAG\",\n-\t       (_ekf->fuseVtasData) ? \"FUSE_VTAS\" : \"INH_VTAS\",\n-\t       (_ekf->useAirspeed) ? \"USE_AIRSPD\" : \"IGN_AIRSPD\",\n-\t       (_ekf->useCompass) ? \"USE_COMPASS\" : \"IGN_COMPASS\",\n-\t       (_ekf->staticMode) ? \"STATIC_MODE\" : \"DYNAMIC_MODE\");\n+\t\t       (_ekf->statesInitialised) ? \"INITIALIZED\" : \"NON_INIT\",\n+\t\t       (_ekf->onGround) ? \"ON_GROUND\" : \"AIRBORNE\",\n+\t\t       (_ekf->fuseVelData) ? \"FUSE_VEL\" : \"INH_VEL\",\n+\t\t       (_ekf->fusePosData) ? \"FUSE_POS\" : \"INH_POS\",\n+\t\t       (_ekf->fuseHgtData) ? \"FUSE_HGT\" : \"INH_HGT\",\n+\t\t       (_ekf->fuseMagData) ? \"FUSE_MAG\" : \"INH_MAG\",\n+\t\t       (_ekf->fuseVtasData) ? \"FUSE_VTAS\" : \"INH_VTAS\",\n+\t\t       (_ekf->useAirspeed) ? \"USE_AIRSPD\" : \"IGN_AIRSPD\",\n+\t\t       (_ekf->useCompass) ? \"USE_COMPASS\" : \"IGN_COMPASS\",\n+\t\t       (_ekf->staticMode) ? \"STATIC_MODE\" : \"DYNAMIC_MODE\");\n }\n \n int FixedwingEstimator::trip_nan() {\n@@ -1512,7 +1652,7 @@ int FixedwingEstimator::trip_nan() {\n int ekf_att_pos_estimator_main(int argc, char *argv[])\n {\n \tif (argc < 1)\n-\t\terrx(1, \"usage: ekf_att_pos_estimator {start|stop|status}\");\n+\t\terrx(1, \"usage: ekf_att_pos_estimator {start|stop|status|logging}\");\n \n \tif (!strcmp(argv[1], \"start\")) {\n \n@@ -1566,6 +1706,29 @@ int ekf_att_pos_estimator_main(int argc, char *argv[])\n \t\t}\n \t}\n \n+\tif (!strcmp(argv[1], \"logging\")) {\n+\t\tif (estimator::g_estimator) {\n+\t\t\tint ret = estimator::g_estimator->enable_logging(true);\n+\n+\t\t\texit(ret);\n+\n+\t\t} else {\n+\t\t\terrx(1, \"not running\");\n+\t\t}\n+\t}\n+\n+\tif (!strcmp(argv[1], \"debug\")) {\n+\t\tif (estimator::g_estimator) {\n+\t\t\tint debug = strtoul(argv[2], NULL, 10);\n+\t\t\tint ret = estimator::g_estimator->set_debuglevel(debug);\n+\n+\t\t\texit(ret);\n+\n+\t\t} else {\n+\t\t\terrx(1, \"not running\");\n+\t\t}\n+\t}\n+\n \twarnx(\"unrecognized command\");\n \treturn 1;\n }"},{"sha":"67bfec4ea3b8acec87a414d707c54970c7a00683","filename":"src/modules/ekf_att_pos_estimator/estimator_21states.cpp","status":"added","additions":2142,"deletions":0,"changes":2142,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_21states.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_21states.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_21states.cpp?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa"},{"sha":"a19ff19952ed7ad48e6f75292bf85986fa0df737","filename":"src/modules/ekf_att_pos_estimator/estimator_21states.h","status":"added","additions":247,"deletions":0,"changes":247,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_21states.h","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_21states.h","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_21states.h?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -0,0 +1,247 @@\n+#pragma once\n+\n+#include \"estimator_utilities.h\"\n+\n+class AttPosEKF {\n+\n+public:\n+\n+    AttPosEKF();\n+    ~AttPosEKF();\n+\n+    /* ##############################################\n+     *\n+     *   M A I N    F I L T E R    P A R A M E T E R S\n+     *\n+     * ########################################### */\n+\n+    /*\n+     * parameters are defined here and initialised in\n+     * the InitialiseParameters() (which is just 20 lines down)\n+     */\n+\n+    float covTimeStepMax; // maximum time allowed between covariance predictions\n+    float covDelAngMax; // maximum delta angle between covariance predictions\n+    float rngFinderPitch; // pitch angle of laser range finder in radians. Zero is aligned with the Z body axis. Positive is RH rotation about Y body axis.\n+\n+    float yawVarScale;\n+    float windVelSigma;\n+    float dAngBiasSigma;\n+    float dVelBiasSigma;\n+    float magEarthSigma;\n+    float magBodySigma;\n+    float gndHgtSigma;\n+\n+    float vneSigma;\n+    float vdSigma;\n+    float posNeSigma;\n+    float posDSigma;\n+    float magMeasurementSigma;\n+    float airspeedMeasurementSigma;\n+\n+    float gyroProcessNoise;\n+    float accelProcessNoise;\n+\n+    float EAS2TAS; // ratio f true to equivalent airspeed\n+\n+    void InitialiseParameters()\n+    {\n+        covTimeStepMax = 0.07f; // maximum time allowed between covariance predictions\n+        covDelAngMax = 0.02f; // maximum delta angle between covariance predictions\n+        rngFinderPitch = 0.0f; // pitch angle of laser range finder in radians. Zero is aligned with the Z body axis. Positive is RH rotation about Y body axis.\n+        EAS2TAS = 1.0f;\n+\n+        yawVarScale = 1.0f;\n+        windVelSigma = 0.1f;\n+        dAngBiasSigma = 5.0e-7f;\n+        dVelBiasSigma = 1e-4f;\n+        magEarthSigma = 3.0e-4f;\n+        magBodySigma  = 3.0e-4f;\n+        gndHgtSigma  = 0.02f; // assume 2% terrain gradient 1-sigma\n+\n+        vneSigma = 0.2f;\n+        vdSigma = 0.3f;\n+        posNeSigma = 2.0f;\n+        posDSigma = 2.0f;\n+\n+        magMeasurementSigma = 0.05;\n+        airspeedMeasurementSigma = 1.4f;\n+        gyroProcessNoise = 1.4544411e-2f;\n+        accelProcessNoise = 0.5f;\n+    }\n+\n+    // Global variables\n+    float KH[n_states][n_states]; //  intermediate result used for covariance updates\n+    float KHP[n_states][n_states]; // intermediate result used for covariance updates\n+    float P[n_states][n_states]; // covariance matrix\n+    float Kfusion[n_states]; // Kalman gains\n+    float states[n_states]; // state matrix\n+    float storedStates[n_states][data_buffer_size]; // state vectors stored for the last 50 time steps\n+    uint32_t statetimeStamp[data_buffer_size]; // time stamp for each state vector stored\n+\n+    float statesAtVelTime[n_states]; // States at the effective measurement time for posNE and velNED measurements\n+    float statesAtPosTime[n_states]; // States at the effective measurement time for posNE and velNED measurements\n+    float statesAtHgtTime[n_states]; // States at the effective measurement time for the hgtMea measurement\n+    float statesAtMagMeasTime[n_states]; // filter satates at the effective measurement time\n+    float statesAtVtasMeasTime[n_states]; // filter states at the effective measurement time\n+\n+    Vector3f correctedDelAng; // delta angles about the xyz body axes corrected for errors (rad)\n+    Vector3f correctedDelVel; // delta velocities along the XYZ body axes corrected for errors (m/s)\n+    Vector3f summedDelAng; // summed delta angles about the xyz body axes corrected for errors (rad)\n+    Vector3f summedDelVel; // summed delta velocities along the XYZ body axes corrected for errors (m/s)\n+    float accNavMag; // magnitude of navigation accel (- used to adjust GPS obs variance (m/s^2)\n+    Vector3f earthRateNED; // earths angular rate vector in NED (rad/s)\n+    Vector3f angRate; // angular rate vector in XYZ body axes measured by the IMU (rad/s)\n+    Vector3f accel; // acceleration vector in XYZ body axes measured by the IMU (m/s^2)\n+    Vector3f dVelIMU;\n+    Vector3f dAngIMU;\n+    float dtIMU; // time lapsed since the last IMU measurement or covariance update (sec)\n+    uint8_t fusionModeGPS; // 0 = GPS outputs 3D velocity, 1 = GPS outputs 2D velocity, 2 = GPS outputs no velocity\n+    float innovVelPos[6]; // innovation output\n+    float varInnovVelPos[6]; // innovation variance output\n+\n+    float velNED[3]; // North, East, Down velocity obs (m/s)\n+    float posNE[2]; // North, East position obs (m)\n+    float hgtMea; //  measured height (m)\n+    float posNED[3]; // North, East Down position (m)\n+\n+    float innovMag[3]; // innovation output\n+    float varInnovMag[3]; // innovation variance output\n+    Vector3f magData; // magnetometer flux radings in X,Y,Z body axes\n+    float innovVtas; // innovation output\n+    float varInnovVtas; // innovation variance output\n+    float VtasMeas; // true airspeed measurement (m/s)\n+    float magDeclination;\n+    float latRef; // WGS-84 latitude of reference point (rad)\n+    float lonRef; // WGS-84 longitude of reference point (rad)\n+    float hgtRef; // WGS-84 height of reference point (m)\n+    Vector3f magBias; // states representing magnetometer bias vector in XYZ body axes\n+    uint8_t covSkipCount; // Number of state prediction frames (IMU daya updates to skip before doing the covariance prediction\n+\n+    // GPS input data variables\n+    float gpsCourse;\n+    float gpsVelD;\n+    float gpsLat;\n+    float gpsLon;\n+    float gpsHgt;\n+    uint8_t GPSstatus;\n+\n+    // Baro input\n+    float baroHgt;\n+\n+    bool statesInitialised;\n+\n+    bool fuseVelData; // this boolean causes the posNE and velNED obs to be fused\n+    bool fusePosData; // this boolean causes the posNE and velNED obs to be fused\n+    bool fuseHgtData; // this boolean causes the hgtMea obs to be fused\n+    bool fuseMagData; // boolean true when magnetometer data is to be fused\n+    bool fuseVtasData; // boolean true when airspeed data is to be fused\n+\n+    bool onGround;    ///< boolean true when the flight vehicle is on the ground (not flying)\n+    bool staticMode;    ///< boolean true if no position feedback is fused\n+    bool useAirspeed;    ///< boolean true if airspeed data is being used\n+    bool useCompass;    ///< boolean true if magnetometer data is being used\n+\n+    struct ekf_status_report current_ekf_state;\n+    struct ekf_status_report last_ekf_error;\n+\n+    bool numericalProtection;\n+\n+    unsigned storeIndex;\n+\n+\n+void  UpdateStrapdownEquationsNED();\n+\n+void CovariancePrediction(float dt);\n+\n+void FuseVelposNED();\n+\n+void FuseMagnetometer();\n+\n+void FuseAirspeed();\n+\n+void zeroRows(float (&covMat)[n_states][n_states], uint8_t first, uint8_t last);\n+\n+void zeroCols(float (&covMat)[n_states][n_states], uint8_t first, uint8_t last);\n+\n+void quatNorm(float (&quatOut)[4], const float quatIn[4]);\n+\n+// store staes along with system time stamp in msces\n+void StoreStates(uint64_t timestamp_ms);\n+\n+/**\n+ * Recall the state vector.\n+ *\n+ * Recalls the vector stored at closest time to the one specified by msec\n+ *\n+ * @return zero on success, integer indicating the number of invalid states on failure.\n+ *         Does only copy valid states, if the statesForFusion vector was initialized\n+ *         correctly by the caller, the result can be safely used, but is a mixture\n+ *         time-wise where valid states were updated and invalid remained at the old\n+ *         value.\n+ */\n+int RecallStates(float statesForFusion[n_states], uint64_t msec);\n+\n+void ResetStoredStates();\n+\n+void quat2Tbn(Mat3f &Tbn, const float (&quat)[4]);\n+\n+void calcEarthRateNED(Vector3f &omega, float latitude);\n+\n+static void eul2quat(float (&quat)[4], const float (&eul)[3]);\n+\n+static void quat2eul(float (&eul)[3], const float (&quat)[4]);\n+\n+static void calcvelNED(float (&velNED)[3], float gpsCourse, float gpsGndSpd, float gpsVelD);\n+\n+static void calcposNED(float (&posNED)[3], float lat, float lon, float hgt, float latRef, float lonRef, float hgtRef);\n+\n+static void calcLLH(float (&posNED)[3], float lat, float lon, float hgt, float latRef, float lonRef, float hgtRef);\n+\n+static void quat2Tnb(Mat3f &Tnb, const float (&quat)[4]);\n+\n+static float sq(float valIn);\n+\n+void OnGroundCheck();\n+\n+void CovarianceInit();\n+\n+void InitialiseFilter(float (&initvelNED)[3], double referenceLat, double referenceLon, float referenceHgt, float declination);\n+\n+float ConstrainFloat(float val, float min, float max);\n+\n+void ConstrainVariances();\n+\n+void ConstrainStates();\n+\n+void ForceSymmetry();\n+\n+int CheckAndBound();\n+\n+void ResetPosition();\n+\n+void ResetVelocity();\n+\n+void ZeroVariables();\n+\n+void GetFilterState(struct ekf_status_report *state);\n+\n+void GetLastErrorState(struct ekf_status_report *last_error);\n+\n+bool StatesNaN(struct ekf_status_report *err_report);\n+void FillErrorReport(struct ekf_status_report *err);\n+\n+void InitializeDynamic(float (&initvelNED)[3], float declination);\n+\n+protected:\n+\n+bool FilterHealthy();\n+\n+void ResetHeight(void);\n+\n+void AttitudeInit(float ax, float ay, float az, float mx, float my, float mz, float declination, float *initQuat);\n+\n+};\n+\n+uint32_t millis();\n+"},{"sha":"9622f7e4044159e0e8fbe09517d8cb8f1c0026b8","filename":"src/modules/ekf_att_pos_estimator/estimator_23states.cpp","status":"renamed","additions":289,"deletions":257,"changes":546,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_23states.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_23states.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_23states.cpp?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -1,151 +1,52 @@\n-#include \"estimator.h\"\n+#include \"estimator_23states.h\"\n #include <string.h>\n-#include <stdarg.h>\n-\n-// Define EKF_DEBUG here to enable the debug print calls\n-// if the macro is not set, these will be completely\n-// optimized out by the compiler.\n-//#define EKF_DEBUG\n-\n-#ifdef EKF_DEBUG\n #include <stdio.h>\n+#include <stdarg.h>\n \n-static void\n-ekf_debug_print(const char *fmt, va_list args)\n-{\n-    fprintf(stderr, \"%s: \", \"[ekf]\");\n-    vfprintf(stderr, fmt, args);\n-\n-    fprintf(stderr, \"\\n\");\n-}\n-\n-static void\n-ekf_debug(const char *fmt, ...)\n-{\n-    va_list args;\n-\n-    va_start(args, fmt);\n-    ekf_debug_print(fmt, args);\n-}\n-\n-#else\n-\n-static void ekf_debug(const char *fmt, ...) { while(0){} }\n-#endif\n-\n-float Vector3f::length(void) const\n-{\n-    return sqrt(x*x + y*y + z*z);\n-}\n-\n-void Vector3f::zero(void)\n-{\n-    x = 0.0f;\n-    y = 0.0f;\n-    z = 0.0f;\n-}\n-\n-Mat3f::Mat3f() {\n-    identity();\n-}\n-\n-void Mat3f::identity() {\n-    x.x = 1.0f;\n-    x.y = 0.0f;\n-    x.z = 0.0f;\n-\n-    y.x = 0.0f;\n-    y.y = 1.0f;\n-    y.z = 0.0f;\n-\n-    z.x = 0.0f;\n-    z.y = 0.0f;\n-    z.z = 1.0f;\n-}\n-\n-Mat3f Mat3f::transpose(void) const\n-{\n-    Mat3f ret = *this;\n-    swap_var(ret.x.y, ret.y.x);\n-    swap_var(ret.x.z, ret.z.x);\n-    swap_var(ret.y.z, ret.z.y);\n-    return ret;\n-}\n-\n-// overload + operator to provide a vector addition\n-Vector3f operator+( Vector3f vecIn1, Vector3f vecIn2)\n-{\n-    Vector3f vecOut;\n-    vecOut.x = vecIn1.x + vecIn2.x;\n-    vecOut.y = vecIn1.y + vecIn2.y;\n-    vecOut.z = vecIn1.z + vecIn2.z;\n-    return vecOut;\n-}\n-\n-// overload - operator to provide a vector subtraction\n-Vector3f operator-( Vector3f vecIn1, Vector3f vecIn2)\n-{\n-    Vector3f vecOut;\n-    vecOut.x = vecIn1.x - vecIn2.x;\n-    vecOut.y = vecIn1.y - vecIn2.y;\n-    vecOut.z = vecIn1.z - vecIn2.z;\n-    return vecOut;\n-}\n-\n-// overload * operator to provide a matrix vector product\n-Vector3f operator*( Mat3f matIn, Vector3f vecIn)\n-{\n-    Vector3f vecOut;\n-    vecOut.x = matIn.x.x*vecIn.x + matIn.x.y*vecIn.y + matIn.x.z*vecIn.z;\n-    vecOut.y = matIn.y.x*vecIn.x + matIn.y.y*vecIn.y + matIn.y.z*vecIn.z;\n-    vecOut.z = matIn.x.x*vecIn.x + matIn.z.y*vecIn.y + matIn.z.z*vecIn.z;\n-    return vecOut;\n-}\n-\n-// overload % operator to provide a vector cross product\n-Vector3f operator%( Vector3f vecIn1, Vector3f vecIn2)\n-{\n-    Vector3f vecOut;\n-    vecOut.x = vecIn1.y*vecIn2.z - vecIn1.z*vecIn2.y;\n-    vecOut.y = vecIn1.z*vecIn2.x - vecIn1.x*vecIn2.z;\n-    vecOut.z = vecIn1.x*vecIn2.y - vecIn1.y*vecIn2.x;\n-    return vecOut;\n-}\n-\n-// overload * operator to provide a vector scaler product\n-Vector3f operator*(Vector3f vecIn1, float sclIn1)\n-{\n-    Vector3f vecOut;\n-    vecOut.x = vecIn1.x * sclIn1;\n-    vecOut.y = vecIn1.y * sclIn1;\n-    vecOut.z = vecIn1.z * sclIn1;\n-    return vecOut;\n-}\n-\n-// overload * operator to provide a vector scaler product\n-Vector3f operator*(float sclIn1, Vector3f vecIn1)\n-{\n-    Vector3f vecOut;\n-    vecOut.x = vecIn1.x * sclIn1;\n-    vecOut.y = vecIn1.y * sclIn1;\n-    vecOut.z = vecIn1.z * sclIn1;\n-    return vecOut;\n-}\n-\n-void swap_var(float &d1, float &d2)\n-{\n-    float tmp = d1;\n-    d1 = d2;\n-    d2 = tmp;\n-}\n+#define EKF_COVARIANCE_DIVERGED 1.0e8f\n \n AttPosEKF::AttPosEKF()\n \n     /* NOTE: DO NOT initialize class members here. Use ZeroVariables()\n      * instead to allow clean in-air re-initialization.\n      */\n {\n+    summedDelAng.zero();\n+    summedDelVel.zero();\n+\n+    fusionModeGPS = 0;\n+    fuseVelData = false;\n+    fusePosData = false;\n+    fuseHgtData = false;\n+    fuseMagData = false;\n+    fuseVtasData = false;\n+    onGround = true;\n+    staticMode = true;\n+    useAirspeed = true;\n+    useCompass = true;\n+    useRangeFinder = true;\n+    numericalProtection = true;\n+    refSet = false;\n+    storeIndex = 0;\n+    gpsHgt = 0.0f;\n+    baroHgt = 0.0f;\n+    GPSstatus = 0;\n+    VtasMeas = 0.0f;\n+    magDeclination = 0.0f;\n+    dAngIMU.zero();\n+    dVelIMU.zero();\n+    velNED[0] = 0.0f;\n+    velNED[1] = 0.0f;\n+    velNED[2] = 0.0f;\n+    accelGPSNED[0] = 0.0f;\n+    accelGPSNED[1] = 0.0f;\n+    accelGPSNED[2] = 0.0f;\n+    delAngTotal.zero();\n+    ekfDiverged = false;\n+    lastReset = 0;\n \n+    memset(&last_ekf_error, 0, sizeof(last_ekf_error));\n+    memset(&current_ekf_state, 0, sizeof(current_ekf_state));\n     ZeroVariables();\n     InitialiseParameters();\n }\n@@ -181,6 +82,10 @@ void AttPosEKF::UpdateStrapdownEquationsNED()\n     dVelIMU.y = dVelIMU.y;\n     dVelIMU.z = dVelIMU.z - states[13];\n \n+    delAngTotal.x += correctedDelAng.x;\n+    delAngTotal.y += correctedDelAng.y;\n+    delAngTotal.z += correctedDelAng.z;\n+\n // Save current measurements\n     Vector3f  prevDelAng = correctedDelAng;\n \n@@ -199,8 +104,12 @@ void AttPosEKF::UpdateStrapdownEquationsNED()\n     }\n     else\n     {\n-        deltaQuat[0] = cosf(0.5f*rotationMag);\n-        float rotScaler = (sinf(0.5f*rotationMag))/rotationMag;\n+        // We are using double here as we are unsure how small\n+        // the angle differences are and if we get into numeric\n+        // issues with float. The runtime impact is not measurable\n+        // for these quantities.\n+        deltaQuat[0] = cos(0.5*(double)rotationMag);\n+        float rotScaler = (sin(0.5*(double)rotationMag))/(double)rotationMag;\n         deltaQuat[1] = correctedDelAng.x*rotScaler;\n         deltaQuat[2] = correctedDelAng.y*rotScaler;\n         deltaQuat[3] = correctedDelAng.z*rotScaler;\n@@ -312,7 +221,8 @@ void AttPosEKF::CovariancePrediction(float dt)\n     float nextP[n_states][n_states];\n \n     // calculate covariance prediction process noise\n-    for (uint8_t i= 0; i<=9;  i++) processNoise[i] = 1.0e-9f;\n+    for (uint8_t i= 0; i<4;  i++) processNoise[i] = 1.0e-9f;\n+    for (uint8_t i= 4; i<10;  i++) processNoise[i] = 1.0e-9f;\n     for (uint8_t i=10; i<=12; i++) processNoise[i] = dt * dAngBiasSigma;\n     // scale gyro bias noise when on ground to allow for faster bias estimation\n     for (uint8_t i=10; i<=12; i++) processNoise[i] = dt * dAngBiasSigma;\n@@ -977,20 +887,20 @@ void AttPosEKF::CovariancePrediction(float dt)\n         // propagate\n         for (unsigned i = 0; i <= 13; i++) {\n             P[i][i] = nextP[i][i];\n+        }\n \n-            // force symmetry for observable states\n-            // force zero for non-observable states\n-            for (unsigned i = 1; i < n_states; i++)\n+        // force symmetry for observable states\n+        // force zero for non-observable states\n+        for (unsigned i = 1; i < n_states; i++)\n+        {\n+            for (uint8_t j = 0; j < i; j++)\n             {\n-                for (uint8_t j = 0; j < i; j++)\n-                {\n-                    if ((i > 13) || (j > 13)) {\n-                        P[i][j] = 0.0f;\n-                    } else {\n-                        P[i][j] = 0.5f * (nextP[i][j] + nextP[j][i]);\n-                    }\n-                    P[j][i] = P[i][j];\n+                if ((i > 13) || (j > 13)) {\n+                    P[i][j] = 0.0f;\n+                } else {\n+                    P[i][j] = 0.5f * (nextP[i][j] + nextP[j][i]);\n                 }\n+                P[j][i] = P[i][j];\n             }\n         }\n \n@@ -1020,9 +930,9 @@ void AttPosEKF::FuseVelposNED()\n {\n \n // declare variables used by fault isolation logic\n-    uint32_t gpsRetryTime = 30000; // time in msec before GPS fusion will be retried following innovation consistency failure\n-    uint32_t gpsRetryTimeNoTAS = 5000; // retry time if no TAS measurement available\n-    uint32_t hgtRetryTime = 5000; // height measurement retry time\n+    uint32_t gpsRetryTime = 3000; // time in msec before GPS fusion will be retried following innovation consistency failure\n+    uint32_t gpsRetryTimeNoTAS = 500; // retry time if no TAS measurement available\n+    uint32_t hgtRetryTime = 500; // height measurement retry time\n     uint32_t horizRetryTime;\n \n // declare variables used to check measurement errors\n@@ -1178,7 +1088,7 @@ void AttPosEKF::FuseVelposNED()\n                 stateIndex = 4 + obsIndex;\n                 // Calculate the measurement innovation, using states from a\n                 // different time coordinate if fusing height data\n-                if (obsIndex >= 0 && obsIndex <= 2)\n+                if (obsIndex <= 2)\n                 {\n                     innovVelPos[obsIndex] = statesAtVelTime[stateIndex] - observation[obsIndex];\n                 }\n@@ -1193,7 +1103,7 @@ void AttPosEKF::FuseVelposNED()\n                 // Calculate the Kalman Gain\n                 // Calculate innovation variances - also used for data logging\n                 varInnovVelPos[obsIndex] = P[stateIndex][stateIndex] + R_OBS[obsIndex];\n-                SK = 1.0/varInnovVelPos[obsIndex];\n+                SK = 1.0/(double)varInnovVelPos[obsIndex];\n                 for (uint8_t i= 0; i<=indexLimit; i++)\n                 {\n                     Kfusion[i] = P[i][stateIndex]*SK;\n@@ -1277,7 +1187,7 @@ void AttPosEKF::FuseMagnetometer()\n // data fit is the only assumption we can make\n // so we might as well take advantage of the computational efficiencies\n // associated with sequential fusion\n-    if (useCompass && (fuseMagData || obsIndex == 1 || obsIndex == 2))\n+    if (useCompass && fuseMagData && (obsIndex < 3))\n     {\n         // Limit range of states modified when on ground\n         if(!onGround)\n@@ -1293,7 +1203,7 @@ void AttPosEKF::FuseMagnetometer()\n         // three prediction time steps.\n \n         // Calculate observation jacobians and Kalman gains\n-        if (fuseMagData)\n+        if (obsIndex == 0)\n         {\n             // Copy required states to local variable names\n             q0       = statesAtMagMeasTime[0];\n@@ -1388,11 +1298,6 @@ void AttPosEKF::FuseMagnetometer()\n             Kfusion[22] = SK_MX[0]*(P[22][19] + P[22][1]*SH_MAG[0] + P[22][3]*SH_MAG[2] + P[22][0]*SK_MX[3] - P[22][2]*SK_MX[2] - P[22][16]*SK_MX[1] + P[22][17]*SK_MX[5] - P[22][18]*SK_MX[4]);\n             varInnovMag[0] = 1.0f/SK_MX[0];\n             innovMag[0] = MagPred[0] - magData.x;\n-\n-            // reset the observation index to 0 (we start by fusing the X\n-            // measurement)\n-            obsIndex = 0;\n-            fuseMagData = false;\n         }\n         else if (obsIndex == 1) // we are now fusing the Y measurement\n         {\n@@ -1508,7 +1413,7 @@ void AttPosEKF::FuseMagnetometer()\n         }\n \n         // Check the innovation for consistency and don't fuse if > 5Sigma\n-        if ((innovMag[obsIndex]*innovMag[obsIndex]/varInnovMag[obsIndex]) < 25.0)\n+        if ((innovMag[obsIndex]*innovMag[obsIndex]/varInnovMag[obsIndex]) < 25.0f)\n         {\n             // correct the state vector\n             for (uint8_t j= 0; j < indexLimit; j++)\n@@ -1517,7 +1422,7 @@ void AttPosEKF::FuseMagnetometer()\n             }\n             // normalise the quaternion states\n             float quatMag = sqrt(states[0]*states[0] + states[1]*states[1] + states[2]*states[2] + states[3]*states[3]);\n-            if (quatMag > 1e-12)\n+            if (quatMag > 1e-12f)\n             {\n                 for (uint8_t j= 0; j<=3; j++)\n                 {\n@@ -1612,7 +1517,7 @@ void AttPosEKF::FuseAirspeed()\n         SH_TAS[0] = 1/(sqrt(sq(ve - vwe) + sq(vn - vwn) + sq(vd)));\n         SH_TAS[1] = (SH_TAS[0]*(2.0f*ve - 2*vwe))/2.0f;\n         SH_TAS[2] = (SH_TAS[0]*(2.0f*vn - 2*vwn))/2.0f;\n-        \n+\n         float H_TAS[n_states];\n         for (uint8_t i = 0; i < n_states; i++) H_TAS[i] = 0.0f;\n         H_TAS[4] = SH_TAS[2];\n@@ -1661,7 +1566,7 @@ void AttPosEKF::FuseAirspeed()\n         // Calculate the measurement innovation\n         innovVtas = VtasPred - VtasMeas;\n         // Check the innovation for consistency and don't fuse if > 5Sigma\n-        if ((innovVtas*innovVtas*SK_TAS) < 25.0)\n+        if ((innovVtas*innovVtas*SK_TAS) < 25.0f)\n         {\n             // correct the state vector\n             for (uint8_t j=0; j <= 22; j++)\n@@ -1758,7 +1663,7 @@ void AttPosEKF::FuseRangeFinder()\n \n     // Need to check that our range finder tilt angle is less than 30 degrees and we are using range finder data\n     SH_RNG[4] = sin(rngFinderPitch);\n-    cosRngTilt = - Tbn.z.x * SH_RNG[4] + Tbn.z.z * cos(rngFinderPitch);\n+    cosRngTilt = - Tbn.z.x * SH_RNG[4] + Tbn.z.z * cosf(rngFinderPitch);\n     if (useRangeFinder && cosRngTilt > 0.87f)\n     {\n         // Calculate observation jacobian and Kalman gain ignoring all states other than the terrain offset\n@@ -1855,21 +1760,21 @@ int AttPosEKF::RecallStates(float* statesForFusion, uint64_t msec)\n \n     int64_t bestTimeDelta = 200;\n     unsigned bestStoreIndex = 0;\n-    for (unsigned storeIndex = 0; storeIndex < data_buffer_size; storeIndex++)\n+    for (unsigned storeIndexLocal = 0; storeIndexLocal < data_buffer_size; storeIndexLocal++)\n     {\n         // Work around a GCC compiler bug - we know 64bit support on ARM is\n         // sketchy in GCC.\n         uint64_t timeDelta;\n \n-        if (msec > statetimeStamp[storeIndex]) {\n-            timeDelta = msec - statetimeStamp[storeIndex];\n+        if (msec > statetimeStamp[storeIndexLocal]) {\n+            timeDelta = msec - statetimeStamp[storeIndexLocal];\n         } else {\n-            timeDelta = statetimeStamp[storeIndex] - msec;\n+            timeDelta = statetimeStamp[storeIndexLocal] - msec;\n         }\n \n-        if (timeDelta < bestTimeDelta)\n+        if (timeDelta < (uint64_t)bestTimeDelta)\n         {\n-            bestStoreIndex = storeIndex;\n+            bestStoreIndex = storeIndexLocal;\n             bestTimeDelta = timeDelta;\n         }\n     }\n@@ -1926,7 +1831,7 @@ void AttPosEKF::quat2Tnb(Mat3f &Tnb, const float (&quat)[4])\n     Tnb.y.z = 2*(q23 + q01);\n }\n \n-void AttPosEKF::quat2Tbn(Mat3f &Tbn, const float (&quat)[4])\n+void AttPosEKF::quat2Tbn(Mat3f &Tbn_ret, const float (&quat)[4])\n {\n     // Calculate the body to nav cosine matrix\n     float q00 = sq(quat[0]);\n@@ -1940,15 +1845,15 @@ void AttPosEKF::quat2Tbn(Mat3f &Tbn, const float (&quat)[4])\n     float q13 =  quat[1]*quat[3];\n     float q23 =  quat[2]*quat[3];\n \n-    Tbn.x.x = q00 + q11 - q22 - q33;\n-    Tbn.y.y = q00 - q11 + q22 - q33;\n-    Tbn.z.z = q00 - q11 - q22 + q33;\n-    Tbn.x.y = 2*(q12 - q03);\n-    Tbn.x.z = 2*(q13 + q02);\n-    Tbn.y.x = 2*(q12 + q03);\n-    Tbn.y.z = 2*(q23 - q01);\n-    Tbn.z.x = 2*(q13 - q02);\n-    Tbn.z.y = 2*(q23 + q01);\n+    Tbn_ret.x.x = q00 + q11 - q22 - q33;\n+    Tbn_ret.y.y = q00 - q11 + q22 - q33;\n+    Tbn_ret.z.z = q00 - q11 - q22 + q33;\n+    Tbn_ret.x.y = 2*(q12 - q03);\n+    Tbn_ret.x.z = 2*(q13 + q02);\n+    Tbn_ret.y.x = 2*(q12 + q03);\n+    Tbn_ret.y.z = 2*(q23 - q01);\n+    Tbn_ret.z.x = 2*(q13 - q02);\n+    Tbn_ret.z.y = 2*(q23 + q01);\n }\n \n void AttPosEKF::eul2quat(float (&quat)[4], const float (&eul)[3])\n@@ -1979,17 +1884,17 @@ void AttPosEKF::calcvelNED(float (&velNED)[3], float gpsCourse, float gpsGndSpd,\n     velNED[2] = gpsVelD;\n }\n \n-void AttPosEKF::calcposNED(float (&posNED)[3], double lat, double lon, float hgt, double latRef, double lonRef, float hgtRef)\n+void AttPosEKF::calcposNED(float (&posNED)[3], double lat, double lon, float hgt, double latReference, double lonReference, float hgtReference)\n {\n-    posNED[0] = earthRadius * (lat - latRef);\n-    posNED[1] = earthRadius * cos(latRef) * (lon - lonRef);\n-    posNED[2] = -(hgt - hgtRef);\n+    posNED[0] = earthRadius * (lat - latReference);\n+    posNED[1] = earthRadius * cos(latReference) * (lon - lonReference);\n+    posNED[2] = -(hgt - hgtReference);\n }\n \n-void AttPosEKF::calcLLH(float posNED[3], float &lat, float &lon, float &hgt, float latRef, float lonRef, float hgtRef)\n+void AttPosEKF::calcLLH(float posNED[3], double &lat, double &lon, float &hgt, double latRef, double lonRef, float hgtRef)\n {\n-    lat = latRef + posNED[0] * earthRadiusInv;\n-    lon = lonRef + posNED[1] * earthRadiusInv / cos(latRef);\n+    lat = latRef + (double)posNED[0] * earthRadiusInv;\n+    lon = lonRef + (double)posNED[1] * earthRadiusInv / cos(latRef);\n     hgt = hgtRef - posNED[2];\n }\n \n@@ -2194,10 +2099,71 @@ void AttPosEKF::ForceSymmetry()\n         {\n             P[i][j] = 0.5f * (P[i][j] + P[j][i]);\n             P[j][i] = P[i][j];\n+\n+            if ((fabsf(P[i][j]) > EKF_COVARIANCE_DIVERGED) ||\n+                (fabsf(P[j][i]) > EKF_COVARIANCE_DIVERGED)) {\n+                current_ekf_state.covariancesExcessive = true;\n+                current_ekf_state.error |= true;\n+                InitializeDynamic(velNED, magDeclination);\n+                return;\n+            }\n+\n+            float symmetric = 0.5f * (P[i][j] + P[j][i]);\n+            P[i][j] = symmetric;\n+            P[j][i] = symmetric;\n         }\n     }\n }\n \n+bool AttPosEKF::GyroOffsetsDiverged()\n+{\n+    // Detect divergence by looking for rapid changes of the gyro offset\n+    Vector3f current_bias;\n+    current_bias.x = states[10];\n+    current_bias.y = states[11];\n+    current_bias.z = states[12];\n+\n+    Vector3f delta = current_bias - lastGyroOffset;\n+    float delta_len = delta.length();\n+    float delta_len_scaled = 0.0f;\n+\n+    // Protect against division by zero\n+    if (delta_len > 0.0f) {\n+        float cov_mag = ConstrainFloat((P[10][10] + P[11][11] + P[12][12]), 1e-12f, 1e-8f);\n+        delta_len_scaled = (5e-7 / (double)cov_mag) * (double)delta_len / (double)dtIMU;\n+    }\n+\n+    bool diverged = (delta_len_scaled > 1.0f);\n+    lastGyroOffset = current_bias;\n+    current_ekf_state.error |= diverged;\n+    current_ekf_state.gyroOffsetsExcessive = diverged;\n+\n+    return diverged;\n+}\n+\n+bool AttPosEKF::VelNEDDiverged()\n+{\n+    Vector3f current_vel;\n+    current_vel.x = states[4];\n+    current_vel.y = states[5];\n+    current_vel.z = states[6];\n+\n+    Vector3f gps_vel;\n+    gps_vel.x = velNED[0];\n+    gps_vel.y = velNED[1];\n+    gps_vel.z = velNED[2];\n+\n+    Vector3f delta = current_vel - gps_vel;\n+    float delta_len = delta.length();\n+\n+    bool excessive = (delta_len > 20.0f);\n+\n+    current_ekf_state.error |= excessive;\n+    current_ekf_state.velOffsetExcessive = excessive;\n+\n+    return excessive;\n+}\n+\n bool AttPosEKF::FilterHealthy()\n {\n     if (!statesInitialised) {\n@@ -2262,42 +2228,26 @@ void AttPosEKF::ResetVelocity(void)\n     }\n }\n \n-\n-void AttPosEKF::FillErrorReport(struct ekf_status_report *err)\n-{\n-    for (unsigned i = 0; i < n_states; i++)\n-    {\n-        err->states[i] = states[i];\n-    }\n-\n-    err->velHealth = current_ekf_state.velHealth;\n-    err->posHealth = current_ekf_state.posHealth;\n-    err->hgtHealth = current_ekf_state.hgtHealth;\n-    err->velTimeout = current_ekf_state.velTimeout;\n-    err->posTimeout = current_ekf_state.posTimeout;\n-    err->hgtTimeout = current_ekf_state.hgtTimeout;\n-}\n-\n-bool AttPosEKF::StatesNaN(struct ekf_status_report *err_report) {\n+bool AttPosEKF::StatesNaN() {\n     bool err = false;\n \n     // check all integrators\n     if (!isfinite(summedDelAng.x) || !isfinite(summedDelAng.y) || !isfinite(summedDelAng.z)) {\n-        err_report->statesNaN = true;\n+        current_ekf_state.angNaN = true;\n         ekf_debug(\"summedDelAng NaN: x: %f y: %f z: %f\", (double)summedDelAng.x, (double)summedDelAng.y, (double)summedDelAng.z);\n         err = true;\n         goto out;\n     } // delta angles\n \n     if (!isfinite(correctedDelAng.x) || !isfinite(correctedDelAng.y) || !isfinite(correctedDelAng.z)) {\n-        err_report->statesNaN = true;\n+        current_ekf_state.angNaN = true;\n         ekf_debug(\"correctedDelAng NaN: x: %f y: %f z: %f\", (double)correctedDelAng.x, (double)correctedDelAng.y, (double)correctedDelAng.z);\n         err = true;\n         goto out;\n     } // delta angles\n \n     if (!isfinite(summedDelVel.x) || !isfinite(summedDelVel.y) || !isfinite(summedDelVel.z)) {\n-        err_report->statesNaN = true;\n+        current_ekf_state.summedDelVelNaN = true;\n         ekf_debug(\"summedDelVel NaN: x: %f y: %f z: %f\", (double)summedDelVel.x, (double)summedDelVel.y, (double)summedDelVel.z);\n         err = true;\n         goto out;\n@@ -2308,39 +2258,39 @@ bool AttPosEKF::StatesNaN(struct ekf_status_report *err_report) {\n         for (unsigned j = 0; j < n_states; j++) {\n             if (!isfinite(KH[i][j])) {\n \n-                err_report->covarianceNaN = true;\n+                current_ekf_state.KHNaN = true;\n                 err = true;\n                 ekf_debug(\"KH NaN\");\n                 goto out;\n             } //  intermediate result used for covariance updates\n \n             if (!isfinite(KHP[i][j])) {\n \n-                err_report->covarianceNaN = true;\n+                current_ekf_state.KHPNaN = true;\n                 err = true;\n                 ekf_debug(\"KHP NaN\");\n                 goto out;\n             } // intermediate result used for covariance updates\n \n             if (!isfinite(P[i][j])) {\n \n-                err_report->covarianceNaN = true;\n+                current_ekf_state.covarianceNaN = true;\n                 err = true;\n                 ekf_debug(\"P NaN\");\n             } // covariance matrix\n         }\n \n         if (!isfinite(Kfusion[i])) {\n \n-            err_report->kalmanGainsNaN = true;\n+            current_ekf_state.kalmanGainsNaN = true;\n             ekf_debug(\"Kfusion NaN\");\n             err = true;\n             goto out;\n         } // Kalman gains\n \n         if (!isfinite(states[i])) {\n \n-            err_report->statesNaN = true;\n+            current_ekf_state.statesNaN = true;\n             ekf_debug(\"states NaN: i: %u val: %f\", i, (double)states[i]);\n             err = true;\n             goto out;\n@@ -2349,7 +2299,7 @@ bool AttPosEKF::StatesNaN(struct ekf_status_report *err_report) {\n \n out:\n     if (err) {\n-        FillErrorReport(err_report);\n+        current_ekf_state.error |= true;\n     }\n \n     return err;\n@@ -2365,47 +2315,105 @@ bool AttPosEKF::StatesNaN(struct ekf_status_report *err_report) {\n  * updated, but before any of the fusion steps are\n  * executed.\n  */\n-int AttPosEKF::CheckAndBound()\n+int AttPosEKF::CheckAndBound(struct ekf_status_report *last_error)\n {\n \n     // Store the old filter state\n     bool currStaticMode = staticMode;\n \n+    // Limit reset rate to 5 Hz to allow the filter\n+    // to settle\n+    if (millis() - lastReset < 200) {\n+        return 0;\n+    }\n+\n+    if (ekfDiverged) {\n+        ekfDiverged = false;\n+    }\n+\n+    int ret = 0;\n+\n+    // Check if we're on ground - this also sets static mode.\n+    OnGroundCheck();\n+\n     // Reset the filter if the states went NaN\n-    if (StatesNaN(&last_ekf_error)) {\n+    if (StatesNaN()) {\n         ekf_debug(\"re-initializing dynamic\");\n \n-        InitializeDynamic(velNED, magDeclination);\n+        // Reset and fill error report\n+\t    InitializeDynamic(velNED, magDeclination);\n \n-        return 1;\n+        ret = 1;\n     }\n \n     // Reset the filter if the IMU data is too old\n     if (dtIMU > 0.3f) {\n \n+        current_ekf_state.imuTimeout = true;\n+\n+        // Fill error report\n+        GetFilterState(&last_ekf_error);\n+\n         ResetVelocity();\n         ResetPosition();\n         ResetHeight();\n         ResetStoredStates();\n \n+        // Timeout cleared with this reset\n+        current_ekf_state.imuTimeout = false;\n+\n         // that's all we can do here, return\n-        return 2;\n+        ret = 2;\n     }\n \n-    // Check if we're on ground - this also sets static mode.\n-    OnGroundCheck();\n-\n     // Check if we switched between states\n     if (currStaticMode != staticMode) {\n+        // Fill error report, but not setting error flag\n+        GetFilterState(&last_ekf_error);\n+\n         ResetVelocity();\n         ResetPosition();\n         ResetHeight();\n         ResetStoredStates();\n \n-        return 3;\n+        ret = 3;\n+    }\n+\n+    // Reset the filter if gyro offsets are excessive\n+    if (GyroOffsetsDiverged()) {\n+\n+        // Reset and fill error report\n+        InitializeDynamic(velNED, magDeclination);\n+\n+        // that's all we can do here, return\n+        ret = 4;\n+    }\n+\n+    // Reset the filter if it diverges too far from GPS\n+    if (VelNEDDiverged()) {\n+\n+        // Reset and fill error report\n+        InitializeDynamic(velNED, magDeclination);\n+\n+        // that's all we can do here, return\n+        ret = 5;\n+    }\n+\n+    // The excessive covariance detection already\n+    // reset the filter. Just need to report here.\n+    if (last_ekf_error.covariancesExcessive) {\n+        ret = 6;\n+    }\n+\n+    if (ret) {\n+        ekfDiverged = true;\n+        lastReset = millis();\n+\n+        // This reads the last error and clears it\n+        GetLastErrorState(last_error);\n     }\n \n-    return 0;\n+    return ret;\n }\n \n void AttPosEKF::AttitudeInit(float ax, float ay, float az, float mx, float my, float mz, float declination, float *initQuat)\n@@ -2456,6 +2464,30 @@ void AttPosEKF::AttitudeInit(float ax, float ay, float az, float mx, float my, f\n \n void AttPosEKF::InitializeDynamic(float (&initvelNED)[3], float declination)\n {\n+    if (current_ekf_state.error) {\n+        GetFilterState(&last_ekf_error);\n+    }\n+\n+    ZeroVariables();\n+\n+    // Reset error states\n+    current_ekf_state.error = false;\n+    current_ekf_state.angNaN = false;\n+    current_ekf_state.summedDelVelNaN = false;\n+    current_ekf_state.KHNaN = false;\n+    current_ekf_state.KHPNaN = false;\n+    current_ekf_state.PNaN = false;\n+    current_ekf_state.covarianceNaN = false;\n+    current_ekf_state.kalmanGainsNaN = false;\n+    current_ekf_state.statesNaN = false;\n+\n+    current_ekf_state.velHealth = true;\n+    //current_ekf_state.posHealth = ?;\n+    //current_ekf_state.hgtHealth = ?;\n+    \n+    current_ekf_state.velTimeout = false;\n+    //current_ekf_state.posTimeout = ?;\n+    //current_ekf_state.hgtTimeout = ?;\n \n     // Fill variables with valid data\n     velNED[0] = initvelNED[0];\n@@ -2494,7 +2526,11 @@ void AttPosEKF::InitializeDynamic(float (&initvelNED)[3], float declination)\n     // write to state vector\n     for (uint8_t j=0; j<=3; j++) states[j] = initQuat[j]; // quaternions\n     for (uint8_t j=4; j<=6; j++) states[j] = initvelNED[j-4]; // velocities\n-    for (uint8_t j=7; j<=15; j++) states[j] = 0.0f; // positions, dAngBias, dVelBias, windVel\n+    // positions:\n+    states[7] = posNE[0];\n+    states[8] = posNE[1];\n+    states[9] = -hgtMea;\n+    for (uint8_t j=10; j<=15; j++) states[j] = 0.0f; // dAngBias, dVelBias, windVel\n     states[16] = initMagNED.x; // Magnetic Field North\n     states[17] = initMagNED.y; // Magnetic Field East\n     states[18] = initMagNED.z; // Magnetic Field Down\n@@ -2525,42 +2561,25 @@ void AttPosEKF::InitialiseFilter(float (&initvelNED)[3], double referenceLat, do\n     hgtRef = referenceHgt;\n     refSet = true;\n \n-    // we are at reference altitude, so measurement must be zero\n-    hgtMea = 0.0f;\n+    // we are at reference position, so measurement must be zero\n+    posNE[0] = 0.0f;\n+    posNE[1] = 0.0f;\n+\n+    // we are at an unknown, possibly non-zero altitude - so altitude\n+    // is not reset (hgtMea)\n \n     // the baro offset must be this difference now\n     baroHgtOffset = baroHgt - referenceHgt;\n \n-    memset(&last_ekf_error, 0, sizeof(last_ekf_error));\n-\n     InitializeDynamic(initvelNED, declination);\n }\n \n void AttPosEKF::ZeroVariables()\n {\n \n     // Initialize on-init initialized variables\n-    fusionModeGPS = 0;\n-    covSkipCount = 0;\n-    statesInitialised = false;\n-    fuseVelData = false;\n-    fusePosData = false;\n-    fuseHgtData = false;\n-    fuseMagData = false;\n-    fuseVtasData = false;\n-    onGround = true;\n-    staticMode = true;\n-    useAirspeed = true;\n-    useCompass = true;\n-    useRangeFinder = true;\n-    numericalProtection = true;\n-    refSet = false;\n+\n     storeIndex = 0;\n-    gpsHgt = 0.0f;\n-    baroHgt = 0.0f;\n-    GPSstatus = 0;\n-    VtasMeas = 0.0f;\n-    magDeclination = 0.0f;\n \n     // Do the data structure init\n     for (unsigned i = 0; i < n_states; i++) {\n@@ -2577,9 +2596,7 @@ void AttPosEKF::ZeroVariables()\n     correctedDelAng.zero();\n     summedDelAng.zero();\n     summedDelVel.zero();\n-\n-    dAngIMU.zero();\n-    dVelIMU.zero();\n+    lastGyroOffset.zero();\n \n     for (unsigned i = 0; i < data_buffer_size; i++) {\n \n@@ -2598,12 +2615,27 @@ void AttPosEKF::ZeroVariables()\n \n }\n \n-void AttPosEKF::GetFilterState(struct ekf_status_report *state)\n+void AttPosEKF::GetFilterState(struct ekf_status_report *err)\n {\n-    memcpy(state, &current_ekf_state, sizeof(*state));\n+\n+    // Copy states\n+    for (unsigned i = 0; i < n_states; i++) {\n+        current_ekf_state.states[i] = states[i];\n+    }\n+    current_ekf_state.n_states = n_states;\n+\n+    memcpy(err, &current_ekf_state, sizeof(*err));\n+\n+    // err->velHealth = current_ekf_state.velHealth;\n+    // err->posHealth = current_ekf_state.posHealth;\n+    // err->hgtHealth = current_ekf_state.hgtHealth;\n+    // err->velTimeout = current_ekf_state.velTimeout;\n+    // err->posTimeout = current_ekf_state.posTimeout;\n+    // err->hgtTimeout = current_ekf_state.hgtTimeout;\n }\n \n void AttPosEKF::GetLastErrorState(struct ekf_status_report *last_error)\n {\n     memcpy(last_error, &last_ekf_error, sizeof(*last_error));\n+    memset(&last_ekf_error, 0, sizeof(last_ekf_error));\n }","previous_filename":"src/modules/ekf_att_pos_estimator/estimator.cpp"},{"sha":"7aad849f972043c8b6fba16d2a6f2152df76ed61","filename":"src/modules/ekf_att_pos_estimator/estimator_23states.h","status":"renamed","additions":23,"deletions":75,"changes":98,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_23states.h","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_23states.h","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_23states.h?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -1,76 +1,10 @@\n-#include <math.h>\n-#include <stdint.h>\n-\n #pragma once\n \n-#define GRAVITY_MSS 9.80665f\n-#define deg2rad 0.017453292f\n-#define rad2deg 57.295780f\n-#define pi 3.141592657f\n-#define earthRate 0.000072921f\n-#define earthRadius 6378145.0f\n-#define earthRadiusInv  1.5678540e-7f\n-\n-class Vector3f\n-{\n-private:\n-public:\n-    float x;\n-    float y;\n-    float z;\n-\n-    float length(void) const;\n-    void zero(void);\n-};\n-\n-class Mat3f\n-{\n-private:\n-public:\n-    Vector3f x;\n-    Vector3f y;\n-    Vector3f z;\n-\n-    Mat3f();\n-\n-    void identity();\n-    Mat3f transpose(void) const;\n-};\n-\n-Vector3f operator*(float sclIn1, Vector3f vecIn1);\n-Vector3f operator+( Vector3f vecIn1, Vector3f vecIn2);\n-Vector3f operator-( Vector3f vecIn1, Vector3f vecIn2);\n-Vector3f operator*( Mat3f matIn, Vector3f vecIn);\n-Vector3f operator%( Vector3f vecIn1, Vector3f vecIn2);\n-Vector3f operator*(Vector3f vecIn1, float sclIn1);\n-\n-void swap_var(float &d1, float &d2);\n+#include \"estimator_utilities.h\"\n \n const unsigned int n_states = 23;\n const unsigned int data_buffer_size = 50;\n \n-enum GPS_FIX {\n-    GPS_FIX_NOFIX = 0,\n-    GPS_FIX_2D = 2,\n-    GPS_FIX_3D = 3\n-};\n-\n-struct ekf_status_report {\n-    bool velHealth;\n-    bool posHealth;\n-    bool hgtHealth;\n-    bool velTimeout;\n-    bool posTimeout;\n-    bool hgtTimeout;\n-    uint32_t velFailTime;\n-    uint32_t posFailTime;\n-    uint32_t hgtFailTime;\n-    float states[n_states];\n-    bool statesNaN;\n-    bool covarianceNaN;\n-    bool kalmanGainsNaN;\n-};\n-\n class AttPosEKF {\n \n public:\n@@ -141,7 +75,7 @@ class AttPosEKF {\n         accelProcessNoise = 0.5f;\n     }\n \n-    struct {\n+    struct mag_state_struct {\n         unsigned obsIndex;\n         float MagPred[3];\n         float SH_MAG[9];\n@@ -157,7 +91,12 @@ class AttPosEKF {\n         float magZbias;\n         float R_MAG;\n         Mat3f DCM;\n-    } magstate;\n+    };\n+\n+    struct mag_state_struct magstate;\n+    struct mag_state_struct resetMagState;\n+\n+\n \n \n     // Global variables\n@@ -166,6 +105,7 @@ class AttPosEKF {\n     float P[n_states][n_states]; // covariance matrix\n     float Kfusion[n_states]; // Kalman gains\n     float states[n_states]; // state matrix\n+    float resetStates[n_states];\n     float storedStates[n_states][data_buffer_size]; // state vectors stored for the last 50 time steps\n     uint32_t statetimeStamp[data_buffer_size]; // time stamp for each state vector stored\n \n@@ -183,6 +123,8 @@ class AttPosEKF {\n     float accNavMag; // magnitude of navigation accel (- used to adjust GPS obs variance (m/s^2)\n     Vector3f earthRateNED; // earths angular rate vector in NED (rad/s)\n     Vector3f angRate; // angular rate vector in XYZ body axes measured by the IMU (rad/s)\n+    Vector3f lastGyroOffset;    // Last gyro offset\n+    Vector3f delAngTotal;\n \n     Mat3f Tbn; // transformation matrix from body to NED coordinates\n     Mat3f Tnb; // transformation amtrix from NED to body coordinates\n@@ -196,11 +138,11 @@ class AttPosEKF {\n     float varInnovVelPos[6]; // innovation variance output\n \n     float velNED[3]; // North, East, Down velocity obs (m/s)\n+    float accelGPSNED[3];   // Acceleration predicted by GPS in earth frame\n     float posNE[2]; // North, East position obs (m)\n     float hgtMea; //  measured height (m)\n     float baroHgtOffset;        ///< the baro (weather) offset from normalized altitude\n     float rngMea; // Ground distance\n-    float posNED[3]; // North, East Down position (m)\n \n     float innovMag[3]; // innovation output\n     float varInnovMag[3]; // innovation variance output\n@@ -243,6 +185,9 @@ class AttPosEKF {\n     bool useCompass;    ///< boolean true if magnetometer data is being used\n     bool useRangeFinder;     ///< true when rangefinder is being used\n \n+    bool ekfDiverged;\n+    uint64_t lastReset;\n+\n     struct ekf_status_report current_ekf_state;\n     struct ekf_status_report last_ekf_error;\n \n@@ -299,9 +244,9 @@ static void quat2eul(float (&eul)[3], const float (&quat)[4]);\n \n static void calcvelNED(float (&velNED)[3], float gpsCourse, float gpsGndSpd, float gpsVelD);\n \n-static void calcposNED(float (&posNED)[3], double lat, double lon, float hgt, double latRef, double lonRef, float hgtRef);\n+void calcposNED(float (&posNED)[3], double lat, double lon, float hgt, double latRef, double lonRef, float hgtRef);\n \n-static void calcLLH(float posNED[3], float &lat, float &lon, float &hgt, float latRef, float lonRef, float hgtRef);\n+static void calcLLH(float posNED[3], double &lat, double &lon, float &hgt, double latRef, double lonRef, float hgtRef);\n \n static void quat2Tnb(Mat3f &Tnb, const float (&quat)[4]);\n \n@@ -321,7 +266,7 @@ void ConstrainStates();\n \n void ForceSymmetry();\n \n-int CheckAndBound();\n+int CheckAndBound(struct ekf_status_report *last_error);\n \n void ResetPosition();\n \n@@ -333,15 +278,18 @@ void GetFilterState(struct ekf_status_report *state);\n \n void GetLastErrorState(struct ekf_status_report *last_error);\n \n-bool StatesNaN(struct ekf_status_report *err_report);\n-void FillErrorReport(struct ekf_status_report *err);\n+bool StatesNaN();\n \n void InitializeDynamic(float (&initvelNED)[3], float declination);\n \n protected:\n \n bool FilterHealthy();\n \n+bool GyroOffsetsDiverged();\n+\n+bool VelNEDDiverged();\n+\n void ResetHeight(void);\n \n void AttitudeInit(float ax, float ay, float az, float mx, float my, float mz, float declination, float *initQuat);","previous_filename":"src/modules/ekf_att_pos_estimator/estimator.h"},{"sha":"b4767a0d341ee62d72b4776179501571e5d18a7e","filename":"src/modules/ekf_att_pos_estimator/estimator_utilities.cpp","status":"added","additions":139,"deletions":0,"changes":139,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_utilities.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_utilities.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_utilities.cpp?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -0,0 +1,139 @@\n+\n+#include \"estimator_utilities.h\"\n+\n+// Define EKF_DEBUG here to enable the debug print calls\n+// if the macro is not set, these will be completely\n+// optimized out by the compiler.\n+//#define EKF_DEBUG\n+\n+#ifdef EKF_DEBUG\n+#include <stdio.h>\n+\n+static void\n+ekf_debug_print(const char *fmt, va_list args)\n+{\n+    fprintf(stderr, \"%s: \", \"[ekf]\");\n+    vfprintf(stderr, fmt, args);\n+\n+    fprintf(stderr, \"\\n\");\n+}\n+\n+void\n+ekf_debug(const char *fmt, ...)\n+{\n+    va_list args;\n+\n+    va_start(args, fmt);\n+    ekf_debug_print(fmt, args);\n+}\n+\n+#else\n+\n+void ekf_debug(const char *fmt, ...) { while(0){} }\n+#endif\n+\n+float Vector3f::length(void) const\n+{\n+    return sqrt(x*x + y*y + z*z);\n+}\n+\n+void Vector3f::zero(void)\n+{\n+    x = 0.0f;\n+    y = 0.0f;\n+    z = 0.0f;\n+}\n+\n+Mat3f::Mat3f() {\n+    identity();\n+}\n+\n+void Mat3f::identity() {\n+    x.x = 1.0f;\n+    x.y = 0.0f;\n+    x.z = 0.0f;\n+\n+    y.x = 0.0f;\n+    y.y = 1.0f;\n+    y.z = 0.0f;\n+\n+    z.x = 0.0f;\n+    z.y = 0.0f;\n+    z.z = 1.0f;\n+}\n+\n+Mat3f Mat3f::transpose(void) const\n+{\n+    Mat3f ret = *this;\n+    swap_var(ret.x.y, ret.y.x);\n+    swap_var(ret.x.z, ret.z.x);\n+    swap_var(ret.y.z, ret.z.y);\n+    return ret;\n+}\n+\n+// overload + operator to provide a vector addition\n+Vector3f operator+( Vector3f vecIn1, Vector3f vecIn2)\n+{\n+    Vector3f vecOut;\n+    vecOut.x = vecIn1.x + vecIn2.x;\n+    vecOut.y = vecIn1.y + vecIn2.y;\n+    vecOut.z = vecIn1.z + vecIn2.z;\n+    return vecOut;\n+}\n+\n+// overload - operator to provide a vector subtraction\n+Vector3f operator-( Vector3f vecIn1, Vector3f vecIn2)\n+{\n+    Vector3f vecOut;\n+    vecOut.x = vecIn1.x - vecIn2.x;\n+    vecOut.y = vecIn1.y - vecIn2.y;\n+    vecOut.z = vecIn1.z - vecIn2.z;\n+    return vecOut;\n+}\n+\n+// overload * operator to provide a matrix vector product\n+Vector3f operator*( Mat3f matIn, Vector3f vecIn)\n+{\n+    Vector3f vecOut;\n+    vecOut.x = matIn.x.x*vecIn.x + matIn.x.y*vecIn.y + matIn.x.z*vecIn.z;\n+    vecOut.y = matIn.y.x*vecIn.x + matIn.y.y*vecIn.y + matIn.y.z*vecIn.z;\n+    vecOut.z = matIn.x.x*vecIn.x + matIn.z.y*vecIn.y + matIn.z.z*vecIn.z;\n+    return vecOut;\n+}\n+\n+// overload % operator to provide a vector cross product\n+Vector3f operator%( Vector3f vecIn1, Vector3f vecIn2)\n+{\n+    Vector3f vecOut;\n+    vecOut.x = vecIn1.y*vecIn2.z - vecIn1.z*vecIn2.y;\n+    vecOut.y = vecIn1.z*vecIn2.x - vecIn1.x*vecIn2.z;\n+    vecOut.z = vecIn1.x*vecIn2.y - vecIn1.y*vecIn2.x;\n+    return vecOut;\n+}\n+\n+// overload * operator to provide a vector scaler product\n+Vector3f operator*(Vector3f vecIn1, float sclIn1)\n+{\n+    Vector3f vecOut;\n+    vecOut.x = vecIn1.x * sclIn1;\n+    vecOut.y = vecIn1.y * sclIn1;\n+    vecOut.z = vecIn1.z * sclIn1;\n+    return vecOut;\n+}\n+\n+// overload * operator to provide a vector scaler product\n+Vector3f operator*(float sclIn1, Vector3f vecIn1)\n+{\n+    Vector3f vecOut;\n+    vecOut.x = vecIn1.x * sclIn1;\n+    vecOut.y = vecIn1.y * sclIn1;\n+    vecOut.z = vecIn1.z * sclIn1;\n+    return vecOut;\n+}\n+\n+void swap_var(float &d1, float &d2)\n+{\n+    float tmp = d1;\n+    d1 = d2;\n+    d2 = tmp;\n+}"},{"sha":"d47568b62c2fb7f702dec16b76fdbc10a7350499","filename":"src/modules/ekf_att_pos_estimator/estimator_utilities.h","status":"added","additions":82,"deletions":0,"changes":82,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_utilities.h","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_utilities.h","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fekf_att_pos_estimator%2Festimator_utilities.h?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -0,0 +1,82 @@\n+#include <math.h>\n+#include <stdint.h>\n+\n+#pragma once\n+\n+#define GRAVITY_MSS 9.80665f\n+#define deg2rad 0.017453292f\n+#define rad2deg 57.295780f\n+#define pi 3.141592657f\n+#define earthRate 0.000072921f\n+#define earthRadius 6378145.0\n+#define earthRadiusInv  1.5678540e-7\n+\n+class Vector3f\n+{\n+private:\n+public:\n+    float x;\n+    float y;\n+    float z;\n+\n+    float length(void) const;\n+    void zero(void);\n+};\n+\n+class Mat3f\n+{\n+private:\n+public:\n+    Vector3f x;\n+    Vector3f y;\n+    Vector3f z;\n+\n+    Mat3f();\n+\n+    void identity();\n+    Mat3f transpose(void) const;\n+};\n+\n+Vector3f operator*(float sclIn1, Vector3f vecIn1);\n+Vector3f operator+( Vector3f vecIn1, Vector3f vecIn2);\n+Vector3f operator-( Vector3f vecIn1, Vector3f vecIn2);\n+Vector3f operator*( Mat3f matIn, Vector3f vecIn);\n+Vector3f operator%( Vector3f vecIn1, Vector3f vecIn2);\n+Vector3f operator*(Vector3f vecIn1, float sclIn1);\n+\n+void swap_var(float &d1, float &d2);\n+\n+enum GPS_FIX {\n+    GPS_FIX_NOFIX = 0,\n+    GPS_FIX_2D = 2,\n+    GPS_FIX_3D = 3\n+};\n+\n+struct ekf_status_report {\n+    bool error;\n+    bool velHealth;\n+    bool posHealth;\n+    bool hgtHealth;\n+    bool velTimeout;\n+    bool posTimeout;\n+    bool hgtTimeout;\n+    bool imuTimeout;\n+    uint32_t velFailTime;\n+    uint32_t posFailTime;\n+    uint32_t hgtFailTime;\n+    float states[32];\n+    unsigned n_states;\n+    bool angNaN;\n+    bool summedDelVelNaN;\n+    bool KHNaN;\n+    bool KHPNaN;\n+    bool PNaN;\n+    bool covarianceNaN;\n+    bool kalmanGainsNaN;\n+    bool statesNaN;\n+    bool gyroOffsetsExcessive;\n+    bool covariancesExcessive;\n+    bool velOffsetExcessive;\n+};\n+\n+void ekf_debug(const char *fmt, ...);\n\\ No newline at end of file"},{"sha":"dc5220bf0cadc890f67b21964c2c0027f34d0635","filename":"src/modules/ekf_att_pos_estimator/module.mk","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Fmodule.mk","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fekf_att_pos_estimator%2Fmodule.mk","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fekf_att_pos_estimator%2Fmodule.mk?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -39,4 +39,5 @@ MODULE_COMMAND\t= ekf_att_pos_estimator\n \n SRCS\t\t= ekf_att_pos_estimator_main.cpp \\\n \t\t  ekf_att_pos_estimator_params.c \\\n-\t\t  estimator.cpp\n+\t\t  estimator_23states.cpp \\\n+\t\t  estimator_utilities.cpp"},{"sha":"9a5e31ef479baefb32534c7a58089d0061b0fd4e","filename":"src/modules/mavlink/mavlink_main.cpp","status":"modified","additions":24,"deletions":6,"changes":30,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fmavlink%2Fmavlink_main.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fmavlink%2Fmavlink_main.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fmavlink%2Fmavlink_main.cpp?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -197,13 +197,14 @@ mavlink_send_uart_bytes(mavlink_channel_t channel, const uint8_t *ch, int length\n \n \t\t\tif (buf_free < desired) {\n \t\t\t\t/* we don't want to send anything just in half, so return */\n+\t\t\t\tinstance->count_txerr();\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tssize_t ret = write(uart, ch, desired);\n \t\tif (ret != desired) {\n-\t\t\t// XXX overflow perf\n+\t\t\tinstance->count_txerr();\n \t\t} else {\n \t\t\tlast_write_success_times[(unsigned)channel] = last_write_try_times[(unsigned)channel];\n \t\t}\n@@ -249,7 +250,8 @@ Mavlink::Mavlink() :\n \t_param_use_hil_gps(0),\n \n /* performance counters */\n-\t_loop_perf(perf_alloc(PC_ELAPSED, \"mavlink\"))\n+\t_loop_perf(perf_alloc(PC_ELAPSED, \"mavlink_el\")),\n+\t_txerr_perf(perf_alloc(PC_COUNT, \"mavlink_txe\"))\n {\n \t_wpm = &_wpm_s;\n \tmission.count = 0;\n@@ -302,6 +304,7 @@ Mavlink::Mavlink() :\n Mavlink::~Mavlink()\n {\n \tperf_free(_loop_perf);\n+\tperf_free(_txerr_perf);\n \n \tif (_task_running) {\n \t\t/* task wakes up every 10ms or so at the longest */\n@@ -326,6 +329,12 @@ Mavlink::~Mavlink()\n \tLL_DELETE(_mavlink_instances, this);\n }\n \n+void\n+Mavlink::count_txerr()\n+{\n+\tperf_count(_txerr_perf);\n+}\n+\n void\n Mavlink::set_mode(enum MAVLINK_MODE mode)\n {\n@@ -2193,11 +2202,20 @@ int Mavlink::start_helper(int argc, char *argv[])\n \t/* create the instance in task context */\n \tMavlink *instance = new Mavlink();\n \n-\t/* this will actually only return once MAVLink exits */\n-\tint res = instance->task_main(argc, argv);\n+\tint res;\n \n-\t/* delete instance on main thread end */\n-\tdelete instance;\n+\tif (!instance) {\n+\n+\t\t/* out of memory */\n+\t\tres = -ENOMEM;\n+\t\twarnx(\"OUT OF MEM\");\n+\t} else {\n+\t\t/* this will actually only return once MAVLink exits */\n+\t\tres = instance->task_main(argc, argv);\n+\n+\t\t/* delete instance on main thread end */\n+\t\tdelete instance;\n+\t}\n \n \treturn res;\n }"},{"sha":"6777d56c396d4908a44c2d0caedb9cc42499ff9a","filename":"src/modules/mavlink/mavlink_main.h","status":"modified","additions":10,"deletions":1,"changes":11,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fmavlink%2Fmavlink_main.h","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fmavlink%2Fmavlink_main.h","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fmavlink%2Fmavlink_main.h?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -215,10 +215,14 @@ class Mavlink\n \n \tconst mavlink_channel_t\tget_channel();\n \n+\tvoid configure_stream_threadsafe(const char *stream_name, const float rate);\n+\n \tbool\t\t\t_task_should_exit;\t/**< if true, mavlink task should exit */\n \n \tint\t\t\tget_mavlink_fd() { return _mavlink_fd; }\n \n+\tMavlinkStream * get_streams() { return _streams; } const\n+\n \n \t/* Functions for waiting to start transmission until message received. */\n \tvoid\t\t\tset_has_received_messages(bool received_messages) { _received_messages = received_messages; }\n@@ -232,6 +236,11 @@ class Mavlink\n     void lockMessageBufferMutex(void) { pthread_mutex_lock(&_message_buffer_mutex); }\n     void unlockMessageBufferMutex(void) { pthread_mutex_unlock(&_message_buffer_mutex); }\n \n+\t/**\n+\t * Count a transmision error\n+\t */\n+\tvoid count_txerr();\n+\n protected:\n \tMavlink\t\t\t*next;\n \n@@ -303,6 +312,7 @@ class Mavlink\n \tpthread_mutex_t\t\t_message_buffer_mutex;\n \n \tperf_counter_t\t\t_loop_perf;\t\t\t/**< loop performance counter */\n+\tperf_counter_t\t\t_txerr_perf;\t\t\t/**< TX error counter */\n \n \tbool\t\t\t_param_initialized;\n \tparam_t\t\t\t_param_system_id;\n@@ -371,7 +381,6 @@ class Mavlink\n \tint mavlink_open_uart(int baudrate, const char *uart_name, struct termios *uart_config_original, bool *is_usb);\n \n \tint configure_stream(const char *stream_name, const float rate);\n-\tvoid configure_stream_threadsafe(const char *stream_name, const float rate);\n \n \tint message_buffer_init(int size);\n "},{"sha":"e1ebc16ccdac4d3e0dddd160ccc0a8cc9095e91d","filename":"src/modules/mavlink/mavlink_messages.cpp","status":"modified","additions":120,"deletions":0,"changes":120,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fmavlink%2Fmavlink_messages.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fmavlink%2Fmavlink_messages.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fmavlink%2Fmavlink_messages.cpp?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -232,6 +232,11 @@ class MavlinkStreamHeartbeat : public MavlinkStream\n \t\treturn \"HEARTBEAT\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_HEARTBEAT;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamHeartbeat();\n@@ -292,6 +297,11 @@ class MavlinkStreamSysStatus : public MavlinkStream\n \t\treturn \"SYS_STATUS\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_SYS_STATUS;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamSysStatus();\n@@ -343,6 +353,11 @@ class MavlinkStreamHighresIMU : public MavlinkStream\n \t\treturn \"HIGHRES_IMU\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_HIGHRES_IMU;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamHighresIMU();\n@@ -428,6 +443,11 @@ class MavlinkStreamAttitude : public MavlinkStream\n \t\treturn \"ATTITUDE\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_ATTITUDE;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamAttitude();\n@@ -474,6 +494,11 @@ class MavlinkStreamAttitudeQuaternion : public MavlinkStream\n \t\treturn \"ATTITUDE_QUATERNION\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_ATTITUDE_QUATERNION;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamAttitudeQuaternion();\n@@ -526,6 +551,11 @@ class MavlinkStreamVFRHUD : public MavlinkStream\n \t\treturn \"VFR_HUD\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_VFR_HUD;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamVFRHUD();\n@@ -609,6 +639,11 @@ class MavlinkStreamGPSRawInt : public MavlinkStream\n \t\treturn \"GPS_RAW_INT\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_GPS_RAW_INT;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamGPSRawInt();\n@@ -662,6 +697,11 @@ class MavlinkStreamGlobalPositionInt : public MavlinkStream\n \t\treturn \"GLOBAL_POSITION_INT\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_GLOBAL_POSITION_INT;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamGlobalPositionInt();\n@@ -723,6 +763,11 @@ class MavlinkStreamLocalPositionNED : public MavlinkStream\n \t\treturn \"LOCAL_POSITION_NED\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_LOCAL_POSITION_NED;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamLocalPositionNED();\n@@ -774,6 +819,11 @@ class MavlinkStreamViconPositionEstimate : public MavlinkStream\n \t\treturn \"VICON_POSITION_ESTIMATE\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamViconPositionEstimate();\n@@ -824,6 +874,11 @@ class MavlinkStreamGPSGlobalOrigin : public MavlinkStream\n \t\treturn \"GPS_GLOBAL_ORIGIN\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamGPSGlobalOrigin();\n@@ -864,6 +919,11 @@ class MavlinkStreamServoOutputRaw : public MavlinkStream\n \t\treturn MavlinkStreamServoOutputRaw<N>::get_name_static();\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_SERVO_OUTPUT_RAW;\n+\t}\n+\n \tstatic const char *get_name_static()\n \t{\n \t\tswitch (N) {\n@@ -941,6 +1001,11 @@ class MavlinkStreamHILControls : public MavlinkStream\n \t\treturn \"HIL_CONTROLS\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_HIL_CONTROLS;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamHILControls();\n@@ -1078,6 +1143,11 @@ class MavlinkStreamGlobalPositionSetpointInt : public MavlinkStream\n \t\treturn \"GLOBAL_POSITION_SETPOINT_INT\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_GLOBAL_POSITION_SETPOINT_INT;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamGlobalPositionSetpointInt();\n@@ -1121,6 +1191,11 @@ class MavlinkStreamLocalPositionSetpoint : public MavlinkStream\n \t\treturn \"LOCAL_POSITION_SETPOINT\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_LOCAL_POSITION_SETPOINT;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamLocalPositionSetpoint();\n@@ -1169,6 +1244,11 @@ class MavlinkStreamRollPitchYawThrustSetpoint : public MavlinkStream\n \t\treturn \"ROLL_PITCH_YAW_THRUST_SETPOINT\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_ROLL_PITCH_YAW_THRUST_SETPOINT;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamRollPitchYawThrustSetpoint();\n@@ -1217,6 +1297,11 @@ class MavlinkStreamRollPitchYawRatesThrustSetpoint : public MavlinkStream\n \t\treturn \"ROLL_PITCH_YAW_RATES_THRUST_SETPOINT\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_ROLL_PITCH_YAW_RATES_THRUST_SETPOINT;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamRollPitchYawRatesThrustSetpoint();\n@@ -1265,6 +1350,11 @@ class MavlinkStreamRCChannelsRaw : public MavlinkStream\n \t\treturn \"RC_CHANNELS_RAW\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_RC_CHANNELS_RAW;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamRCChannelsRaw();\n@@ -1349,6 +1439,11 @@ class MavlinkStreamManualControl : public MavlinkStream\n \t\treturn \"MANUAL_CONTROL\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_MANUAL_CONTROL;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamManualControl();\n@@ -1398,6 +1493,11 @@ class MavlinkStreamOpticalFlow : public MavlinkStream\n \t\treturn \"OPTICAL_FLOW\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_OPTICAL_FLOW;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamOpticalFlow();\n@@ -1446,6 +1546,11 @@ class MavlinkStreamAttitudeControls : public MavlinkStream\n \t\treturn \"ATTITUDE_CONTROLS\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn 0;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamAttitudeControls();\n@@ -1504,6 +1609,11 @@ class MavlinkStreamNamedValueFloat : public MavlinkStream\n \t\treturn \"NAMED_VALUE_FLOAT\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_NAMED_VALUE_FLOAT;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamNamedValueFloat();\n@@ -1552,6 +1662,11 @@ class MavlinkStreamCameraCapture : public MavlinkStream\n \t\treturn \"CAMERA_CAPTURE\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn 0;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamCameraCapture();\n@@ -1597,6 +1712,11 @@ class MavlinkStreamDistanceSensor : public MavlinkStream\n \t\treturn \"DISTANCE_SENSOR\";\n \t}\n \n+\tuint8_t get_id()\n+\t{\n+\t\treturn MAVLINK_MSG_ID_DISTANCE_SENSOR;\n+\t}\n+\n \tstatic MavlinkStream *new_instance()\n \t{\n \t\treturn new MavlinkStreamDistanceSensor();"},{"sha":"bb977d277dd80843b9ce565b349873166ea75a1d","filename":"src/modules/mavlink/mavlink_receiver.cpp","status":"modified","additions":22,"deletions":0,"changes":22,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fmavlink%2Fmavlink_receiver.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fmavlink%2Fmavlink_receiver.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fmavlink%2Fmavlink_receiver.cpp?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -159,6 +159,10 @@ MavlinkReceiver::handle_message(mavlink_message_t *msg)\n \t\thandle_message_heartbeat(msg);\n \t\tbreak;\n \n+\tcase MAVLINK_MSG_ID_REQUEST_DATA_STREAM:\n+\t\thandle_message_request_data_stream(msg);\n+\t\tbreak;\n+\n \tcase MAVLINK_MSG_ID_ENCAPSULATED_DATA:\n \t\tMavlinkFTP::getServer()->handle_message(_mavlink, msg);\n \t\tbreak;\n@@ -498,6 +502,24 @@ MavlinkReceiver::handle_message_heartbeat(mavlink_message_t *msg)\n \t}\n }\n \n+void\n+MavlinkReceiver::handle_message_request_data_stream(mavlink_message_t *msg)\n+{\n+\tmavlink_request_data_stream_t req;\n+\tmavlink_msg_request_data_stream_decode(msg, &req);\n+\n+\tif (req.target_system == mavlink_system.sysid && req.target_component == mavlink_system.compid) {\n+\t\tfloat rate = req.start_stop ? (1000.0f / req.req_message_rate) : 0.0f;\n+\n+\t\tMavlinkStream *stream;\n+\t\tLL_FOREACH(_mavlink->get_streams(), stream) {\n+\t\t\tif (req.req_stream_id == stream->get_id()) {\n+\t\t\t\t_mavlink->configure_stream_threadsafe(stream->get_name(), rate);\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n void\n MavlinkReceiver::handle_message_hil_sensor(mavlink_message_t *msg)\n {"},{"sha":"040a074809b8a0f072a3c45f6b7f87d11227a5d6","filename":"src/modules/mavlink/mavlink_receiver.h","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fmavlink%2Fmavlink_receiver.h","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fmavlink%2Fmavlink_receiver.h","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fmavlink%2Fmavlink_receiver.h?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -115,6 +115,7 @@ class MavlinkReceiver\n \tvoid handle_message_radio_status(mavlink_message_t *msg);\n \tvoid handle_message_manual_control(mavlink_message_t *msg);\n \tvoid handle_message_heartbeat(mavlink_message_t *msg);\n+\tvoid handle_message_request_data_stream(mavlink_message_t *msg);\n \tvoid handle_message_hil_sensor(mavlink_message_t *msg);\n \tvoid handle_message_hil_gps(mavlink_message_t *msg);\n \tvoid handle_message_hil_state_quaternion(mavlink_message_t *msg);"},{"sha":"69809a386995188bc5052f6675c2a31991273ce0","filename":"src/modules/mavlink/mavlink_stream.h","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fmavlink%2Fmavlink_stream.h","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fmavlink%2Fmavlink_stream.h","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fmavlink%2Fmavlink_stream.h?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -67,6 +67,7 @@ class MavlinkStream\n \tstatic const char *get_name_static();\n \tvirtual void subscribe(Mavlink *mavlink) = 0;\n \tvirtual const char *get_name() const = 0;\n+\tvirtual uint8_t get_id() = 0;\n \n protected:\n \tmavlink_channel_t _channel;"},{"sha":"e483b35e8c6f2f67f149057fb38297e0f759b5d8","filename":"src/modules/sdlog2/sdlog2.c","status":"modified","additions":17,"deletions":10,"changes":27,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fsdlog2%2Fsdlog2.c","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fsdlog2%2Fsdlog2.c","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fsdlog2%2Fsdlog2.c?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -976,7 +976,8 @@ int sdlog2_thread_main(int argc, char *argv[])\n \t\t\tstruct log_BATT_s log_BATT;\n \t\t\tstruct log_DIST_s log_DIST;\n \t\t\tstruct log_TELE_s log_TELE;\n-\t\t\tstruct log_ESTM_s log_ESTM;\n+\t\t\tstruct log_EST0_s log_EST0;\n+\t\t\tstruct log_EST1_s log_EST1;\n \t\t\tstruct log_PWR_s log_PWR;\n \t\t\tstruct log_VICN_s log_VICN;\n \t\t\tstruct log_GS0A_s log_GS0A;\n@@ -1489,15 +1490,21 @@ int sdlog2_thread_main(int argc, char *argv[])\n \n \t\t/* --- ESTIMATOR STATUS --- */\n \t\tif (copy_if_updated(ORB_ID(estimator_status), subs.estimator_status_sub, &buf.estimator_status)) {\n-\t\t\tlog_msg.msg_type = LOG_ESTM_MSG;\n-\t\t\tunsigned maxcopy = (sizeof(buf.estimator_status.states) < sizeof(log_msg.body.log_ESTM.s)) ? sizeof(buf.estimator_status.states) : sizeof(log_msg.body.log_ESTM.s);\n-\t\t\tmemset(&(log_msg.body.log_ESTM.s), 0, sizeof(log_msg.body.log_ESTM.s));\n-\t\t\tmemcpy(&(log_msg.body.log_ESTM.s), buf.estimator_status.states, maxcopy);\n-\t\t\tlog_msg.body.log_ESTM.n_states = buf.estimator_status.n_states;\n-\t\t\tlog_msg.body.log_ESTM.states_nan = buf.estimator_status.states_nan;\n-\t\t\tlog_msg.body.log_ESTM.covariance_nan = buf.estimator_status.covariance_nan;\n-\t\t\tlog_msg.body.log_ESTM.kalman_gain_nan = buf.estimator_status.kalman_gain_nan;\n-\t\t\tLOGBUFFER_WRITE_AND_COUNT(ESTM);\n+\t\t\tlog_msg.msg_type = LOG_EST0_MSG;\n+\t\t\tunsigned maxcopy0 = (sizeof(buf.estimator_status.states) < sizeof(log_msg.body.log_EST0.s)) ? sizeof(buf.estimator_status.states) : sizeof(log_msg.body.log_EST0.s);\n+\t\t\tmemset(&(log_msg.body.log_EST0.s), 0, sizeof(log_msg.body.log_EST0.s));\n+\t\t\tmemcpy(&(log_msg.body.log_EST0.s), buf.estimator_status.states, maxcopy0);\n+\t\t\tlog_msg.body.log_EST0.n_states = buf.estimator_status.n_states;\n+\t\t\tlog_msg.body.log_EST0.nan_flags = buf.estimator_status.nan_flags;\n+\t\t\tlog_msg.body.log_EST0.health_flags = buf.estimator_status.health_flags;\n+\t\t\tlog_msg.body.log_EST0.timeout_flags = buf.estimator_status.timeout_flags;\n+\t\t\tLOGBUFFER_WRITE_AND_COUNT(EST0);\n+\n+\t\t\tlog_msg.msg_type = LOG_EST1_MSG;\n+\t\t\tunsigned maxcopy1 = ((sizeof(buf.estimator_status.states) - maxcopy0) < sizeof(log_msg.body.log_EST1.s)) ? (sizeof(buf.estimator_status.states) - maxcopy0) : sizeof(log_msg.body.log_EST1.s);\n+\t\t\tmemset(&(log_msg.body.log_EST1.s), 0, sizeof(log_msg.body.log_EST1.s));\n+\t\t\tmemcpy(&(log_msg.body.log_EST1.s), buf.estimator_status.states + maxcopy0, maxcopy1);\n+\t\t\tLOGBUFFER_WRITE_AND_COUNT(EST1);\n \t\t}\n \n \t\t/* --- TECS STATUS --- */"},{"sha":"8c05e87c59c8a39875d37e8b7c762173e5e9b5a8","filename":"src/modules/sdlog2/sdlog2_messages.h","status":"modified","additions":19,"deletions":10,"changes":29,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fsdlog2%2Fsdlog2_messages.h","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2Fsdlog2%2Fsdlog2_messages.h","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fsdlog2%2Fsdlog2_messages.h?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -288,15 +288,7 @@ struct log_TELE_s {\n \tuint8_t txbuf;\n };\n \n-/* --- ESTM - ESTIMATOR STATUS --- */\n-#define LOG_ESTM_MSG 23\n-struct log_ESTM_s {\n-\tfloat s[10];\n-\tuint8_t n_states;\n-\tuint8_t states_nan;\n-\tuint8_t covariance_nan;\n-\tuint8_t kalman_gain_nan;\n-};\n+// ID 23 available\n \n /* --- PWR - ONBOARD POWER SYSTEM --- */\n #define LOG_PWR_MSG 24\n@@ -377,6 +369,22 @@ struct log_WIND_s {\n \tfloat cov_y;\n };\n \n+/* --- EST0 - ESTIMATOR STATUS --- */\n+#define LOG_EST0_MSG 32\n+struct log_EST0_s {\n+\tfloat s[12];\n+\tuint8_t n_states;\n+\tuint8_t nan_flags;\n+\tuint8_t health_flags;\n+\tuint8_t timeout_flags;\n+};\n+\n+/* --- EST1 - ESTIMATOR STATUS --- */\n+#define LOG_EST1_MSG 33\n+struct log_EST1_s {\n+\tfloat s[16];\n+};\n+\n /********** SYSTEM MESSAGES, ID > 0x80 **********/\n \n /* --- TIME - TIME STAMP --- */\n@@ -425,7 +433,8 @@ static const struct log_format_s log_formats[] = {\n \tLOG_FORMAT(BATT, \"ffff\",\t\t\"V,VFilt,C,Discharged\"),\n \tLOG_FORMAT(DIST, \"ffB\",\t\t\t\"Bottom,BottomRate,Flags\"),\n \tLOG_FORMAT(TELE, \"BBBBHHB\",\t\t\"RSSI,RemRSSI,Noise,RemNoise,RXErr,Fixed,TXBuf\"),\n-\tLOG_FORMAT(ESTM, \"ffffffffffBBBB\",\t\"s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,nStat,statNaN,covNaN,kGainNaN\"),\n+\tLOG_FORMAT(EST0, \"ffffffffffffBBBB\",\t\"s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,nStat,fNaN,fHealth,fTOut\"),\n+\tLOG_FORMAT(EST1, \"ffffffffffffffff\",\t\"s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26,s27\"),\n \tLOG_FORMAT(PWR, \"fffBBBBB\",\t\t\"Periph5V,Servo5V,RSSI,UsbOk,BrickOk,ServoOk,PeriphOC,HipwrOC\"),\n \tLOG_FORMAT(VICN, \"ffffff\",\t\t\"X,Y,Z,Roll,Pitch,Yaw\"),\n \tLOG_FORMAT(GS0A, \"BBBBBBBBBBBBBBBB\",\t\"s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15\"),"},{"sha":"7f26b505b72e8d9e4af94b365b58a3e4c2696cf5","filename":"src/modules/uORB/topics/estimator_status.h","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2FuORB%2Ftopics%2Festimator_status.h","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/28a31708f98eefa4ceb04617f2da3dd7892c99fa/src%2Fmodules%2FuORB%2Ftopics%2Festimator_status.h","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2FuORB%2Ftopics%2Festimator_status.h?ref=28a31708f98eefa4ceb04617f2da3dd7892c99fa","patch":"@@ -64,9 +64,9 @@ struct estimator_status_report {\n \tuint64_t timestamp;\t\t\t/**< Timestamp in microseconds since boot */\n \tfloat states[32];\t\t\t/**< Internal filter states */\n \tfloat n_states;\t\t\t\t/**< Number of states effectively used */\n-\tbool states_nan;\t\t\t/**< If set to true, one of the states is NaN */\n-\tbool covariance_nan;\t\t\t/**< If set to true, the covariance matrix went NaN */\n-\tbool kalman_gain_nan;\t\t\t/**< If set to true, the Kalman gain matrix went NaN */\n+\tuint8_t nan_flags;\t\t\t/**< Bitmask to indicate NaN states */\n+\tuint8_t health_flags;\t\t\t/**< Bitmask to indicate sensor health states (vel, pos, hgt) */\n+\tuint8_t timeout_flags;\t\t\t/**< Bitmask to indicate timeout flags (vel, pos, hgt) */\n \n };\n "}]}