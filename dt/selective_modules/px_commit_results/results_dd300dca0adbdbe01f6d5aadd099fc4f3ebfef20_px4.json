{"sha":"dd300dca0adbdbe01f6d5aadd099fc4f3ebfef20","node_id":"MDY6Q29tbWl0NTI5ODc5MDpkZDMwMGRjYTBhZGJkYmUwMWY2ZDVhYWRkMDk5ZmM0ZjNlYmZlZjIw","commit":{"author":{"name":"Claudio Micheli","email":"claudio@auterion.com","date":"2018-12-17T14:30:06Z"},"committer":{"name":"Beat KÃ¼ng","email":"beat-kueng@gmx.net","date":"2019-01-15T08:17:24Z"},"message":"Solved frequency rate issue. Now driver publish at ~10Hz.\n\n\nSigned-off-by: Claudio Micheli <claudio@auterion.com>","tree":{"sha":"2780c429cd90aec5f28aefbaa233042ecb0fe36a","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/2780c429cd90aec5f28aefbaa233042ecb0fe36a"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/dd300dca0adbdbe01f6d5aadd099fc4f3ebfef20","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/dd300dca0adbdbe01f6d5aadd099fc4f3ebfef20","html_url":"https://github.com/PX4/PX4-Autopilot/commit/dd300dca0adbdbe01f6d5aadd099fc4f3ebfef20","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/dd300dca0adbdbe01f6d5aadd099fc4f3ebfef20/comments","author":{"login":"cmic0","id":7490213,"node_id":"MDQ6VXNlcjc0OTAyMTM=","avatar_url":"https://avatars.githubusercontent.com/u/7490213?v=4","gravatar_id":"","url":"https://api.github.com/users/cmic0","html_url":"https://github.com/cmic0","followers_url":"https://api.github.com/users/cmic0/followers","following_url":"https://api.github.com/users/cmic0/following{/other_user}","gists_url":"https://api.github.com/users/cmic0/gists{/gist_id}","starred_url":"https://api.github.com/users/cmic0/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cmic0/subscriptions","organizations_url":"https://api.github.com/users/cmic0/orgs","repos_url":"https://api.github.com/users/cmic0/repos","events_url":"https://api.github.com/users/cmic0/events{/privacy}","received_events_url":"https://api.github.com/users/cmic0/received_events","type":"User","site_admin":false},"committer":{"login":"bkueng","id":281593,"node_id":"MDQ6VXNlcjI4MTU5Mw==","avatar_url":"https://avatars.githubusercontent.com/u/281593?v=4","gravatar_id":"","url":"https://api.github.com/users/bkueng","html_url":"https://github.com/bkueng","followers_url":"https://api.github.com/users/bkueng/followers","following_url":"https://api.github.com/users/bkueng/following{/other_user}","gists_url":"https://api.github.com/users/bkueng/gists{/gist_id}","starred_url":"https://api.github.com/users/bkueng/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bkueng/subscriptions","organizations_url":"https://api.github.com/users/bkueng/orgs","repos_url":"https://api.github.com/users/bkueng/repos","events_url":"https://api.github.com/users/bkueng/events{/privacy}","received_events_url":"https://api.github.com/users/bkueng/received_events","type":"User","site_admin":false},"parents":[{"sha":"4b7be38e67e6ae97b34baf87973c2492db301b33","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/4b7be38e67e6ae97b34baf87973c2492db301b33","html_url":"https://github.com/PX4/PX4-Autopilot/commit/4b7be38e67e6ae97b34baf87973c2492db301b33"}],"stats":{"total":287,"additions":172,"deletions":115},"files":[{"sha":"30dbe88308e80c04f9e5fa93d32766ee39a9f933","filename":"src/drivers/distance_sensor/airlango/isl2950.cpp","status":"modified","additions":112,"deletions":68,"changes":180,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/dd300dca0adbdbe01f6d5aadd099fc4f3ebfef20/src%2Fdrivers%2Fdistance_sensor%2Fairlango%2Fisl2950.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/dd300dca0adbdbe01f6d5aadd099fc4f3ebfef20/src%2Fdrivers%2Fdistance_sensor%2Fairlango%2Fisl2950.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Fdistance_sensor%2Fairlango%2Fisl2950.cpp?ref=dd300dca0adbdbe01f6d5aadd099fc4f3ebfef20","patch":"@@ -78,9 +78,9 @@\n \n // designated serial port on Pixhawk\n  #define ISL2950_DEFAULT_PORT\t\t\"/dev/ttyS1\" // Its baudrate is 115200\n- // #define LANBAO_DEFAULT_BAUDRATE      115200\n+\n  // normal conversion wait time\n- #define ISL2950_CONVERSION_INTERVAL 50*1000UL /* 50ms */\n+ #define ISL2950_CONVERSION_INTERVAL 100*1000UL/* 100ms */\n \n \n  class ISL2950 : public cdev::CDev\n@@ -105,17 +105,20 @@\n    uint8_t _rotation;\n    float\t\t\t\t_min_distance;\n    float\t\t\t\t_max_distance;\n-   int         \t\t        _conversion_interval;\n+   int         \t_conversion_interval;\n    work_s\t\t\t\t_work{};\n    ringbuffer::RingBuffer\t\t*_reports;\n    int\t\t\t\t_measure_ticks;\n    bool\t\t\t\t_collect_phase;\n    int\t\t\t\t_fd;\n-   char\t\t\t\t_linebuf[50];\n+   uint8_t\t\t\t_linebuf[20];\n    unsigned\t\t\t_linebuf_index;\n+\n    enum ISL2950_PARSE_STATE\t\t_parse_state;\n-   hrt_abstime\t\t\t_last_read;\n+   unsigned char _frame_data[4];\n+   uint16_t     _crc16;\n \n+   hrt_abstime\t\t\t_last_read;\n    int\t\t\t\t_class_instance;\n    int\t\t\t\t_orb_class_instance;\n \n@@ -190,7 +193,9 @@\n \t_collect_phase(false),\n \t_fd(-1),\n \t_linebuf_index(0),\n-\t_parse_state(ISL2950_PARSE_STATE0_UNSYNC),\n+\t_parse_state(TFS_NOT_STARTED),\n+  _frame_data{TOF_SFD1, TOF_SFD2, 0, 0},\n+  _crc16(0),\n \t_last_read(0),\n \t_class_instance(-1),\n \t_orb_class_instance(-1),\n@@ -393,43 +398,111 @@ int\n */\n ISL2950::collect()\n {\n-\tint\tret;\n+  int bytes_read = 0;\n+  int bytes_available = 0;\n+\n+  int distance_mm = -1.0f;\n+  bool full_frame = false;\n+  bool stop_serial_read = false;\n \n   perf_begin(_sample_perf);\n \n   /* clear buffer if last read was too long ago */\n-  int64_t read_elapsed = hrt_elapsed_time(&_last_read);\n+  int64_t read_elapsed = hrt_absolute_time();\n+  read_elapsed = read_elapsed - _last_read;\n+\n+  /* the buffer for read chars is buflen minus null termination */\n+\tuint8_t readbuf[sizeof(_linebuf)];\n+\tunsigned readlen = sizeof(readbuf);\n+\n+  while ((!stop_serial_read)) {\n+    /* read from the sensor (uart buffer) */\n+    bytes_read = ::read(_fd, &readbuf[0], readlen);\n+\n+    if (bytes_read < 0) {\n+      stop_serial_read = true;\n+  \t\tPX4_DEBUG(\"read err: %d \\n\", bytes_read);\n+  \t\tperf_count(_comms_errors);\n+  \t\tperf_end(_sample_perf);\n+\n+    } else if (bytes_read > 0){\n+      _last_read = hrt_absolute_time();\n+      bytes_available += bytes_read;\n+\n+      //printf(\"Got a buffer with %d bytes,read %d \\n\", bytes_available,bytes_read);\n+        for (int i = 0; i < bytes_read; i++) {\n+          if (OK == isl2950_parser(readbuf[i],_frame_data, &_parse_state,&_crc16, &distance_mm)){\n+            stop_serial_read = true;\n+            full_frame = true;\n+          }\n+        }\n+\n+    }\n+  }\n+\n+  if (!full_frame) {\n+\t\treturn -EAGAIN;\n+\t}\n+\n+  printf(\"val (int): %d, raw: 0x%08X, valid: %s \\n\", distance_mm, _frame_data, ((full_frame) ? \"OK\" : \"NO\"));\n+\n+\tstruct distance_sensor_s report;\n+\n+\treport.timestamp = hrt_absolute_time();\n+\treport.type = distance_sensor_s::MAV_DISTANCE_SENSOR_LASER;\n+\treport.orientation = _rotation;\n+\treport.current_distance = distance_mm/1000.0f;\n+\treport.min_distance = get_minimum_distance();\n+\treport.max_distance = get_maximum_distance();\n+\treport.covariance = 0.0f;\n+\treport.signal_quality = -1;\n+\t/* TODO: set proper ID */\n+\treport.id = 0;\n+\n+\t/* publish it */\n+\torb_publish(ORB_ID(distance_sensor), _distance_sensor_topic, &report);\n+\n+\t_reports->force(&report);\n+\n+\t/* notify anyone waiting for data */\n+\tpoll_notify(POLLIN);\n+\n+\tbytes_read = OK;\n+\n+\tperf_end(_sample_perf);\n+\treturn bytes_read;\n \n-  // ----------------------- LANBAO SPECIFIC ---------------------------\n \n+\n+  // ----------------------- LANBAO SPECIFIC ---------------------------\n+/*\n   uint8_t buffer[50];\n   int bytes_available = 0;\n   int bytes_processed = 0;\n   int bytes_read = 0;\n-  bool full_frame;\n-  int distance_mm = -1.0f;\n \n+  int distance_mm = -1.0f;\n   bytes_read = ::read(_fd, buffer + bytes_available, 50 - bytes_available);\n   //printf(\"read() returns %02X %02X %02X %02X \\n\", buffer[0], buffer[1],buffer[2],buffer[3] );\n \n-\n   //--------------------------------------------------------------------\n   if (bytes_read < 0) {\n   \t\tPX4_ERR(\"isl2950 - read() error: %d \\n\", bytes_read);\n   \t\tperf_count(_comms_errors);\n   \t\tperf_end(_sample_perf);\n \n-  \t\t/* only throw an error if we time out */\n+  \t// only throw an error if we time out\n   \t\tif (read_elapsed > (_conversion_interval * 2)) {\n+        printf(\"read elapsed %d , conversion interval %d\",read_elapsed,_conversion_interval * 2);\n   \t\t\treturn bytes_read;\n \n   \t\t} else {\n+        printf(\"EAGAIN\",read_elapsed,_conversion_interval * 2);\n   \t\t\treturn -EAGAIN;\n   \t\t}\n \n   } else if (bytes_read == 0) {\n-  \treturn -EAGAIN;                         // SF0X drivers\n-                                       // LANBAO driver\n+  \treturn OK;                         // If we dont read any bites we simply exit from collecting\n   \t}\n \n   _last_read = hrt_absolute_time();\n@@ -438,7 +511,9 @@ ISL2950::collect()\n \n   // parse the buffer data\n     full_frame = false;\n+\n     bytes_processed = isl2950_parser(buffer, bytes_available, &full_frame,&distance_mm);\n+    tempo = tempo - hrt_absolute_time();\n   //printf(\"isl2950_parser() processed %d bytes, full_frame %d \\n\", bytes_processed, full_frame);\n \n   // discard the processed bytes and move the buffer content to the head\n@@ -449,36 +524,34 @@ ISL2950::collect()\n     printf(\"Measured Distance %d mm\\n\",distance_mm);\n   }\n \n-  else if (!full_frame) {\n-    return -EAGAIN;\n-\n+  else if (!full_frame) {     // If the frame is not valid we avoid publishing it\n+    return OK;\n   }\n \n   struct distance_sensor_s report;\n \n   \treport.timestamp = hrt_absolute_time();\n   \treport.type = distance_sensor_s::MAV_DISTANCE_SENSOR_LASER;\n   \treport.orientation = _rotation;\n-  \treport.current_distance = distance_mm /1000.f;        //  To meters\n+  \treport.current_distance = distance_mm/1000;        //  To meters\n   \treport.min_distance = get_minimum_distance();\n   \treport.max_distance = get_maximum_distance();\n   \treport.covariance = 0.0f;\n   \treport.signal_quality = -1;\n-  \t/* TODO: set proper ID */\n+  \t// TODO: set proper ID\n   \treport.id = 0;\n \n-  \t/* publish it */\n+  \t// publish it\n   \torb_publish(ORB_ID(distance_sensor), _distance_sensor_topic, &report);\n \n   \t_reports->force(&report);\n \n-  \t/* notify anyone waiting for data */\n+  \t// notify anyone waiting for data\n   \tpoll_notify(POLLIN);\n \n-  \tret = OK;\n-\n+    printf(\"tempo %d \\n\",tempo);\n   \tperf_end(_sample_perf);\n-  \treturn ret;\n+  \treturn OK; */\n }\n \n void\n@@ -550,12 +623,7 @@ ISL2950::cycle()\n \t\t\tPX4_ERR(\"baud %d ATTR\", termios_state);\n \t\t}\n \t}\n-\n-\n-\n-\t/* collection phase? */\n-\tif (_collect_phase) {\n-\n+    //printf(\"COLLECT \\n\");\n \t\t/* perform collection */\n \t\tint collect_ret = collect();\n \n@@ -565,51 +633,27 @@ ISL2950::cycle()\n \t\t\treturn;\n \t\t}\n \n-\t\tif (OK != collect_ret) {\n+\n+  // ------------------- DISABLED CHECKING OF CONSECUTIVE FAIL\n+  //  if (OK != collect_ret) {\n \n \t\t\t/* we know the sensor needs about four seconds to initialize */\n-\t\t\tif (hrt_absolute_time() > 5 * 1000 * 1000LL && _consecutive_fail_count < 5) {\n-\t\t\t\tPX4_ERR(\"collection error #%u\", _consecutive_fail_count);\n-\t\t\t}\n+\t//\t\tif (hrt_absolute_time() > 1 * 1000 * 1000LL && _consecutive_fail_count < 5) {\n+\t//\t\t\tPX4_ERR(\"collection error #%u\", _consecutive_fail_count);\n+\t//\t\t}\n \n-\t\t\t_consecutive_fail_count++;\n+\t//\t\t_consecutive_fail_count++;\n \n \t\t\t/* restart the measurement state machine */\n-\t\t\tstart();\n-\t\t\treturn;\n+\t//\t\tstart();\n+\t//\t\treturn;\n \n-\t\t} else {\n+\t//\t} else {\n \t\t\t/* apparently success */\n-\t\t\t_consecutive_fail_count = 0;\n-\t\t}\n-\n-\t\t/* next phase is measurement */\n-\t\t_collect_phase = false;\n-\n-\t\t/*\n-\t\t * Is there a collect->measure gap?\n-\t\t */\n-\t\tif (_measure_ticks > USEC2TICK(_conversion_interval)) {\n-\n-\t\t\t/* schedule a fresh cycle call when we are ready to measure again */\n-\t\t\twork_queue(HPWORK,\n-\t\t\t\t   &_work,\n-\t\t\t\t   (worker_t)&ISL2950::cycle_trampoline,\n-\t\t\t\t   this,\n-\t\t\t\t   _measure_ticks - USEC2TICK(_conversion_interval));\n-\n-\t\t\treturn;\n-\t\t}\n-\t}\n-\n-\t/* measurement phase */\n-/*  if (OK != measure()) {\n-\t\tPX4_DEBUG(\"measure error\");\n-\t}\n-*/\n+\t//\t\t_consecutive_fail_count = 0;\n+\t//\t}\n+  // ------------------- DISABLED CHECKING OF CONSECUTIVE FAIL\n \n-\t/* next phase is collection */\n-\t_collect_phase = true;\n \n \t/* schedule a fresh cycle call when the measurement is done */\n \twork_queue(HPWORK,"},{"sha":"468e02299ad01d601e1c868c5d183753ebe765df","filename":"src/drivers/distance_sensor/airlango/isl2950_parser.cpp","status":"modified","additions":44,"deletions":42,"changes":86,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/dd300dca0adbdbe01f6d5aadd099fc4f3ebfef20/src%2Fdrivers%2Fdistance_sensor%2Fairlango%2Fisl2950_parser.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/dd300dca0adbdbe01f6d5aadd099fc4f3ebfef20/src%2Fdrivers%2Fdistance_sensor%2Fairlango%2Fisl2950_parser.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Fdistance_sensor%2Fairlango%2Fisl2950_parser.cpp?ref=dd300dca0adbdbe01f6d5aadd099fc4f3ebfef20","patch":"@@ -33,7 +33,8 @@\n \n /**\n  * @file isl2950_parser.cpp\n- * @author Claudio Micheli claudio@auterion.com\n+ * @author Claudio Micheli\n+ *         claudio@auterion.com\n  *\n  */\n \n@@ -100,6 +101,7 @@ static const UCHAR aucCRCLo[] = {\n   0x41, 0x81, 0x80, 0x40\n };\n \n+\n // TOF frame format\n //\n //   1B     1B      1B              1B            2B\n@@ -109,9 +111,7 @@ static const UCHAR aucCRCLo[] = {\n const static int TOF_DISTANCE_MSB_POS   = 2;\n const static int TOF_DISTANCE_LSB_POS   = 3;\n const static int TOF_CRC_CALC_DATA_LEN  = 4;\n-static unsigned char frame_data[TOF_CRC_CALC_DATA_LEN] = {\n-  TOF_SFD1, TOF_SFD2, 0, 0\n-};\n+\n \n USHORT usMBCRC16(UCHAR* pucFrame, USHORT usLen) {\n   UCHAR ucCRCHi = 0xFF;\n@@ -125,79 +125,81 @@ USHORT usMBCRC16(UCHAR* pucFrame, USHORT usLen) {\n   return (USHORT)(ucCRCHi << 8 | ucCRCLo);\n }\n \n-int isl2950_parser(const uint8_t* buffer, int length, bool* full_frame, int* dist)\n+int isl2950_parser(uint8_t c, uint8_t *parserbuf, ISL2950_PARSE_STATE *state, uint16_t *crc16, int *dist)\n {\n-  static TofFramingState state = TFS_NOT_STARTED;\n-  static uint16_t crc16 = 0;\n-  int bytes_processed = 0;\n+  int ret = -1;\n+//  int bytes_processed = 0;\n \n-  while (bytes_processed < length) {\n-    uint8_t b = buffer[bytes_processed++];\n+\n+//    uint8_t b = buffer[bytes_processed++];    // Can be removed\n //    printf(\"parse byte 0x%02X \\n\", b);\n \n-    switch (state) {\n+    switch (*state) {\n     case TFS_NOT_STARTED:\n-      if (b == TOF_SFD1) {\n-        state = TFS_GOT_SFD1;\n-  //      printf(\"Got SFD1 \\n\");\n+      if (c == TOF_SFD1) {\n+        *state = TFS_GOT_SFD1;\n+        //printf(\"Got SFD1 \\n\");\n       }\n       break;\n \n     case TFS_GOT_SFD1:\n-      if (b == TOF_SFD2) {\n-        state = TFS_GOT_SFD2;\n-//        printf(\"Got SFD2 \\n\");\n-      } else if (b == TOF_SFD1) {\n-        state = TFS_GOT_SFD1;\n+      if (c == TOF_SFD2) {\n+          *state = TFS_GOT_SFD2;\n+         //printf(\"Got SFD2 \\n\");\n+      }\n+      // @NOTE (claudio@auterion.com): Strange thing, if second byte is wrong we skip all the frame !!\n+      else if (c == TOF_SFD1) {\n+        *state = TFS_GOT_SFD1;\n //        printf(\"Discard previous SFD1, Got new SFD1 \\n\");\n       } else {\n-        state = TFS_NOT_STARTED;\n+        *state = TFS_NOT_STARTED;\n       }\n       break;\n \n     case TFS_GOT_SFD2:\n-      frame_data[TOF_DISTANCE_MSB_POS] = b;\n-      state = TFS_GOT_DATA1;\n-//      printf(\"Got DATA1 0x%02X \\n\", b);\n+      *state = TFS_GOT_DATA1;\n+      parserbuf[TOF_DISTANCE_MSB_POS] = c;                  // MSB Data\n+      //printf(\"Got DATA1 0x%02X \\n\", c);\n       break;\n \n     case TFS_GOT_DATA1:\n-      frame_data[TOF_DISTANCE_LSB_POS] = b;\n-      state = TFS_GOT_DATA2;\n-//      printf(\"Got DATA2 0x%02X \\n\", b);\n+      *state = TFS_GOT_DATA2;\n+      parserbuf[TOF_DISTANCE_LSB_POS] = c;                  // LSB Data\n+      //printf(\"Got DATA2 0x%02X \\n\", c);\n       // do crc calculation\n-      crc16 = usMBCRC16(frame_data, TOF_CRC_CALC_DATA_LEN);\n+      *crc16 = usMBCRC16(parserbuf, TOF_CRC_CALC_DATA_LEN);\n       // convert endian\n-      crc16 = (crc16 >> 8) | (crc16 << 8);\n+      *crc16 = (*crc16 >> 8) | (*crc16 << 8);\n       break;\n \n     case TFS_GOT_DATA2:\n-      if (b == (crc16 >> 8)) {\n-        state = TFS_GOT_CHECKSUM1;\n+      if (c == (*crc16 >> 8)) {\n+        *state = TFS_GOT_CHECKSUM1;\n       } else {\n-//        printf(\"Checksum invalid on high byte: 0x%02X, calculated: 0x%04X \\n\",b, crc16);\n-        state = TFS_NOT_STARTED;\n+        printf(\"Checksum invalid on high byte: 0x%02X, calculated: 0x%04X \\n\",c, *crc16);\n+        //*state = TFS_NOT_STARTED;\n+        *state = TFS_GOT_CHECKSUM1; // Forcing to print the value anyway\n       }\n       break;\n \n     case TFS_GOT_CHECKSUM1:\n       // Here, reset state to `NOT-STARTED` no matter crc ok or not\n-      state = TFS_NOT_STARTED;\n-      if (b == (crc16 & 0xFF)) {\n+      *state = TFS_NOT_STARTED;\n+      /*if (c == (*crc16 & 0xFF)) {\n       //printf(\"Checksum verified \\n\");\n-        *dist = (frame_data[TOF_DISTANCE_MSB_POS] << 8) | frame_data[TOF_DISTANCE_LSB_POS];\n-        *full_frame = true;\n-        return bytes_processed;\n-      } else {\n-        printf(\"Checksum invalidon low byte: 0x%02X, calculated: 0x%04X \\n\",b, crc16);\n-      }\n+        *dist = (parserbuf[TOF_DISTANCE_MSB_POS] << 8) | parserbuf[TOF_DISTANCE_LSB_POS];\n+        return OK;\n+      }*/\n+      *dist = (parserbuf[TOF_DISTANCE_MSB_POS] << 8) | parserbuf[TOF_DISTANCE_LSB_POS];\n+      return OK;\n+\n       break;\n \n     default:\n       printf(\"This should never happen. \\n\");\n       break;\n     }\n-  }\n+\n   // SOME STUFFS\n-  return bytes_processed;\n+  return ret;\n }"},{"sha":"4729c44fb3a1be6f6275778e36c7efc0d2d6f840","filename":"src/drivers/distance_sensor/airlango/isl2950_parser.h","status":"modified","additions":16,"deletions":5,"changes":21,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/dd300dca0adbdbe01f6d5aadd099fc4f3ebfef20/src%2Fdrivers%2Fdistance_sensor%2Fairlango%2Fisl2950_parser.h","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/dd300dca0adbdbe01f6d5aadd099fc4f3ebfef20/src%2Fdrivers%2Fdistance_sensor%2Fairlango%2Fisl2950_parser.h","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Fdistance_sensor%2Fairlango%2Fisl2950_parser.h?ref=dd300dca0adbdbe01f6d5aadd099fc4f3ebfef20","patch":"@@ -40,19 +40,30 @@\n \n #pragma once\n \n+#include <stdint.h>\n // frame start delimiter\n #define TOF_SFD1      0xA5\n #define TOF_SFD2      0x5A\n \n-typedef enum {\n+/*typedef enum {\n   TFS_NOT_STARTED = 0,\n   TFS_GOT_SFD1,\n   TFS_GOT_SFD2,\n   TFS_GOT_DATA1,\n   TFS_GOT_DATA2,\n   TFS_GOT_CHECKSUM1,\n   TFS_GOT_CHECKSUM2,\n-} TofFramingState;\n+} TofFramingState;*/\n+\n+enum ISL2950_PARSE_STATE {\n+  TFS_NOT_STARTED = 0,\n+  TFS_GOT_SFD1,\n+  TFS_GOT_SFD2,\n+  TFS_GOT_DATA1,\n+  TFS_GOT_DATA2,\n+  TFS_GOT_CHECKSUM1,\n+  TFS_GOT_CHECKSUM2,\n+};\n \n enum IslWorkingMode {\n   KEEP_HEIGHT = 0,\n@@ -61,15 +72,15 @@ enum IslWorkingMode {\n \n \n // SF0X STYLE\n-enum ISL2950_PARSE_STATE {\n+/*enum ISL2950_PARSE_STATE {\n \tISL2950_PARSE_STATE0_UNSYNC = 0,\n \tISL2950_PARSE_STATE1_SYNC,\n \tISL2950_PARSE_STATE2_GOT_DIGIT0,\n \tISL2950_PARSE_STATE3_GOT_DOT,\n \tISL2950_PARSE_STATE4_GOT_DIGIT1,\n \tISL2950_PARSE_STATE5_GOT_DIGIT2,\n \tISL2950_PARSE_STATE6_GOT_CARRIAGE_RETURN\n-};\n+};*/\n \n \n-int isl2950_parser(const uint8_t* buffer, int length, bool* full_frame, int* dist);\n+int isl2950_parser(uint8_t c, uint8_t *parserbuf,enum ISL2950_PARSE_STATE *state,uint16_t *crc16, int *dist);"}]}