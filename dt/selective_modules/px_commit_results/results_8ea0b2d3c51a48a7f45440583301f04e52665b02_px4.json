{"sha":"8ea0b2d3c51a48a7f45440583301f04e52665b02","node_id":"MDY6Q29tbWl0NTI5ODc5MDo4ZWEwYjJkM2M1MWE0OGE3ZjQ1NDQwNTgzMzAxZjA0ZTUyNjY1YjAy","commit":{"author":{"name":"priseborough","email":"p_riseborough@live.com.au","date":"2017-03-08T00:03:27Z"},"committer":{"name":"Lorenz Meier","email":"lorenz@px4.io","date":"2017-05-03T06:37:14Z"},"message":"commander: rework posvel validity checks\n\nMove into functions.\nReset probation time and recalculate checks if a mode change is demanded to give the operator ability to regain control as soon as possible after nav performance is regained. (+11 squashed commits)\nSquashed commits:\n[a4bb800] commander: enable pilot to quickly recover from loss of position accuracy\n[19e16a0] commander: rework postal probation time\n[f96284e] commander: rework bad pos and vel test probation time\n[00d5f0c] commander: Allow EKF preflight checks to pass with moving vehicle\n\nSeparates the 'is using GPS' and the GPS quality checks.\nUses a reasonable subset of the GPS quality checks which allows checks to pass if the vehicle is moving.\n[4cdfb5c] commander: remove unused variable\n[349385a] commander: add EKF GPS quality checks to pre-arm checking\n\nOnly perform check if GPs checking is activated by parameter setting.\nDisplay fault messages that makes it clear if EKF quality checks are failing or the EKF is not using GPS for another reason. We do not want to confuse this with GPS lock.\n[340ae29] commander: make position invalid fail-safe more sticky\n\nRequire check to pass for 7 seconds before exiting failsafe. This is required because if GPs is failing innovation tests for a prolonged period, the EKF will periodically reset to the GPS and report good accuracy at the time of reset.\nAdding this delay gives time for an underlying error condition (eg bad IMU or compass) to be re-detected.\n[b04ac95] commander: Increase RAM allocation to eliminate low stack warnings\n[9dca12f] commander: add missing position invalid fail-safe responses\n[69f264d] commander: Update position invalid fail-safe responses\n\nReplace separate logic for each case with a generic function\nAdd velocity checks.\n[8e8cef1] commander: rework position validity checks\n\nConsolidate existing checks for global and local position validity and add checking of velocity accuracy.\nEnable checks to be bypassed using the CBRK_VELPOSERR parameter.","tree":{"sha":"886943b16a82eda5d977a0d24b0d9768addac473","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/886943b16a82eda5d977a0d24b0d9768addac473"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/8ea0b2d3c51a48a7f45440583301f04e52665b02","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/8ea0b2d3c51a48a7f45440583301f04e52665b02","html_url":"https://github.com/PX4/PX4-Autopilot/commit/8ea0b2d3c51a48a7f45440583301f04e52665b02","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/8ea0b2d3c51a48a7f45440583301f04e52665b02/comments","author":{"login":"priseborough","id":3596952,"node_id":"MDQ6VXNlcjM1OTY5NTI=","avatar_url":"https://avatars.githubusercontent.com/u/3596952?v=4","gravatar_id":"","url":"https://api.github.com/users/priseborough","html_url":"https://github.com/priseborough","followers_url":"https://api.github.com/users/priseborough/followers","following_url":"https://api.github.com/users/priseborough/following{/other_user}","gists_url":"https://api.github.com/users/priseborough/gists{/gist_id}","starred_url":"https://api.github.com/users/priseborough/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/priseborough/subscriptions","organizations_url":"https://api.github.com/users/priseborough/orgs","repos_url":"https://api.github.com/users/priseborough/repos","events_url":"https://api.github.com/users/priseborough/events{/privacy}","received_events_url":"https://api.github.com/users/priseborough/received_events","type":"User","site_admin":false},"committer":{"login":"LorenzMeier","id":1208119,"node_id":"MDQ6VXNlcjEyMDgxMTk=","avatar_url":"https://avatars.githubusercontent.com/u/1208119?v=4","gravatar_id":"","url":"https://api.github.com/users/LorenzMeier","html_url":"https://github.com/LorenzMeier","followers_url":"https://api.github.com/users/LorenzMeier/followers","following_url":"https://api.github.com/users/LorenzMeier/following{/other_user}","gists_url":"https://api.github.com/users/LorenzMeier/gists{/gist_id}","starred_url":"https://api.github.com/users/LorenzMeier/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/LorenzMeier/subscriptions","organizations_url":"https://api.github.com/users/LorenzMeier/orgs","repos_url":"https://api.github.com/users/LorenzMeier/repos","events_url":"https://api.github.com/users/LorenzMeier/events{/privacy}","received_events_url":"https://api.github.com/users/LorenzMeier/received_events","type":"User","site_admin":false},"parents":[{"sha":"40160c44881b850aaf8ee6030836869982350eed","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/40160c44881b850aaf8ee6030836869982350eed","html_url":"https://github.com/PX4/PX4-Autopilot/commit/40160c44881b850aaf8ee6030836869982350eed"}],"stats":{"total":542,"additions":400,"deletions":142},"files":[{"sha":"63f3873d58fdc19d996d679c380476090166cb2e","filename":"src/modules/commander/PreflightCheck.cpp","status":"modified","additions":27,"deletions":2,"changes":29,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/8ea0b2d3c51a48a7f45440583301f04e52665b02/src%2Fmodules%2Fcommander%2FPreflightCheck.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/8ea0b2d3c51a48a7f45440583301f04e52665b02/src%2Fmodules%2Fcommander%2FPreflightCheck.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fcommander%2FPreflightCheck.cpp?ref=8ea0b2d3c51a48a7f45440583301f04e52665b02","patch":"@@ -448,7 +448,7 @@ static bool gnssCheck(orb_advert_t *mavlink_log_pub, bool report_fail)\n \treturn success;\n }\n \n-static bool ekf2Check(orb_advert_t *mavlink_log_pub, bool optional, bool report_fail)\n+static bool ekf2Check(orb_advert_t *mavlink_log_pub, bool optional, bool report_fail, bool enforce_gps_required)\n {\n \t// Get estimator status data if available and exit with a fail recorded if not\n \tint sub = orb_subscribe(ORB_ID(estimator_status));\n@@ -491,6 +491,31 @@ static bool ekf2Check(orb_advert_t *mavlink_log_pub, bool optional, bool report_\n \t\tgoto out;\n \t}\n \n+\t// If GPS aiding is required, declare fault condition if the EKF is not using GPS\n+\tif (enforce_gps_required) {\n+\t\tif (!(status.control_mode_flags & 2)) {\n+\t\t\tif (report_fail) {\n+\t\t\t\tmavlink_log_critical(mavlink_log_pub, \"PREFLIGHT FAIL: EKF NOT USING GPS\");\n+\t\t\t}\n+\t\t\tsuccess = false;\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+\t// If GPS aiding is required, declare fault condition if the required GPS quality checks are failing\n+\tif (enforce_gps_required) {\n+\t\tif ((status.gps_check_fail_flags & (estimator_status_s::GPS_CHECK_FAIL_MIN_SAT_COUNT\n+\t\t\t\t\t\t    | estimator_status_s::GPS_CHECK_FAIL_MIN_GDOP\n+\t\t\t\t\t\t    | estimator_status_s::GPS_CHECK_FAIL_MAX_HORZ_ERR\n+\t\t\t\t\t\t    | estimator_status_s::GPS_CHECK_FAIL_MAX_VERT_ERR)) > 0) {\n+\t\t\tif (report_fail) {\n+\t\t\t\tmavlink_log_critical(mavlink_log_pub, \"PREFLIGHT FAIL: GPS QUALITY CHECKS\");\n+\t\t\t}\n+\t\t\tsuccess = false;\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n \t// check magnetometer innovation test ratio\n \tparam_get(param_find(\"COM_ARM_EKF_YAW\"), &test_limit);\n \tif (status.mag_test_ratio > test_limit) {\n@@ -694,7 +719,7 @@ bool preflightCheck(orb_advert_t *mavlink_log_pub, bool checkMag, bool checkAcc,\n \tint32_t estimator_type;\n \tparam_get(param_find(\"SYS_MC_EST_GROUP\"), &estimator_type);\n \tif (estimator_type == 2 && checkGNSS) {\n-\t\tif (!ekf2Check(mavlink_log_pub, true, reportFailures)) {\n+\t\tif (!ekf2Check(mavlink_log_pub, true, reportFailures, checkGNSS)) {\n \t\t\tfailed = true;\n \t\t}\n \t}"},{"sha":"04976950580e1c591e8ea4485f0c709e62224801","filename":"src/modules/commander/commander.cpp","status":"modified","additions":290,"deletions":75,"changes":365,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/8ea0b2d3c51a48a7f45440583301f04e52665b02/src%2Fmodules%2Fcommander%2Fcommander.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/8ea0b2d3c51a48a7f45440583301f04e52665b02/src%2Fmodules%2Fcommander%2Fcommander.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fcommander%2Fcommander.cpp?ref=8ea0b2d3c51a48a7f45440583301f04e52665b02","patch":"@@ -159,6 +159,18 @@ static constexpr uint8_t COMMANDER_MAX_GPS_NOISE = 60;\t\t/**< Maximum percentage\n #define HIL_ID_MIN 1000\n #define HIL_ID_MAX 1999\n \n+/* Controls the probation period which is the amount of time required for position and velocity checks to pass before the validity can be changed from false to true*/\n+#define POSVEL_PROBATION_TAKEOFF 30E6\t\t/**< probation duration set at takeoff (usec) */\n+#define POSVEL_PROBATION_MIN 1E6\t\t/**< minimum probation duration (usec) */\n+#define POSVEL_PROBATION_MAX 100E6\t\t/**< maximum probation duration (usec) */\n+#define POSVEL_VALID_PROBATION_FACTOR 10\t/**< the rate at which the probation duration is increased while checks are failing */\n+\n+/* Probation times for position and velocity validity checks to pass if failed */\n+static int64_t gpos_probation_time_us = POSVEL_PROBATION_TAKEOFF;\n+static int64_t gvel_probation_time_us = POSVEL_PROBATION_TAKEOFF;\n+static int64_t lpos_probation_time_us = POSVEL_PROBATION_TAKEOFF;\n+static int64_t lvel_probation_time_us = POSVEL_PROBATION_TAKEOFF;\n+\n /* Mavlink log uORB handle */\n static orb_advert_t mavlink_log_pub = nullptr;\n \n@@ -179,8 +191,14 @@ static uint64_t last_print_mode_reject_time = 0;\n \n static systemlib::Hysteresis auto_disarm_hysteresis(false);\n \n-static float eph_threshold = 5.0f;\n-static float epv_threshold = 10.0f;\n+static float eph_threshold = 5.0f;\t// Horizontal position error threshold (m)\n+static float epv_threshold = 10.0f;\t// Vertivcal position error threshold (m)\n+static float evh_threshold = 1.0f;\t// Horizontal velocity error threshold (m)\n+\n+static uint64_t last_lpos_fail_time_us = 0;\t// Last time that the local position validity recovery check failed (usec)\n+static uint64_t last_gpos_fail_time_us = 0;\t// Last time that the global position validity recovery check failed (usec)\n+static uint64_t last_lvel_fail_time_us = 0;\t// Last time that the local velocity validity recovery check failed (usec)\n+static uint64_t last_gvel_fail_time_us = 0;\t// Last time that the global velocity validity recovery check failed (usec)\n \n /* pre-flight EKF checks */\n static float max_ekf_pos_ratio = 0.5f;\n@@ -233,6 +251,7 @@ static bool arm_mission_required = false;\n \n static bool _last_condition_global_position_valid = false;\n \n+static struct vehicle_land_detected_s land_detector = {};\n \n /**\n  * The daemon app only briefly exists to start\n@@ -258,7 +277,8 @@ bool handle_command(struct vehicle_status_s *status, const struct safety_s *safe\n \t\t    struct actuator_armed_s *armed, struct home_position_s *home, struct vehicle_global_position_s *global_pos,\n \t\t    struct vehicle_local_position_s *local_pos, struct vehicle_attitude_s *attitude, orb_advert_t *home_pub,\n \t\t    orb_advert_t *command_ack_pub, struct vehicle_command_ack_s *command_ack, struct vehicle_roi_s *roi,\n-\t\t\torb_advert_t *roi_pub);\n+\t\t\torb_advert_t *roi_pub,\n+\t\t    bool *changed);\n \n /**\n  * Mainloop of commander.\n@@ -272,7 +292,13 @@ void get_circuit_breaker_params();\n \n void check_valid(hrt_abstime timestamp, hrt_abstime timeout, bool valid_in, bool *valid_out, bool *changed);\n \n-transition_result_t set_main_state_rc(struct vehicle_status_s *status);\n+transition_result_t set_main_state_rc(struct vehicle_status_s *status, vehicle_global_position_s *global_position, vehicle_local_position_s *local_position, bool *changed);\n+\n+void reset_posvel_validity(vehicle_global_position_s *global_position, vehicle_local_position_s *local_position, bool *changed);\n+\n+void check_global_posvel_validity(vehicle_global_position_s *global_position, bool *changed);\n+\n+void check_local_posvel_validity(vehicle_local_position_s *local_position, bool *changed);\n \n void set_control_mode();\n \n@@ -342,7 +368,7 @@ int commander_main(int argc, char *argv[])\n \t\tdaemon_task = px4_task_spawn_cmd(\"commander\",\n \t\t\t\t\t     SCHED_DEFAULT,\n \t\t\t\t\t     SCHED_PRIORITY_DEFAULT + 40,\n-\t\t\t\t\t     3600,\n+\t\t\t\t\t     3700,\n \t\t\t\t\t     commander_thread_main,\n \t\t\t\t\t     (char * const *)&argv[0]);\n \n@@ -705,7 +731,7 @@ bool handle_command(struct vehicle_status_s *status_local, const struct safety_s\n \t\t    struct home_position_s *home, struct vehicle_global_position_s *global_pos,\n \t\t    struct vehicle_local_position_s *local_pos, struct vehicle_attitude_s *attitude, orb_advert_t *home_pub,\n \t\t    orb_advert_t *command_ack_pub, struct vehicle_command_ack_s *command_ack,\n-\t\t\tstruct vehicle_roi_s *roi, orb_advert_t *roi_pub)\n+\t\t\tstruct vehicle_roi_s *roi, orb_advert_t *roi_pub, bool *changed)\n {\n \t/* only handle commands that are meant to be handled by this system and component */\n \tif (cmd->target_system != status_local->system_id || ((cmd->target_component != status_local->component_id)\n@@ -770,11 +796,13 @@ bool handle_command(struct vehicle_status_s *status_local, const struct safety_s\n \n \t\t\t\t} else if (custom_main_mode == PX4_CUSTOM_MAIN_MODE_POSCTL) {\n \t\t\t\t\t/* POSCTL */\n+\t\t\t\t\treset_posvel_validity(global_pos, local_pos, changed);\n \t\t\t\t\tmain_ret = main_state_transition(status_local, commander_state_s::MAIN_STATE_POSCTL, main_state_prev, &status_flags, &internal_state);\n \n \t\t\t\t} else if (custom_main_mode == PX4_CUSTOM_MAIN_MODE_AUTO) {\n \t\t\t\t\t/* AUTO */\n \t\t\t\t\tif (custom_sub_mode > 0) {\n+\t\t\t\t\t\treset_posvel_validity(global_pos, local_pos, changed);\n \t\t\t\t\t\tswitch(custom_sub_mode) {\n \t\t\t\t\t\tcase PX4_CUSTOM_SUB_MODE_AUTO_LOITER:\n \t\t\t\t\t\t\tmain_ret = main_state_transition(status_local, commander_state_s::MAIN_STATE_AUTO_LOITER, main_state_prev, &status_flags, &internal_state);\n@@ -818,6 +846,7 @@ bool handle_command(struct vehicle_status_s *status_local, const struct safety_s\n \t\t\t\t\tmain_ret = main_state_transition(status_local, commander_state_s::MAIN_STATE_STAB, main_state_prev, &status_flags, &internal_state);\n \n \t\t\t\t} else if (custom_main_mode == PX4_CUSTOM_MAIN_MODE_OFFBOARD) {\n+\t\t\t\t\treset_posvel_validity(global_pos, local_pos, changed);\n \t\t\t\t\t/* OFFBOARD */\n \t\t\t\t\tmain_ret = main_state_transition(status_local, commander_state_s::MAIN_STATE_OFFBOARD, main_state_prev, &status_flags, &internal_state);\n \t\t\t\t}\n@@ -1447,6 +1476,13 @@ int commander_thread_main(int argc, char *argv[])\n \tstatus_flags.circuit_breaker_engaged_gpsfailure_check = false;\n \tget_circuit_breaker_params();\n \n+\t/* Set position and velocity validty to false */\n+\tstatus_flags.condition_global_position_valid = false;\n+\tstatus_flags.condition_global_velocity_valid = false;\n+\tstatus_flags.condition_local_position_valid = false;\n+\tstatus_flags.condition_local_velocity_valid = false;\n+\tstatus_flags.condition_local_altitude_valid = false;\n+\n \t// initialize gps failure to false if circuit breaker enabled\n \tif (status_flags.circuit_breaker_engaged_gpsfailure_check) {\n \t\tstatus_flags.gps_failure = false;\n@@ -1587,7 +1623,6 @@ int commander_thread_main(int argc, char *argv[])\n \n \t/* Subscribe to land detector */\n \tint land_detector_sub = orb_subscribe(ORB_ID(vehicle_land_detected));\n-\tstruct vehicle_land_detected_s land_detector = {};\n \tland_detector.landed = true;\n \n \t/*\n@@ -2110,85 +2145,44 @@ int commander_thread_main(int argc, char *argv[])\n \t\t\tstatus_changed = true;\n \t\t}\n \n+\t\t// Check if quality checking of position accuracy and consistency is to be performed\n+\t\tbool run_quality_checks = !status_flags.circuit_breaker_engaged_posfailure_check;\n+\n \t\t/* update global position estimate */\n-\t\torb_check(global_position_sub, &updated);\n+\t\tbool gpos_updated =  false;\n+\t\torb_check(global_position_sub, &gpos_updated);\n \n-\t\tif (updated) {\n+\t\tif (gpos_updated) {\n \t\t\t/* position changed */\n-\t\t\tvehicle_global_position_s gpos;\n-\t\t\torb_copy(ORB_ID(vehicle_global_position), global_position_sub, &gpos);\n-\n-\t\t\t/* copy to global struct if valid, with hysteresis */\n+\t\t\torb_copy(ORB_ID(vehicle_global_position), global_position_sub, &global_position);\n \n-\t\t\t// XXX consolidate this with local position handling and timeouts after release\n-\t\t\t// but we want a low-risk change now.\n-\t\t\tif (status_flags.condition_global_position_valid) {\n-\t\t\t\tif (gpos.eph < eph_threshold * 2.5f) {\n-\t\t\t\t\torb_copy(ORB_ID(vehicle_global_position), global_position_sub, &global_position);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tif (gpos.eph < eph_threshold) {\n-\t\t\t\t\torb_copy(ORB_ID(vehicle_global_position), global_position_sub, &global_position);\n-\t\t\t\t}\n+\t\t\tif (run_quality_checks) {\n+\t\t\t\tcheck_global_posvel_validity(&global_position, &status_changed);\n \t\t\t}\n \t\t}\n \n \t\t/* update local position estimate */\n-\t\torb_check(local_position_sub, &updated);\n+\t\tbool lpos_updated = false;\n+\t\torb_check(local_position_sub, &lpos_updated);\n \n-\t\tif (updated) {\n+\t\tif (lpos_updated) {\n \t\t\t/* position changed */\n \t\t\torb_copy(ORB_ID(vehicle_local_position), local_position_sub, &local_position);\n+\n+\t\t\tif (run_quality_checks) {\n+\t\t\t\tcheck_local_posvel_validity(&local_position, &status_changed);\n+\t\t\t}\n \t\t}\n \n \t\t/* update attitude estimate */\n \t\torb_check(attitude_sub, &updated);\n \n \t\tif (updated) {\n-\t\t\t/* position changed */\n+\t\t\t/* attitude changed */\n \t\t\torb_copy(ORB_ID(vehicle_attitude), attitude_sub, &attitude);\n \t\t}\n \n-\t\t//update condition_global_position_valid\n-\t\t//Global positions are only published by the estimators if they are valid\n-\t\tif (hrt_absolute_time() - global_position.timestamp > POSITION_TIMEOUT) {\n-\t\t\t//We have had no good fix for POSITION_TIMEOUT amount of time\n-\t\t\tif (status_flags.condition_global_position_valid) {\n-\t\t\t\tset_tune_override(TONE_GPS_WARNING_TUNE);\n-\t\t\t\tstatus_changed = true;\n-\t\t\t\tstatus_flags.condition_global_position_valid = false;\n-\t\t\t}\n-\t\t} else if (global_position.timestamp != 0) {\n-\t\t\t// Got good global position estimate\n-\t\t\tif (!status_flags.condition_global_position_valid) {\n-\t\t\t\tstatus_changed = true;\n-\t\t\t\tstatus_flags.condition_global_position_valid = true;\n-\t\t\t}\n-\t\t}\n-\n-\t\t/* update condition_local_position_valid and condition_local_altitude_valid */\n-\t\t/* hysteresis for EPH */\n-\t\tbool local_eph_good;\n-\n-\t\tif (status_flags.condition_local_position_valid) {\n-\t\t\tif (local_position.eph > eph_threshold * 2.5f) {\n-\t\t\t\tlocal_eph_good = false;\n-\n-\t\t\t} else {\n-\t\t\t\tlocal_eph_good = true;\n-\t\t\t}\n-\n-\t\t} else {\n-\t\t\tif (local_position.eph < eph_threshold) {\n-\t\t\t\tlocal_eph_good = true;\n-\n-\t\t\t} else {\n-\t\t\t\tlocal_eph_good = false;\n-\t\t\t}\n-\t\t}\n-\n-\t\tcheck_valid(local_position.timestamp, POSITION_TIMEOUT, local_position.xy_valid\n-\t\t\t    && local_eph_good, &(status_flags.condition_local_position_valid), &status_changed);\n+\t\t/* update condition_local_altitude_valid */\n \t\tcheck_valid(local_position.timestamp, POSITION_TIMEOUT, local_position.z_valid,\n \t\t\t    &(status_flags.condition_local_altitude_valid), &status_changed);\n \n@@ -2203,6 +2197,14 @@ int commander_thread_main(int argc, char *argv[])\n \t\t\t\t} else {\n \t\t\t\t\tmavlink_and_console_log_info(&mavlink_log_pub, \"Takeoff detected\");\n \t\t\t\t\thave_taken_off_since_arming = true;\n+\n+\t\t\t\t\t// Set all position and velocity test probation durations to takeoff value\n+\t\t\t\t\t// This is a larger value to give the vehicle time to complete a failsafe landing\n+\t\t\t\t\t// if faulty sensors cause loss of navigatio shortly after takeoff.\n+\t\t\t\t\tgpos_probation_time_us = POSVEL_PROBATION_TAKEOFF;\n+\t\t\t\t\tgvel_probation_time_us = POSVEL_PROBATION_TAKEOFF;\n+\t\t\t\t\tlpos_probation_time_us = POSVEL_PROBATION_TAKEOFF;\n+\t\t\t\t\tlvel_probation_time_us = POSVEL_PROBATION_TAKEOFF;\n \t\t\t\t}\n \t\t\t}\n \n@@ -2414,12 +2416,8 @@ int commander_thread_main(int argc, char *argv[])\n \t\t}\n \n \t\t/*\n-\t\t * Check for valid position information.\n-\t\t *\n-\t\t * If the system has a valid position source from an onboard\n-\t\t * position estimator, it is safe to operate it autonomously.\n-\t\t * The flag_vector_flight_mode_ok flag indicates that a minimum\n-\t\t * set of position measurements is available.\n+\t\t * Check GPS fix quality. Note that this check augments the position validity\n+\t\t * checks and adds an additional level of protection.\n \t\t */\n \n \t\torb_check(gps_sub, &updated);\n@@ -2454,6 +2452,7 @@ int commander_thread_main(int argc, char *argv[])\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\t// Check fix type and data freshness\n \t\t\tif (gps_position.fix_type >= 3 && hrt_elapsed_time(&gps_position.timestamp) < FAILSAFE_DEFAULT_TIMEOUT) {\n \t\t\t\t/* handle the case where gps was regained */\n \t\t\t\tif (status_flags.gps_failure && !gpsIsNoisy) {\n@@ -2469,6 +2468,7 @@ int commander_thread_main(int argc, char *argv[])\n \t\t\t\tstatus_changed = true;\n \t\t\t\tmavlink_log_critical(&mavlink_log_pub, \"GPS fix lost\");\n \t\t\t}\n+\n \t\t}\n \n \t\t/* start mission result check */\n@@ -2797,7 +2797,7 @@ int commander_thread_main(int argc, char *argv[])\n \n \t\t\t/* evaluate the main state machine according to mode switches */\n \t\t\tbool first_rc_eval = (_last_sp_man.timestamp == 0) && (sp_man.timestamp > 0);\n-\t\t\ttransition_result_t main_res = set_main_state_rc(&status);\n+\t\t\ttransition_result_t main_res = set_main_state_rc(&status, &global_position, &local_position, &status_changed);\n \n \t\t\t/* store last position lock state */\n \t\t\t_last_condition_global_position_valid = status_flags.condition_global_position_valid;\n@@ -2968,7 +2968,7 @@ int commander_thread_main(int argc, char *argv[])\n \n \t\t\t/* handle it */\n \t\t\tif (handle_command(&status, &safety, &cmd, &armed, &_home, &global_position, &local_position,\n-\t\t\t\t\t&attitude, &home_pub, &command_ack_pub, &command_ack, &_roi, &roi_pub)) {\n+\t\t\t\t\t&attitude, &home_pub, &command_ack_pub, &command_ack, &_roi, &roi_pub, &status_changed)) {\n \t\t\t\tstatus_changed = true;\n \t\t\t}\n \t\t}\n@@ -3237,6 +3237,7 @@ get_circuit_breaker_params()\n \tstatus_flags.circuit_breaker_engaged_enginefailure_check = circuit_breaker_enabled(\"CBRK_ENGINEFAIL\", CBRK_ENGINEFAIL_KEY);\n \tstatus_flags.circuit_breaker_engaged_gpsfailure_check = circuit_breaker_enabled(\"CBRK_GPSFAIL\", CBRK_GPSFAIL_KEY);\n \tstatus_flags.circuit_breaker_flight_termination_disabled = circuit_breaker_enabled(\"CBRK_FLIGHTTERM\", CBRK_FLIGHTTERM_KEY);\n+\tstatus_flags.circuit_breaker_engaged_posfailure_check = circuit_breaker_enabled(\"CBRK_VELPOSERR\", CBRK_VELPOSERR_KEY);\n }\n \n void\n@@ -3377,7 +3378,7 @@ control_status_leds(vehicle_status_s *status_local, const actuator_armed_s *actu\n }\n \n transition_result_t\n-set_main_state_rc(struct vehicle_status_s *status_local)\n+set_main_state_rc(struct vehicle_status_s *status_local, vehicle_global_position_s *global_position, vehicle_local_position_s *local_position, bool *changed)\n {\n \t/* set main state according to RC switches */\n \ttransition_result_t res = TRANSITION_DENIED;\n@@ -3426,6 +3427,10 @@ set_main_state_rc(struct vehicle_status_s *status_local)\n \n \t_last_sp_man = sp_man;\n \n+\t// reset the position and velocity validity calculation to give the best change of being able to select\n+\t// the desired mode\n+\treset_posvel_validity(global_position, local_position, changed);\n+\n \t/* offboard switch overrides main switch */\n \tif (sp_man.offboard_switch == manual_control_setpoint_s::SWITCH_POS_ON) {\n \t\tres = main_state_transition(status_local, commander_state_s::MAIN_STATE_OFFBOARD, main_state_prev, &status_flags, &internal_state);\n@@ -3751,6 +3756,216 @@ set_main_state_rc(struct vehicle_status_s *status_local)\n \treturn res;\n }\n \n+void\n+reset_posvel_validity(vehicle_global_position_s *global_position, vehicle_local_position_s *local_position, bool *changed)\n+{\n+\t// reset all the check probation times back to the minimum value\n+\tgpos_probation_time_us = POSVEL_PROBATION_MIN;\n+\tgvel_probation_time_us = POSVEL_PROBATION_MIN;\n+\tlpos_probation_time_us = POSVEL_PROBATION_MIN;\n+\tlvel_probation_time_us = POSVEL_PROBATION_MIN;\n+\n+\t// recheck validity\n+\tcheck_global_posvel_validity(global_position, changed);\n+\tcheck_local_posvel_validity(local_position, changed);\n+}\n+\n+void\n+check_global_posvel_validity(vehicle_global_position_s *global_position, bool *changed)\n+{\n+\tbool global_pos_inaccurate = false;\n+\tbool global_vel_inaccurate = false;\n+\tbool hold_fail_state = false;\n+\n+\t// Check position accuracy with hysteresis in both test level and time\n+\tbool pos_status_changed = false;\n+\tif (status_flags.condition_global_position_valid && global_position->eph > eph_threshold * 2.5f) {\n+\t\tglobal_pos_inaccurate = true;\n+\t\tpos_status_changed = true;\n+\t\tlast_gpos_fail_time_us = hrt_absolute_time();\n+\t} else if (!status_flags.condition_global_position_valid) {\n+\t\tbool level_check_pass = global_position->eph < eph_threshold;\n+\t\tif (!level_check_pass || hold_fail_state) {\n+\t\t\tgpos_probation_time_us += (hrt_absolute_time() - last_gpos_fail_time_us) * POSVEL_VALID_PROBATION_FACTOR;\n+\t\t\tlast_gpos_fail_time_us = hrt_absolute_time();\n+\t\t} else if (hrt_absolute_time() - last_gpos_fail_time_us > gpos_probation_time_us) {\n+\t\t\tglobal_pos_inaccurate = false;\n+\t\t\tpos_status_changed = true;\n+\t\t\tlast_gpos_fail_time_us = 0;\n+\t\t}\n+\t} else {\n+\t\tgpos_probation_time_us -= (hrt_absolute_time() - last_gpos_fail_time_us);\n+\t\tlast_gpos_fail_time_us = hrt_absolute_time();\n+\t}\n+\n+\t// check global velocity accuracy with hysteresis in both test level and time\n+\tbool vel_status_changed = false;\n+\tif (status_flags.condition_global_velocity_valid && global_position->evh > evh_threshold * 2.5f) {\n+\t\tglobal_vel_inaccurate = true;\n+\t\tvel_status_changed = true;\n+\t\tlast_gvel_fail_time_us = hrt_absolute_time();\n+\t} else if (!status_flags.condition_global_velocity_valid) {\n+\t\tbool check_level_pass = global_position->evh < evh_threshold;\n+\t\tif (!check_level_pass || hold_fail_state) {\n+\t\t\tgvel_probation_time_us += (hrt_absolute_time() - last_gvel_fail_time_us) * POSVEL_VALID_PROBATION_FACTOR;\n+\t\t\tlast_gvel_fail_time_us = hrt_absolute_time();\n+\t\t} else if (hrt_absolute_time() - last_gvel_fail_time_us > gvel_probation_time_us) {\n+\t\t\tglobal_vel_inaccurate = false;\n+\t\t\tvel_status_changed = true;\n+\t\t\tlast_gvel_fail_time_us = 0;\n+\t\t}\n+\t} else {\n+\t\tgvel_probation_time_us -= (hrt_absolute_time() - last_gvel_fail_time_us);\n+\t\tlast_gvel_fail_time_us = hrt_absolute_time();\n+\t}\n+\n+\tbool global_data_stale = (hrt_absolute_time() - global_position->timestamp > POSITION_TIMEOUT);\n+\n+\t// Set global velocity validity\n+\tif (vel_status_changed) {\n+\t\tif (status_flags.condition_global_velocity_valid\n+\t\t\t   && (global_data_stale || global_vel_inaccurate)) {\n+\t\t\tstatus_flags.condition_global_position_valid = false;\n+\t\t\t*changed = true;\n+\t\t} else if (!status_flags.condition_global_velocity_valid\n+\t\t\t   && !global_data_stale\n+\t\t\t   && !global_vel_inaccurate) {\n+\t\t\tstatus_flags.condition_global_velocity_valid = true;\n+\t\t\t*changed = true;\n+\t\t}\n+\t}\n+\n+\t// Set global position validity\n+\tif (pos_status_changed) {\n+\t\tif (status_flags.condition_global_position_valid\n+\t\t\t   && (global_data_stale || global_pos_inaccurate)) {\n+\t\t\tstatus_flags.condition_global_position_valid = false;\n+\t\t\tset_tune_override(TONE_GPS_WARNING_TUNE);\n+\t\t\t*changed = true;\n+\t\t} else if (!status_flags.condition_global_position_valid\n+\t\t\t   && !global_data_stale\n+\t\t\t   && !global_pos_inaccurate) {\n+\t\t\tstatus_flags.condition_global_position_valid = true;\n+\t\t\t*changed = true;\n+\t\t}\n+\t}\n+\n+\t// constrain probation times\n+\tif (land_detector.landed) {\n+\t\tgpos_probation_time_us = POSVEL_PROBATION_MIN;\n+\t\tgvel_probation_time_us = POSVEL_PROBATION_MIN;\n+\t} else {\n+\t\tif (gpos_probation_time_us < POSVEL_PROBATION_MIN) {\n+\t\t\tgpos_probation_time_us = POSVEL_PROBATION_MIN;\n+\t\t} else if  (gpos_probation_time_us > POSVEL_PROBATION_MAX) {\n+\t\t\tgpos_probation_time_us = POSVEL_PROBATION_MAX;\n+\t\t}\n+\t\tif (gvel_probation_time_us < POSVEL_PROBATION_MIN) {\n+\t\t\tgvel_probation_time_us = POSVEL_PROBATION_MIN;\n+\t\t} else if  (gvel_probation_time_us > POSVEL_PROBATION_MAX) {\n+\t\t\tgvel_probation_time_us = POSVEL_PROBATION_MAX;\n+\t\t}\n+\t}\n+}\n+\n+void\n+check_local_posvel_validity(struct vehicle_local_position_s *local_position, bool *changed)\n+{\n+\tbool local_pos_inaccurate = false;\n+\tbool local_vel_inaccurate = false;\n+\tbool hold_fail_state = false;\n+\n+\t// Check local position accuracy with hysteresis in both test level and time\n+\tbool pos_status_changed = false;\n+\tif (status_flags.condition_local_position_valid && local_position->eph > eph_threshold * 2.5f) {\n+\t\tlocal_pos_inaccurate = true;\n+\t\tpos_status_changed = true;\n+\t\tlast_lpos_fail_time_us = hrt_absolute_time();\n+\t} else if (!status_flags.condition_local_position_valid) {\n+\t\tbool level_check_pass = local_position->xy_valid && local_position->eph < eph_threshold;\n+\t\tif (!level_check_pass || hold_fail_state) {\n+\t\t\tlpos_probation_time_us += (hrt_absolute_time() - last_lpos_fail_time_us) * POSVEL_VALID_PROBATION_FACTOR;\n+\t\t\tlast_lpos_fail_time_us = hrt_absolute_time();\n+\t\t} else if (hrt_absolute_time() - last_lpos_fail_time_us > lpos_probation_time_us) {\n+\t\t\tlocal_pos_inaccurate = false;\n+\t\t\tpos_status_changed = true;\n+\t\t\tlast_lpos_fail_time_us = 0;\n+\t\t}\n+\t} else {\n+\t\tlpos_probation_time_us -= (hrt_absolute_time() - last_lpos_fail_time_us);\n+\t\tlast_lpos_fail_time_us = hrt_absolute_time();\n+\t}\n+\n+\t// Check local velocity accuracy with hysteresis\n+\tbool vel_status_changed = false;\n+\tif (status_flags.condition_local_velocity_valid && local_position->evh > evh_threshold * 2.5f) {\n+\t\tlocal_vel_inaccurate = true;\n+\t\tvel_status_changed = true;\n+\t\tlast_lvel_fail_time_us =  hrt_absolute_time();\n+\t} else if (!status_flags.condition_local_velocity_valid) {\n+\t\tbool level_check_pass = local_position->v_xy_valid && local_position->evh < evh_threshold;\n+\t\tif (!level_check_pass || hold_fail_state) {\n+\t\t\tlvel_probation_time_us += (hrt_absolute_time() - last_lvel_fail_time_us) * POSVEL_VALID_PROBATION_FACTOR;\n+\t\t\tlast_lvel_fail_time_us =  hrt_absolute_time();\n+\t\t} else if (hrt_absolute_time() - last_lvel_fail_time_us > lvel_probation_time_us) {\n+\t\t\tlocal_vel_inaccurate = false;\n+\t\t\tvel_status_changed = true;\n+\t\t\tlast_lvel_fail_time_us = 0;\n+\t\t}\n+\t} else {\n+\t\tlvel_probation_time_us -= (hrt_absolute_time() - last_lvel_fail_time_us);\n+\t\tlast_lvel_fail_time_us =  hrt_absolute_time();\n+\t}\n+\n+\tbool local_data_stale = (hrt_absolute_time() - local_position->timestamp > POSITION_TIMEOUT);\n+\n+\t// Set local velocity validity\n+\tif (vel_status_changed) {\n+\t\tif (status_flags.condition_local_velocity_valid\n+\t\t\t   && (local_data_stale || local_vel_inaccurate)) {\n+\t\t\tstatus_flags.condition_local_velocity_valid = false;\n+\t\t\t*changed = true;\n+\t\t} else if (!status_flags.condition_local_velocity_valid\n+\t\t\t   && !local_data_stale\n+\t\t\t   && !local_vel_inaccurate) {\n+\t\t\tstatus_flags.condition_local_velocity_valid = true;\n+\t\t\t*changed = true;\n+\t\t}\n+\t}\n+\n+\t// Set local position validity\n+\tif (pos_status_changed) {\n+\t\tif (status_flags.condition_local_position_valid\n+\t\t\t   && (local_data_stale || !local_position->xy_valid || local_pos_inaccurate)) {\n+\t\t\tstatus_flags.condition_local_position_valid = false;\n+\t\t\t*changed = true;\n+\t\t} else if (!status_flags.condition_local_position_valid\n+\t\t\t   && !local_data_stale\n+\t\t\t   && !local_pos_inaccurate\n+\t\t\t   && local_position->xy_valid) {\n+\t\t\tstatus_flags.condition_local_position_valid = true;\n+\t\t\t*changed = true;\n+\t\t}\n+\t}\n+\n+\t// constrain probation times\n+\tif (land_detector.landed) {\n+\t\tlpos_probation_time_us = POSVEL_PROBATION_MIN;\n+\t\tlvel_probation_time_us = POSVEL_PROBATION_MIN;\n+\t} else {\n+\t\tif (lpos_probation_time_us < POSVEL_PROBATION_MIN) {\n+\t\t\tlpos_probation_time_us = POSVEL_PROBATION_MIN;\n+\t\t} else if  (lpos_probation_time_us > POSVEL_PROBATION_MAX) {\n+\t\t\tlpos_probation_time_us = POSVEL_PROBATION_MAX;\n+\t\t}\n+\t\tif (lvel_probation_time_us < POSVEL_PROBATION_MIN) {\n+\t\t\tlvel_probation_time_us = POSVEL_PROBATION_MIN;\n+\t\t} else if  (lvel_probation_time_us > POSVEL_PROBATION_MAX) {\n+\t\t\tlvel_probation_time_us = POSVEL_PROBATION_MAX;\n+\t\t}\n+\t}\n+}\n+\n void\n set_control_mode()\n {"},{"sha":"d5bcdbe89754d9cbcac97e48f4d1d89df50492df","filename":"src/modules/commander/state_machine_helper.cpp","status":"modified","additions":65,"deletions":60,"changes":125,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/8ea0b2d3c51a48a7f45440583301f04e52665b02/src%2Fmodules%2Fcommander%2Fstate_machine_helper.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/8ea0b2d3c51a48a7f45440583301f04e52665b02/src%2Fmodules%2Fcommander%2Fstate_machine_helper.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fcommander%2Fstate_machine_helper.cpp?ref=8ea0b2d3c51a48a7f45440583301f04e52665b02","patch":"@@ -69,8 +69,8 @@ static const char reason_no_offboard[] = \"no offboard\";\n static const char reason_no_rc_and_no_offboard[] = \"no RC and no offboard\";\n static const char reason_no_gps[] = \"no gps\";\n static const char reason_no_gps_cmd[] = \"no gps cmd\";\n-static const char reason_no_home[] = \"no home\";\n static const char reason_no_local_position[] = \"no local position\";\n+static const char reason_no_global_position[] = \"no global position\";\n static const char reason_no_datalink[] = \"no datalink\";\n \n // This array defines the arming state transitions. The rows are the new state, and the columns\n@@ -622,18 +622,10 @@ bool set_nav_state(struct vehicle_status_s *status,\n \t\t\t\t * this enables POSCTL using e.g. flow.\n \t\t\t\t * For fixedwing, a global position is needed. */\n \n-\t\t\t} else if (((status->is_rotary_wing && !status_flags->condition_local_position_valid) ||\n-\t\t\t\t    (!status->is_rotary_wing && !status_flags->condition_global_position_valid))\n-\t\t\t\t   && is_armed) {\n-\t\t\t\tenable_failsafe(status, old_failsafe, mavlink_log_pub, reason_no_rc);\n-\n-\t\t\t\tif (status_flags->condition_local_altitude_valid) {\n-\t\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_ALTCTL;\n-\n-\t\t\t\t} else {\n-\t\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_STAB;\n-\t\t\t\t}\n-\n+\t\t\t} else if (is_armed && check_invalid_pos_nav_state(status, old_failsafe, mavlink_log_pub, status_flags, true, !status->is_rotary_wing)) {\n+\t\t\t\t// nothing to do - everything done in check_invalid_pos_nav_state\n+\t\t\t} else if (is_armed && check_invalid_pos_nav_state(status, old_failsafe, mavlink_log_pub, status_flags, true, status->is_rotary_wing)) {\n+\t\t\t\t// nothing to do - everything done in check_invalid_pos_nav_state\n \t\t\t} else {\n \t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_POSCTL;\n \t\t\t}\n@@ -671,6 +663,8 @@ bool set_nav_state(struct vehicle_status_s *status,\n \t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_DESCEND;\n \t\t\tenable_failsafe(status, old_failsafe, mavlink_log_pub, reason_no_gps);\n \n+\t\t} else if (is_armed && check_invalid_pos_nav_state(status, old_failsafe, mavlink_log_pub, status_flags, false, true)) {\n+\t\t\t// nothing to do - everything done in check_invalid_pos_nav_state\n \t\t} else if (status->engine_failure) {\n \t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_AUTO_LANDENGFAIL;\n \n@@ -720,6 +714,8 @@ bool set_nav_state(struct vehicle_status_s *status,\n \t\t\t/* also go into failsafe if just datalink is lost, and we're actually in air */\n \n \t\t\tenable_failsafe(status, old_failsafe, mavlink_log_pub, reason_no_datalink);\n+\t\t} else if (is_armed && check_invalid_pos_nav_state(status, old_failsafe, mavlink_log_pub, status_flags, false, true)) {\n+\t\t\t// nothing to do - everything done in check_invalid_pos_nav_state\n \t\t} else if (status->data_link_lost && data_link_loss_act_configured && !landed) {\n \n \t\t\tset_data_link_loss_nav_state(status, armed, status_flags, data_link_loss_act);\n@@ -756,20 +752,8 @@ bool set_nav_state(struct vehicle_status_s *status,\n \t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_DESCEND;\n \t\t\tenable_failsafe(status, old_failsafe, mavlink_log_pub, reason_no_gps);\n \n-\t\t} else if ((!status_flags->condition_global_position_valid ||\n-\t\t\t    !status_flags->condition_home_position_valid)) {\n-\t\t\tenable_failsafe(status, old_failsafe, mavlink_log_pub, reason_no_home);\n-\n-\t\t\tif (status_flags->condition_local_position_valid) {\n-\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_AUTO_LAND;\n-\n-\t\t\t} else if (status_flags->condition_local_altitude_valid) {\n-\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_DESCEND;\n-\n-\t\t\t} else {\n-\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_TERMINATION;\n-\t\t\t}\n-\n+\t\t} else if (is_armed && check_invalid_pos_nav_state(status, old_failsafe, mavlink_log_pub, status_flags, false, true)) {\n+\t\t\t// nothing to do - everything done in check_invalid_pos_nav_state\n \t\t} else {\n \t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_AUTO_RTL;\n \t\t}\n@@ -783,18 +767,8 @@ bool set_nav_state(struct vehicle_status_s *status,\n \t\tif (status->engine_failure) {\n \t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_AUTO_LANDENGFAIL;\n \n-\t\t} else if (!status_flags->condition_global_position_valid) {\n-\t\t\tenable_failsafe(status, old_failsafe, mavlink_log_pub, reason_no_gps);\n-\n-\t\t\tif (status_flags->condition_local_position_valid) {\n-\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_AUTO_LAND;\n-\n-\t\t\t} else if (status_flags->condition_local_altitude_valid) {\n-\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_DESCEND;\n-\n-\t\t\t} else {\n-\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_TERMINATION;\n-\t\t\t}\n+\t\t} else if (is_armed && check_invalid_pos_nav_state(status, old_failsafe, mavlink_log_pub, status_flags, false, true)) {\n+\t\t\t// nothing to do - everything done in check_invalid_pos_nav_state\n \n \t\t} else {\n \t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_AUTO_FOLLOW_TARGET;\n@@ -809,18 +783,8 @@ bool set_nav_state(struct vehicle_status_s *status,\n \t\tif (status->engine_failure) {\n \t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_AUTO_LANDENGFAIL;\n \n-\t\t} else if (!status_flags->condition_local_position_valid) {\n-\t\t\tenable_failsafe(status, old_failsafe, mavlink_log_pub, reason_no_local_position);\n-\n-\t\t\tif (status_flags->condition_local_position_valid) {\n-\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_AUTO_LAND;\n-\n-\t\t\t} else if (status_flags->condition_local_altitude_valid) {\n-\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_DESCEND;\n-\n-\t\t\t} else {\n-\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_TERMINATION;\n-\t\t\t}\n+\t\t} else if (is_armed && check_invalid_pos_nav_state(status, old_failsafe, mavlink_log_pub, status_flags, false, false)) {\n+\t\t\t// nothing to do - everything done in check_invalid_pos_nav_state\n \n \t\t} else {\n \t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_AUTO_TAKEOFF;\n@@ -835,15 +799,8 @@ bool set_nav_state(struct vehicle_status_s *status,\n \t\tif (status->engine_failure) {\n \t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_AUTO_LANDENGFAIL;\n \n-\t\t} else if (!status_flags->condition_local_position_valid) {\n-\t\t\tenable_failsafe(status, old_failsafe, mavlink_log_pub, reason_no_local_position);\n-\n-\t\t\tif (status_flags->condition_local_altitude_valid) {\n-\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_DESCEND;\n-\n-\t\t\t} else {\n-\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_TERMINATION;\n-\t\t\t}\n+\t\t} else if (is_armed && check_invalid_pos_nav_state(status, old_failsafe, mavlink_log_pub, status_flags, false, false)) {\n+\t\t\t// nothing to do - everything done in check_invalid_pos_nav_state\n \n \t\t} else {\n \t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_AUTO_LAND;\n@@ -945,6 +902,54 @@ void set_rc_loss_nav_state(struct vehicle_status_s *status,\n \tset_link_loss_nav_state(status, armed, status_flags, link_loss_act, vehicle_status_s::NAVIGATION_STATE_AUTO_RCRECOVER);\n }\n \n+bool check_invalid_pos_nav_state(struct vehicle_status_s *status,\n+\t\t\t       bool old_failsafe,\n+\t\t\t       orb_advert_t *mavlink_log_pub,\n+\t\t\t       status_flags_s *status_flags,\n+\t\t\t       const bool use_rc, // true if we can fallback to a mode that uses RC inputs\n+\t\t\t       const bool using_global_pos) // true if the current flight mode requires a global position\n+{\n+\tbool fallback_required = false;\n+\n+\tif (using_global_pos && (!status_flags->condition_global_position_valid || !status_flags->condition_global_velocity_valid)) {\n+\t\tfallback_required = true;\n+\t} else if (!using_global_pos && (!status_flags->condition_local_position_valid || !status_flags->condition_local_velocity_valid)) {\n+\t\tfallback_required = true;\n+\t}\n+\n+\tif (fallback_required) {\n+\t\tif (use_rc) {\n+\t\t\t// fallback to a mode that gives the operator stick control\n+\t\t\tif (status->is_rotary_wing && status_flags->condition_local_position_valid) {\n+\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_POSCTL;\n+\t\t\t} else if (status_flags->condition_local_altitude_valid) {\n+\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_ALTCTL;\n+\t\t\t} else {\n+\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_STAB;\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// go into a descent that does not require stick control\n+\t\t\tif (status_flags->condition_local_position_valid) {\n+\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_AUTO_LAND;\n+\t\t\t} else  if (status_flags->condition_local_altitude_valid) {\n+\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_DESCEND;\n+\t\t\t} else {\n+\t\t\t\tstatus->nav_state = vehicle_status_s::NAVIGATION_STATE_TERMINATION;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (using_global_pos) {\n+\t\t\tenable_failsafe(status, old_failsafe, mavlink_log_pub, reason_no_global_position);\n+\t\t} else {\n+\t\t\tenable_failsafe(status, old_failsafe, mavlink_log_pub, reason_no_local_position);\n+\t\t}\n+\n+\t}\n+\n+\treturn fallback_required;\n+\n+}\n+\n void set_data_link_loss_nav_state(struct vehicle_status_s *status,\n \t\t\t\t  struct actuator_armed_s *armed,\n \t\t\t\t  status_flags_s *status_flags,"},{"sha":"d62abcf5b635d1991420abbec011b3642213e866","filename":"src/modules/commander/state_machine_helper.h","status":"modified","additions":18,"deletions":5,"changes":23,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/8ea0b2d3c51a48a7f45440583301f04e52665b02/src%2Fmodules%2Fcommander%2Fstate_machine_helper.h","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/8ea0b2d3c51a48a7f45440583301f04e52665b02/src%2Fmodules%2Fcommander%2Fstate_machine_helper.h","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fcommander%2Fstate_machine_helper.h?ref=8ea0b2d3c51a48a7f45440583301f04e52665b02","patch":"@@ -71,13 +71,15 @@ enum class link_loss_actions_t {\n struct status_flags_s {\n     bool condition_calibration_enabled;\n     bool condition_system_sensors_initialized;\n-    bool condition_system_prearm_error_reported;        // true if errors have already been reported\n-    bool condition_system_hotplug_timeout;                // true if the hotplug sensor search is over\n+    bool condition_system_prearm_error_reported;\t// true if errors have already been reported\n+    bool condition_system_hotplug_timeout;\t\t// true if the hotplug sensor search is over\n     bool condition_system_returned_to_home;\n     bool condition_auto_mission_available;\n-    bool condition_global_position_valid;                // set to true by the commander app if the quality of the position estimate is good enough to use it for navigation\n-    bool condition_home_position_valid;                // indicates a valid home position (a valid home position is not always a valid launch)\n-    bool condition_local_position_valid;\n+    bool condition_global_position_valid;\t\t// set to true by the commander app if the quality of the global position estimate is good enough to use for navigation\n+    bool condition_global_velocity_valid;\t\t// set to true by the commander app if the quality of the global horizontal velocity data is good enough to use for navigation\n+    bool condition_home_position_valid;\t\t\t// indicates a valid home position (a valid home position is not always a valid launch)\n+    bool condition_local_position_valid;\t\t// set to true by the commander app if the quality of the local position estimate is good enough to use for navigation\n+    bool condition_local_velocity_valid;\t\t// set to true by the commander app if the quality of the local horizontal velocity data is good enough to use for navigation\n     bool condition_local_altitude_valid;\n     bool condition_airspeed_valid;                        // set to true by the commander app if there is a valid airspeed measurement available\n     bool condition_power_input_valid;                // set if input power is valid\n@@ -88,6 +90,7 @@ struct status_flags_s {\n     bool circuit_breaker_engaged_gpsfailure_check;\n     bool circuit_breaker_flight_termination_disabled;\n     bool circuit_breaker_engaged_usb_check;\n+    bool circuit_breaker_engaged_posfailure_check;\t// set to true when the position valid checks have been disabled\n     bool offboard_control_signal_found_once;\n     bool offboard_control_signal_lost;\n     bool offboard_control_set_by_command;                // true if the offboard mode was set by a mavlink command and should not be overridden by RC\n@@ -145,6 +148,16 @@ void set_rc_loss_nav_state(struct vehicle_status_s *status,\n \t\t\t   struct actuator_armed_s *armed,\n \t\t\t   status_flags_s *status_flags,\n \t\t\t   const link_loss_actions_t link_loss_act);\n+/*\n+ * Checks the validty of position data aaainst the requirements of the current navigation\n+ * mode and switches mode if position data required is not available.\n+ */\n+bool check_invalid_pos_nav_state(struct vehicle_status_s *status,\n+\t\t\t       bool old_failsafe,\n+\t\t\t       orb_advert_t *mavlink_log_pub,\n+\t\t\t       status_flags_s *status_flags,\n+\t\t\t       const bool use_rc, // true if a mode using RC control can be used as a fallback\n+\t\t\t       const bool using_global_pos); // true when the current mode requires a global position estimate\n \n void set_data_link_loss_nav_state(struct vehicle_status_s *status,\n \t\t\t\t  struct actuator_armed_s *armed,"}]}