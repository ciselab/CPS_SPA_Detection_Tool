{"sha":"810dbbd25b5a1e3a27918d1cd51f3c1059335cc4","node_id":"MDY6Q29tbWl0NTI5ODc5MDo4MTBkYmJkMjViNWExZTNhMjc5MThkMWNkNTFmM2MxMDU5MzM1Y2M0","commit":{"author":{"name":"alexklimaj","email":"alex@arkelectron.com","date":"2021-08-16T01:07:06Z"},"committer":{"name":"Daniel Agar","email":"daniel@agar.ca","date":"2021-08-17T23:38:33Z"},"message":"AFBR mode switching, rate switching, and test","tree":{"sha":"f6ae6931ae9de3c029caf24b5c79ad038857ecac","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/f6ae6931ae9de3c029caf24b5c79ad038857ecac"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/810dbbd25b5a1e3a27918d1cd51f3c1059335cc4","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/810dbbd25b5a1e3a27918d1cd51f3c1059335cc4","html_url":"https://github.com/PX4/PX4-Autopilot/commit/810dbbd25b5a1e3a27918d1cd51f3c1059335cc4","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/810dbbd25b5a1e3a27918d1cd51f3c1059335cc4/comments","author":{"login":"AlexKlimaj","id":2019539,"node_id":"MDQ6VXNlcjIwMTk1Mzk=","avatar_url":"https://avatars.githubusercontent.com/u/2019539?v=4","gravatar_id":"","url":"https://api.github.com/users/AlexKlimaj","html_url":"https://github.com/AlexKlimaj","followers_url":"https://api.github.com/users/AlexKlimaj/followers","following_url":"https://api.github.com/users/AlexKlimaj/following{/other_user}","gists_url":"https://api.github.com/users/AlexKlimaj/gists{/gist_id}","starred_url":"https://api.github.com/users/AlexKlimaj/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/AlexKlimaj/subscriptions","organizations_url":"https://api.github.com/users/AlexKlimaj/orgs","repos_url":"https://api.github.com/users/AlexKlimaj/repos","events_url":"https://api.github.com/users/AlexKlimaj/events{/privacy}","received_events_url":"https://api.github.com/users/AlexKlimaj/received_events","type":"User","site_admin":false},"committer":{"login":"dagar","id":84712,"node_id":"MDQ6VXNlcjg0NzEy","avatar_url":"https://avatars.githubusercontent.com/u/84712?v=4","gravatar_id":"","url":"https://api.github.com/users/dagar","html_url":"https://github.com/dagar","followers_url":"https://api.github.com/users/dagar/followers","following_url":"https://api.github.com/users/dagar/following{/other_user}","gists_url":"https://api.github.com/users/dagar/gists{/gist_id}","starred_url":"https://api.github.com/users/dagar/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dagar/subscriptions","organizations_url":"https://api.github.com/users/dagar/orgs","repos_url":"https://api.github.com/users/dagar/repos","events_url":"https://api.github.com/users/dagar/events{/privacy}","received_events_url":"https://api.github.com/users/dagar/received_events","type":"User","site_admin":false},"parents":[{"sha":"c1f588806af67f0772562ac057ed2e37baaceb82","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/c1f588806af67f0772562ac057ed2e37baaceb82","html_url":"https://github.com/PX4/PX4-Autopilot/commit/c1f588806af67f0772562ac057ed2e37baaceb82"}],"stats":{"total":898,"additions":651,"deletions":247},"files":[{"sha":"22c3105c890dae6b0f7c7a95f339ec3a70e4479e","filename":"src/drivers/distance_sensor/broadcom/afbrs50/AFBRS50.cpp","status":"modified","additions":179,"deletions":31,"changes":210,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/810dbbd25b5a1e3a27918d1cd51f3c1059335cc4/src%2Fdrivers%2Fdistance_sensor%2Fbroadcom%2Fafbrs50%2FAFBRS50.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/810dbbd25b5a1e3a27918d1cd51f3c1059335cc4/src%2Fdrivers%2Fdistance_sensor%2Fbroadcom%2Fafbrs50%2FAFBRS50.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Fdistance_sensor%2Fbroadcom%2Fafbrs50%2FAFBRS50.cpp?ref=810dbbd25b5a1e3a27918d1cd51f3c1059335cc4","patch":"@@ -77,6 +77,9 @@ status_t AFBRS50::measurement_ready_callback(status_t status, void *data)\n \t\t\tif (g_dev) {\n \t\t\t\tg_dev->ProcessMeasurement(data);\n \t\t\t}\n+\n+\t\t} else {\n+\t\t\tPX4_ERR(\"Measurement Ready Callback received error!: %i\", (int)status);\n \t\t}\n \t}\n \n@@ -94,15 +97,23 @@ void AFBRS50::ProcessMeasurement(void *data)\n \t\tif ((evaluate_status == STATUS_OK) && (res.Status == 0)) {\n \t\t\tuint32_t result_mm = res.Bin.Range / (Q9_22_ONE / 1000);\n \t\t\tfloat result_m = static_cast<float>(result_mm) / 1000.f;\n+\t\t\t//int8_t quality = res.Bin.SignalQuality;\n \t\t\tint8_t quality = 100;\n \n+\t\t\t// Signal quality indicates 100% for good signals, 50% and lower for weak signals.\n+\t\t\t// 1% is an errored signal (not reliable). Signal Quality of 0% is unknown.\n+\t\t\t//if (quality == 1) {\n+\t\t\t//\tquality = 0;\n+\t\t\t//}\n+\n \t\t\t// distance quality check\n-\t\t\tif (result_m < _min_distance || result_m > _max_distance) {\n+\t\t\tif (result_m > _max_distance) {\n \t\t\t\tresult_m = 0.0;\n \t\t\t\tquality = 0;\n \t\t\t}\n \n \t\t\t_current_distance = result_m;\n+\t\t\t_current_quality = quality;\n \t\t\t_px4_rangefinder.update(((res.TimeStamp.sec * 1000000ULL) + res.TimeStamp.usec), result_m, quality);\n \t\t}\n \t}\n@@ -135,8 +146,7 @@ int AFBRS50::init()\n \t\tuint8_t a = (value >> 24) & 0xFFU;\n \t\tuint8_t b = (value >> 16) & 0xFFU;\n \t\tuint8_t c = value & 0xFFFFU;\n-\t\tPX4_INFO_RAW(\"AFBR-S50 Chip ID: %\"  PRId32 \", API Version: %\"  PRId32 \" v%\"  PRId8 \".%\"  PRId8 \".%\"  PRId8 \"\\n\", id,\n-\t\t\t     value, a, b, c);\n+\t\tPX4_INFO_RAW(\"AFBR-S50 Chip ID: %u, API Version: %u v%d.%d.%d\\n\", (uint)id, (uint)value, a, b, c);\n \n \t\targus_module_version_t mv = Argus_GetModuleVersion(_hnd);\n \n@@ -157,10 +167,8 @@ int AFBRS50::init()\n \t\t\tbreak;\n \n \t\tcase AFBR_S50LV85D_V1:\n-\t\t\t// Start in short range mode\n-\t\t\tset_mode(ARGUS_MODE_B); // Long: ARGUS_MODE_A, Short: ARGUS_MODE_B\n \t\t\t_min_distance = 0.08f;\n-\t\t\t_max_distance = 80.f;\t// Long: 80m, Short: 30m\n+\t\t\t_max_distance = 30.f;\n \t\t\t_px4_rangefinder.set_min_distance(_min_distance);\n \t\t\t_px4_rangefinder.set_max_distance(_max_distance);\n \t\t\t_px4_rangefinder.set_fov(math::radians(6.f));\n@@ -198,7 +206,13 @@ int AFBRS50::init()\n \t\t\tbreak;\n \t\t}\n \n-\t\t_state = STATE::CONFIGURE;\n+\t\tif (_testing) {\n+\t\t\t_state = STATE::TEST;\n+\n+\t\t} else {\n+\t\t\t_state = STATE::CONFIGURE;\n+\t\t}\n+\n \t\tScheduleDelayed(_measure_interval);\n \t\treturn PX4_OK;\n \t}\n@@ -210,20 +224,46 @@ void AFBRS50::Run()\n {\n \tswitch (_state) {\n \tcase STATE::TEST: {\n-\t\t\tArgus_VerifyHALImplementation(Argus_GetSPISlave(_hnd));\n+\t\t\tif (_testing) {\n+\t\t\t\tArgus_VerifyHALImplementation(Argus_GetSPISlave(_hnd));\n+\t\t\t\t_testing = false;\n \n-\t\t\t_state = STATE::CONFIGURE;\n-\t\t\tScheduleDelayed(100_ms);\n+\t\t\t} else {\n+\t\t\t\t_state = STATE::CONFIGURE;\n+\t\t\t}\n \t\t}\n \t\tbreak;\n \n \tcase STATE::CONFIGURE: {\n-\t\t\tArgus_SetConfigurationFrameTime(_hnd, _measure_interval);\n+\t\t\t//status_t status = Argus_SetConfigurationFrameTime(_hnd, _measure_interval);\n+\t\t\tstatus_t status = set_rate(SHORT_RANGE_MODE_HZ);\n+\n+\t\t\tif (status != STATUS_OK) {\n+\t\t\t\tPX4_ERR(\"CONFIGURE status not okay: %i\", (int)status);\n+\t\t\t\t_state = STATE::STOP;\n+\t\t\t\tScheduleNow();\n+\t\t\t}\n \n-\t\t\tstatus_t status = Argus_StartMeasurementTimer(_hnd, measurement_ready_callback);\n+\t\t\tstatus = Argus_SetConfigurationDFMMode(_hnd, ARGUS_MODE_B, DFM_MODE_8X);\n \n \t\t\tif (status != STATUS_OK) {\n-\t\t\t\tPX4_ERR(\"CONFIGURE status not okay: %\"  PRIi32, status);\n+\t\t\t\tPX4_ERR(\"Argus_SetConfigurationDFMMode status not okay: %i\", (int)status);\n+\t\t\t}\n+\n+\t\t\tstatus = Argus_SetConfigurationDFMMode(_hnd, ARGUS_MODE_A, DFM_MODE_8X);\n+\n+\t\t\tif (status != STATUS_OK) {\n+\t\t\t\tPX4_ERR(\"Argus_SetConfigurationDFMMode status not okay: %i\", (int)status);\n+\t\t\t}\n+\n+\t\t\t// start in short range mode\n+\t\t\t_mode = ARGUS_MODE_B;\n+\t\t\tset_mode(_mode);\n+\n+\t\t\tstatus = Argus_StartMeasurementTimer(_hnd, measurement_ready_callback);\n+\n+\t\t\tif (status != STATUS_OK) {\n+\t\t\t\tPX4_ERR(\"CONFIGURE status not okay: %i\", (int)status);\n \t\t\t\t_state = STATE::STOP;\n \t\t\t\tScheduleNow();\n \n@@ -236,6 +276,8 @@ void AFBRS50::Run()\n \n \tcase STATE::COLLECT: {\n \t\t\t// currently handeled by measurement_ready_callback\n+\n+\t\t\tUpdateMode();\n \t\t}\n \t\tbreak;\n \n@@ -250,31 +292,47 @@ void AFBRS50::Run()\n \t\tbreak;\n \t}\n \n-\tUpdateMode();\n-\n \t// backup schedule\n \tScheduleDelayed(100_ms);\n }\n \n void AFBRS50::UpdateMode()\n {\n \t// only update mode if _current_distance is a valid measurement\n-\tif (_current_distance > 0) {\n+\tif ((_current_distance > 0) && (_current_quality > 0)) {\n \n \t\tif ((_current_distance >= _long_range_threshold) && (_mode != ARGUS_MODE_A)) {\n \t\t\t// change to long range mode\n-\t\t\t_mode = ARGUS_MODE_A;\n-\t\t\tset_mode(_mode);\n-\t\t\t_measure_interval = (1000000 / LONG_RANGE_MODE_HZ);\n-\t\t\tScheduleDelayed(1000_ms); // don't switch again for at least 1 second\n+\t\t\targus_mode_t mode = ARGUS_MODE_A;\n+\t\t\tstatus_t status = set_mode(mode);\n+\n+\t\t\tif (status != STATUS_OK) {\n+\t\t\t\tPX4_ERR(\"set_mode status not okay: %i\", (int)status);\n+\t\t\t}\n+\n+\t\t\tstatus = set_rate(LONG_RANGE_MODE_HZ);\n+\n+\t\t\tif (status != STATUS_OK) {\n+\t\t\t\tPX4_ERR(\"set_rate status not okay: %i\", (int)status);\n+\t\t\t}\n \n \t\t} else if ((_current_distance <= _short_range_threshold) && (_mode != ARGUS_MODE_B)) {\n \t\t\t// change to short range mode\n-\t\t\t_mode = ARGUS_MODE_B;\n-\t\t\tset_mode(_mode);\n-\t\t\t_measure_interval = (1000000 / SHORT_RANGE_MODE_HZ);\n-\t\t\tScheduleDelayed(1000_ms); // don't switch again for at least 1 second\n+\t\t\targus_mode_t mode = ARGUS_MODE_B;\n+\t\t\tstatus_t status = set_mode(mode);\n+\n+\t\t\tif (status != STATUS_OK) {\n+\t\t\t\tPX4_ERR(\"set_mode status not okay: %i\", (int)status);\n+\t\t\t}\n+\n+\t\t\tstatus = set_rate(SHORT_RANGE_MODE_HZ);\n+\n+\t\t\tif (status != STATUS_OK) {\n+\t\t\t\tPX4_ERR(\"set_rate status not okay: %i\", (int)status);\n+\t\t\t}\n \t\t}\n+\n+\t\tScheduleDelayed(1000_ms); // don't switch again for at least 1 second\n \t}\n }\n \n@@ -284,19 +342,76 @@ void AFBRS50::stop()\n \tScheduleNow();\n }\n \n+int AFBRS50::test()\n+{\n+\t_testing = true;\n+\n+\tinit();\n+\n+\treturn PX4_OK;\n+}\n+\n void AFBRS50::print_info()\n {\n \tperf_print_counter(_sample_perf);\n-\tget_mode();\n+\tget_info();\n+}\n+\n+status_t AFBRS50::set_mode(argus_mode_t mode)\n+{\n+\twhile (Argus_GetStatus(_hnd) != STATUS_IDLE) {\n+\t\tpx4_usleep(1_ms);\n+\t}\n+\n+\tstatus_t status = Argus_SetConfigurationMeasurementMode(_hnd, mode);\n+\n+\tif (status != STATUS_OK) {\n+\t\tPX4_ERR(\"Argus_SetConfigurationMeasurementMode status not okay: %i\", (int)status);\n+\t\treturn status;\n+\t}\n+\n+\targus_mode_t current_mode;\n+\tstatus = Argus_GetConfigurationMeasurementMode(_hnd, &current_mode);\n+\n+\tif (status != STATUS_OK) {\n+\t\tPX4_ERR(\"Argus_GetConfigurationMeasurementMode status not okay: %i\", (int)status);\n+\t\treturn status;\n+\n+\t} else {\n+\t\t_mode = current_mode;\n+\t}\n+\n+\treturn status;\n }\n \n-void AFBRS50::set_mode(argus_mode_t mode)\n+status_t AFBRS50::set_rate(uint32_t rate_hz)\n {\n-\tArgus_SetConfigurationMeasurementMode(_hnd, mode);\n-\tArgus_SetConfigurationDFMMode(_hnd, mode, DFM_MODE_8X);\n+\twhile (Argus_GetStatus(_hnd) != STATUS_IDLE) {\n+\t\tpx4_usleep(1_ms);\n+\t}\n+\n+\tstatus_t status = Argus_SetConfigurationFrameTime(_hnd, (1000000 / rate_hz));\n+\n+\tif (status != STATUS_OK) {\n+\t\tPX4_ERR(\"Argus_SetConfigurationFrameTime status not okay: %i\", (int)status);\n+\t\treturn status;\n+\t}\n+\n+\tuint32_t current_rate;\n+\tstatus = Argus_GetConfigurationFrameTime(_hnd, &current_rate);\n+\n+\tif (status != STATUS_OK) {\n+\t\tPX4_ERR(\"Argus_GetConfigurationFrameTime status not okay: %i\", (int)status);\n+\t\treturn status;\n+\n+\t} else {\n+\t\t_measure_interval = current_rate;\n+\t}\n+\n+\treturn status;\n }\n \n-void AFBRS50::get_mode()\n+void AFBRS50::get_info()\n {\n \targus_mode_t current_mode;\n \targus_dfm_mode_t dfm_mode;\n@@ -306,7 +421,7 @@ void AFBRS50::get_mode()\n \tPX4_INFO_RAW(\"distance: %.3fm\\n\", (double)_current_distance);\n \tPX4_INFO_RAW(\"mode: %d\\n\", current_mode);\n \tPX4_INFO_RAW(\"dfm mode: %d\\n\", dfm_mode);\n-\tPX4_INFO_RAW(\"rate: %d Hz\\n\", (1000000 / _measure_interval));\n+\tPX4_INFO_RAW(\"rate: %u Hz\\n\", (uint)(1000000 / _measure_interval));\n }\n \n namespace afbrs50\n@@ -351,16 +466,44 @@ static int status()\n \n static int stop()\n {\n+\tif (g_dev == nullptr) {\n+\t\tPX4_ERR(\"driver not running\");\n+\t\treturn PX4_ERROR;\n+\t}\n+\n \tif (g_dev != nullptr) {\n \t\tdelete g_dev;\n \t\tg_dev = nullptr;\n-\n \t}\n \n \tPX4_INFO(\"driver stopped\");\n \treturn PX4_OK;\n }\n \n+static int test(const uint8_t rotation)\n+{\n+\tif (g_dev != nullptr) {\n+\t\tPX4_ERR(\"already started\");\n+\t\treturn PX4_ERROR;\n+\t}\n+\n+\tg_dev = new AFBRS50(rotation);\n+\n+\tif (g_dev == nullptr) {\n+\t\tPX4_ERR(\"object instantiate failed\");\n+\t\treturn PX4_ERROR;\n+\t}\n+\n+\tif (g_dev->test() != PX4_OK) {\n+\t\tPX4_ERR(\"driver test failed\");\n+\t\tdelete g_dev;\n+\t\tg_dev = nullptr;\n+\t\treturn PX4_ERROR;\n+\t}\n+\n+\treturn PX4_OK;\n+}\n+\n static int usage()\n {\n \tPRINT_MODULE_DESCRIPTION(\n@@ -382,6 +525,7 @@ Stop driver\n \tPRINT_MODULE_USAGE_COMMAND_DESCR(\"start\", \"Start driver\");\n \tPRINT_MODULE_USAGE_PARAM_STRING('d', nullptr, nullptr, \"Serial device\", false);\n \tPRINT_MODULE_USAGE_PARAM_INT('r', 25, 0, 25, \"Sensor rotation - downward facing by default\", true);\n+\tPRINT_MODULE_USAGE_COMMAND_DESCR(\"test\", \"Test driver\");\n \tPRINT_MODULE_USAGE_COMMAND_DESCR(\"stop\", \"Stop driver\");\n \treturn PX4_OK;\n }\n@@ -421,6 +565,10 @@ extern \"C\" __EXPORT int afbrs50_main(int argc, char *argv[])\n \n \t} else if (!strcmp(argv[myoptind], \"stop\")) {\n \t\treturn afbrs50::stop();\n+\n+\t} else if (!strcmp(argv[myoptind], \"test\")) {\n+\t\treturn afbrs50::test(rotation);\n+\n \t}\n \n \treturn afbrs50::usage();"},{"sha":"f7503b321bfa85a7c948176e809fc62cfda50869","filename":"src/drivers/distance_sensor/broadcom/afbrs50/AFBRS50.hpp","status":"modified","additions":10,"deletions":4,"changes":14,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/810dbbd25b5a1e3a27918d1cd51f3c1059335cc4/src%2Fdrivers%2Fdistance_sensor%2Fbroadcom%2Fafbrs50%2FAFBRS50.hpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/810dbbd25b5a1e3a27918d1cd51f3c1059335cc4/src%2Fdrivers%2Fdistance_sensor%2Fbroadcom%2Fafbrs50%2FAFBRS50.hpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Fdistance_sensor%2Fbroadcom%2Fafbrs50%2FAFBRS50.hpp?ref=810dbbd25b5a1e3a27918d1cd51f3c1059335cc4","patch":"@@ -63,11 +63,15 @@ class AFBRS50 : public px4::ScheduledWorkItem\n \t */\n \tvoid print_info();\n \n-\t/**\n+\t/**50\n \t * Stop the automatic measurement state machine.\n \t */\n \tvoid stop();\n \n+\tint test();\n+\n+\tbool _testing = false;\n+\n private:\n \tvoid Run() override;\n \n@@ -77,8 +81,9 @@ class AFBRS50 : public px4::ScheduledWorkItem\n \n \tstatic status_t measurement_ready_callback(status_t status, void *data);\n \n-\tvoid get_mode();\n-\tvoid set_mode(argus_mode_t mode);\n+\tvoid get_info();\n+\tstatus_t set_mode(argus_mode_t mode);\n+\tstatus_t set_rate(uint32_t rate_hz);\n \n \targus_hnd_t *_hnd{nullptr};\n \targus_mode_t _mode{ARGUS_MODE_B}; // Short-Range\n@@ -96,8 +101,9 @@ class AFBRS50 : public px4::ScheduledWorkItem\n \n \tperf_counter_t _sample_perf{perf_alloc(PC_INTERVAL, MODULE_NAME\": sample interval\")};\n \n-\tint _measure_interval{1000000 / 50}; // 50Hz\n+\tuint32_t _measure_interval{1000000 / 50}; // 50Hz\n \tfloat _current_distance{0};\n+\tint8_t _current_quality{0};\n \tconst float _short_range_threshold = 4.0; //meters\n \tconst float _long_range_threshold = 6.0; //meters\n \tfloat _max_distance;"},{"sha":"8ace56ea92f66a5cdcc590eff0501fad5ec18faf","filename":"src/drivers/distance_sensor/broadcom/afbrs50/API/Src/timer.c","status":"modified","additions":17,"deletions":10,"changes":27,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/810dbbd25b5a1e3a27918d1cd51f3c1059335cc4/src%2Fdrivers%2Fdistance_sensor%2Fbroadcom%2Fafbrs50%2FAPI%2FSrc%2Ftimer.c","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/810dbbd25b5a1e3a27918d1cd51f3c1059335cc4/src%2Fdrivers%2Fdistance_sensor%2Fbroadcom%2Fafbrs50%2FAPI%2FSrc%2Ftimer.c","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Fdistance_sensor%2Fbroadcom%2Fafbrs50%2FAPI%2FSrc%2Ftimer.c?ref=810dbbd25b5a1e3a27918d1cd51f3c1059335cc4","patch":"@@ -9,25 +9,25 @@\n \n static struct hrt_call broadcom_hrt_call = {};\n \n-static timer_cb_t timer_callback_; /*! Callback function for PIT timer */\n+static timer_cb_t timer_callback_ = 0; /*! Callback function for PIT timer */\n \n-static uint32_t period_us_;\n+static uint32_t period_us_ = 1000000 / 1000; // 1000Hz\n+\n+static bool isInitialized_ = false;\n \n /*! Storage for the callback parameter */\n static void *callback_param_;\n \n static void broadcom_hrt_callout(void *arg)\n {\n-\tif (timer_callback_ != 0) {\n+\tif ((timer_callback_ != 0) && (period_us_ != 0) && (isInitialized_ == true)) {\n \t\t//timer_callback_(arg);\n \t\ttimer_callback_(callback_param_);\n \t\thrt_call_after(&broadcom_hrt_call, period_us_, broadcom_hrt_callout, callback_param_);\n-\t}\n-}\n \n-void Timer_Init(void)\n-{\n-\thrt_cancel(&broadcom_hrt_call);\n+\t} else {\n+\t\thrt_cancel(&broadcom_hrt_call);\n+\t}\n }\n \n /*!***************************************************************************\n@@ -72,7 +72,8 @@ status_t Timer_Start(uint32_t period, void *param)\n \tperiod_us_ = period;\n \n \tif (period != 0) {\n-\t\thrt_call_after(&broadcom_hrt_call, period, broadcom_hrt_callout, param);\n+\t\thrt_call_after(&broadcom_hrt_call, period_us_, broadcom_hrt_callout, callback_param_);\n+\t\tisInitialized_ = true;\n \n \t} else {\n \t\thrt_cancel(&broadcom_hrt_call);\n@@ -91,6 +92,7 @@ status_t Timer_Stop(void *param)\n {\n \tperiod_us_ = 0;\n \tcallback_param_ = 0;\n+\tisInitialized_ = false;\n \thrt_cancel(&broadcom_hrt_call);\n \treturn STATUS_OK;\n }\n@@ -111,10 +113,15 @@ status_t Timer_SetInterval(uint32_t dt_microseconds, void *param)\n {\n \tif (dt_microseconds != 0) {\n \t\tperiod_us_ = dt_microseconds;\n-\t\thrt_call_after(&broadcom_hrt_call, dt_microseconds, broadcom_hrt_callout, param);\n+\t\tcallback_param_ = param;\n+\t\tisInitialized_ = true;\n+\t\thrt_call_after(&broadcom_hrt_call, period_us_, broadcom_hrt_callout, callback_param_);\n \n \t} else {\n \t\thrt_cancel(&broadcom_hrt_call);\n+\t\tcallback_param_ = 0;\n+\t\tperiod_us_ = 0;\n+\t\tisInitialized_ = false;\n \t}\n \n \treturn STATUS_OK;"},{"sha":"8b877fa1d4735548313d0758402251d793cbec74","filename":"src/drivers/distance_sensor/broadcom/afbrs50/argus_hal_test.c","status":"modified","additions":347,"deletions":125,"changes":472,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/810dbbd25b5a1e3a27918d1cd51f3c1059335cc4/src%2Fdrivers%2Fdistance_sensor%2Fbroadcom%2Fafbrs50%2Fargus_hal_test.c","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/810dbbd25b5a1e3a27918d1cd51f3c1059335cc4/src%2Fdrivers%2Fdistance_sensor%2Fbroadcom%2Fafbrs50%2Fargus_hal_test.c","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Fdistance_sensor%2Fbroadcom%2Fafbrs50%2Fargus_hal_test.c?ref=810dbbd25b5a1e3a27918d1cd51f3c1059335cc4","patch":"@@ -46,7 +46,8 @@\n #include \"platform/argus_nvm.h\"\n #include \"platform/argus_irq.h\"\n \n-#include <px4_platform_common/micro_hal.h>\n+#include <px4_platform_common/px4_config.h>\n+#include <px4_platform_common/defines.h>\n \n /*******************************************************************************\n  * Definitions\n@@ -64,6 +65,7 @@ static status_t SpiConnectionTest(s2pi_slave_t slave);\n static status_t SpiInterruptTest(s2pi_slave_t slave);\n static status_t GpioModeTest(s2pi_slave_t slave);\n static status_t TimerTest(s2pi_slave_t slave);\n+static status_t PITTest(void);\n \n static status_t CheckTimerCounterValues(uint32_t hct, uint32_t lct);\n static status_t SPITransferSync(s2pi_slave_t slave, uint8_t *data, uint8_t size);\n@@ -73,13 +75,17 @@ static status_t AwaitDataReady(s2pi_slave_t slave, uint32_t timeout_ms);\n static status_t ReadEEPROM(s2pi_slave_t slave, uint8_t *eeprom);\n static status_t ReadRcoTrim(s2pi_slave_t slave, int8_t *RcoTrim);\n static status_t RunMeasurement(s2pi_slave_t slave, uint16_t samples);\n+static status_t RunPITTest(uint32_t exp_dt_us, uint32_t n);\n \n+static void PIT_Callback(void *param);\n static void DataReadyCallback(void *param);\n \n+/// @cond EXTERN\n extern uint32_t EEPROM_ReadChipId(uint8_t const *eeprom);\n extern argus_module_version_t EEPROM_ReadModule(uint8_t const *eeprom);\n extern status_t EEPROM_Read(s2pi_slave_t slave, uint8_t address, uint8_t *data);\n extern uint8_t hamming_decode(uint8_t const *code, uint8_t *data);\n+/// @endcond\n \n /******************************************************************************\n  * Variables\n@@ -93,63 +99,76 @@ status_t Argus_VerifyHALImplementation(s2pi_slave_t spi_slave)\n {\n \tstatus_t status = STATUS_OK;\n \n-\tprint(\"########################################################\\n\");\n-\tprint(\"#   Running HAL Verification Test - \" HAL_TEST_VERSION \"\\n\");\n-\tprint(\"########################################################\\n\\n\");\n+\tPX4_INFO_RAW(\"########################################################\\n\");\n+\tPX4_INFO_RAW(\"#   Running HAL Verification Test - \" HAL_TEST_VERSION \"\\n\");\n+\tPX4_INFO_RAW(\"########################################################\\n\\n\");\n \n-\tprint(\"1 > Timer Plausibility Test\\n\");\n+\tPX4_INFO_RAW(\"1 > Timer Plausibility Test\\n\");\n \tstatus = TimerPlausibilityTest();\n \n \tif (status != STATUS_OK) { goto summary; }\n \n-\tprint(\"1 > PASS\\n\\n\");\n+\tPX4_INFO_RAW(\"1 > PASS\\n\\n\");\n \n-\tprint(\"2 > Timer Wraparound Test\\n\");\n+\tPX4_INFO_RAW(\"2 > Timer Wraparound Test\\n\");\n \tstatus = TimerWraparoundTest();\n \n \tif (status != STATUS_OK) { goto summary; }\n \n-\tprint(\"2 > PASS\\n\\n\");\n+\tPX4_INFO_RAW(\"2 > PASS\\n\\n\");\n \n-\tprint(\"3 > SPI Connection Test\\n\");\n+\tPX4_INFO_RAW(\"3 > SPI Connection Test\\n\");\n \tstatus = SpiConnectionTest(spi_slave);\n \n \tif (status != STATUS_OK) { goto summary; }\n \n-\tprint(\"3 > PASS\\n\\n\");\n+\tPX4_INFO_RAW(\"3 > PASS\\n\\n\");\n \n-\tprint(\"4 > SPI Interrupt Test\\n\");\n+\tPX4_INFO_RAW(\"4 > SPI Interrupt Test\\n\");\n \tstatus = SpiInterruptTest(spi_slave);\n \n \tif (status != STATUS_OK) { goto summary; }\n \n-\tprint(\"4 > PASS\\n\\n\");\n+\tPX4_INFO_RAW(\"4 > PASS\\n\\n\");\n \n-\tprint(\"5 > GPIO Mode Test\\n\");\n+\tPX4_INFO_RAW(\"5 > GPIO Mode Test\\n\");\n \tstatus = GpioModeTest(spi_slave);\n \n \tif (status != STATUS_OK) { goto summary; }\n \n-\tprint(\"5 > PASS\\n\\n\");\n+\tPX4_INFO_RAW(\"5 > PASS\\n\\n\");\n \n-\tprint(\"6 > Timer Test\\n\");\n+\tPX4_INFO_RAW(\"6 > Lifetime Counter Timer (LTC) Test\\n\");\n \tstatus = TimerTest(spi_slave);\n \n \tif (status != STATUS_OK) { goto summary; }\n \n-\tprint(\"6 > PASS\\n\\n\");\n+\tPX4_INFO_RAW(\"6 > PASS\\n\\n\");\n+\n+\tPX4_INFO_RAW(\"7 > Periodic Interrupt Timer (PIT) Test\\n\");\n+\tstatus = PITTest();\n+\n+\tif (status == ERROR_NOT_IMPLEMENTED) {\n+\t\tPX4_INFO_RAW(\"7 > SKIPPED (PIT is not implemented)\\n\\n\");\n+\n+\t} else {\n+\t\tif (status != STATUS_OK) { goto summary; }\n+\n+\t\tPX4_INFO_RAW(\"7 > PASS\\n\\n\");\n+\t}\n+\n \n summary:\n-\tprint(\"########################################################\\n\");\n+\tPX4_INFO_RAW(\"########################################################\\n\");\n \n \tif (status != STATUS_OK) {\n-\t\tprint(\"#   FAIL: HAL Verification Test finished with error %d!\\n\", status);\n+\t\tPX4_INFO_RAW(\"#   FAIL: HAL Verification Test finished with error %d!\\n\", (int)status);\n \n \t} else {\n-\t\tprint(\"#   PASS: HAL Verification Test finished successfully!\\n\");\n+\t\tPX4_INFO_RAW(\"#   PASS: HAL Verification Test finished successfully!\\n\");\n \t}\n \n-\tprint(\"########################################################\\n\\n\");\n+\tPX4_INFO_RAW(\"########################################################\\n\\n\");\n \treturn status;\n }\n \n@@ -158,7 +177,7 @@ status_t Argus_VerifyHALImplementation(s2pi_slave_t spi_slave)\n  *\n  * @details\tThis verifies that the counter values returned from the\n  * \t\t\t#Timer_GetCounterValue function are valid. This means, the low\n- * \t\t\tcounter value \\p lct is within 0 and 999999 μs.\n+ * \t\t\tcounter value \\p lct is within 0 and 999999 µs.\n  *\n  * @return \tReturns the \\link #status_t status\\endlink:\n  * \t\t\t- #STATUS_OK on success.\n@@ -167,10 +186,10 @@ status_t Argus_VerifyHALImplementation(s2pi_slave_t spi_slave)\n static status_t CheckTimerCounterValues(uint32_t hct, uint32_t lct)\n {\n \tif (lct > 999999) {\n-\t\terror_log(\"Timer plausibility check:\\n\"\n-\t\t\t  \"The parameter \\\"lct\\\" of Timer_GetCounterValue() must always \"\n-\t\t\t  \"be within 0 and 999999.\\n\"\n-\t\t\t  \"Current Values: hct = %d, lct = %d\", hct, lct);\n+\t\tPX4_INFO_RAW(\"Timer plausibility check:\\n\"\n+\t\t\t     \"The parameter \\\"lct\\\" of Timer_GetCounterValue() must always \"\n+\t\t\t     \"be within 0 and 999999.\\n\"\n+\t\t\t     \"Current Values: hct = %d, lct = %d\", (uint)hct, (uint)lct);\n \t\treturn ERROR_FAIL;\n \t}\n \n@@ -227,13 +246,13 @@ static status_t TimerPlausibilityTest(void)\n \t/* Either the hct value must have been increased or the lct value if the hct\n \t * value is still the same. */\n \tif (!((hct1 > hct0) || ((hct1 == hct0) && (lct1 > lct0)))) {\n-\t\terror_log(\"Timer plausibility check: the elapsed time could not be \"\n-\t\t\t  \"measured with the Timer_GetCounterValue() function; no time \"\n-\t\t\t  \"has elapsed!\\n\"\n-\t\t\t  \"The delay was induced by the following code:\\n\"\n-\t\t\t  \"for (volatile uint32_t i = 0; i < 100000; ++i) __asm(\\\"nop\\\");\\n\",\n-\t\t\t  \"Current Values: hct0 = %d, lct0 = %d, hct1 = %d, lct1 = %d\",\n-\t\t\t  hct0, lct0, hct1, lct1);\n+\t\tPX4_INFO_RAW(\"Timer plausibility check: the elapsed time could not be \"\n+\t\t\t     \"measured with the Timer_GetCounterValue() function; no time \"\n+\t\t\t     \"has elapsed!\\n\"\n+\t\t\t     \"The delay was induced by the following code:\\n\"\n+\t\t\t     \"for (volatile uint32_t i = 0; i < 100000; ++i) __asm(\\\"nop\\\");\\n\"\n+\t\t\t     \"Current Values: hct0 = %d, lct0 = %d, hct1 = %d, lct1 = %d\",\n+\t\t\t     (uint)hct0, (uint)lct0, (uint)hct1, (uint)lct1);\n \t\treturn ERROR_FAIL;\n \t}\n \n@@ -243,7 +262,7 @@ static status_t TimerPlausibilityTest(void)\n /*!***************************************************************************\n  * @brief\tWraparound Test for the Timer HAL Implementation.\n  *\n- * @details The LTC values must wrap from 999999 μs to 0 μs and increase the\n+ * @details The LTC values must wrap from 999999 µs to 0 µs and increase the\n  *          seconds counter accordingly. This test verifies the correct wrapping\n  *          by consecutively calling the #Timer_GetCounterValue function until\n  *          at least 2 wraparound events have been occurred.\n@@ -283,6 +302,8 @@ static status_t TimerWraparoundTest(void)\n \tuint32_t hct2 = hct0 + n;\n \tuint32_t lct2 = lct0;\n \n+\tpx4_usleep(20000);\n+\n \t/* Periodically read timer values. From previous tests we\n \t * already know the timer value is increasing. */\n \twhile (hct0 < hct2 || lct0 < lct2) {\n@@ -302,16 +323,18 @@ static status_t TimerWraparoundTest(void)\n \t\t * than previous one. */\n \t\tif (!(((hct1 == hct0 + 1) && (lct1 < lct0))\n \t\t      || ((hct1 == hct0) && (lct1 >= lct0)))) {\n-\t\t\terror_log(\"Timer plausibility check: the wraparound of \\\"lct\\\" or \"\n-\t\t\t\t  \"\\\"hct\\\" parameters of the Timer_GetCounterValue() \"\n-\t\t\t\t  \"function was not handled correctly!\\n\"\n-\t\t\t\t  \"Current Values: hct0 = %d, lct0 = %d, hct1 = %d, lct1 = %d\",\n-\t\t\t\t  hct0, lct0, hct1, lct1);\n+\t\t\tPX4_INFO_RAW(\"Timer plausibility check: the wraparound of \\\"lct\\\" or \"\n+\t\t\t\t     \"\\\"hct\\\" parameters of the Timer_GetCounterValue() \"\n+\t\t\t\t     \"function was not handled correctly!\\n\"\n+\t\t\t\t     \"Current Values: hct0 = %d, lct0 = %d, hct1 = %d, lct1 = %d\",\n+\t\t\t\t     (uint)hct0, (uint)lct0, (uint)hct1, (uint)lct1);\n \t\t\treturn ERROR_FAIL;\n \t\t}\n \n \t\thct0 = hct1;\n \t\tlct0 = lct1;\n+\n+\t\tpx4_usleep(20000);\n \t}\n \n \treturn STATUS_OK;\n@@ -352,8 +375,8 @@ static status_t SPITransferSync(s2pi_slave_t slave, uint8_t *data, uint8_t size)\n \tstatus_t status = S2PI_TransferFrame(slave, data, data, size, 0, 0);\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"SPI transfer failed! The call to S2PI_TransferFrame \"\n-\t\t\t  \"yielded error code: %d\", status);\n+\t\tPX4_INFO_RAW(\"SPI transfer failed! The call to S2PI_TransferFrame \"\n+\t\t\t     \"yielded error code: %d\", (int)status);\n \t\treturn status;\n \t}\n \n@@ -367,16 +390,16 @@ static status_t SPITransferSync(s2pi_slave_t slave, uint8_t *data, uint8_t size)\n \t\tstatus = S2PI_GetStatus();\n \n \t\tif (status < STATUS_OK) {\n-\t\t\terror_log(\"SPI transfer failed! The call to S2PI_GetStatus \"\n-\t\t\t\t  \"yielded error code: %d\", status);\n+\t\t\tPX4_INFO_RAW(\"SPI transfer failed! The call to S2PI_GetStatus \"\n+\t\t\t\t     \"yielded error code: %d\", (int)status);\n \t\t\tS2PI_Abort();\n \t\t\treturn status;\n \t\t}\n \n \t\tif (Time_CheckTimeoutMSec(&start, timeout_ms)) {\n-\t\t\terror_log(\"SPI transfer failed! The operation did not finished \"\n-\t\t\t\t  \"within %d ms. This may also be caused by an invalid \"\n-\t\t\t\t  \"timer implementation!\", timeout_ms);\n+\t\t\tPX4_INFO_RAW(\"SPI transfer failed! The operation did not finished \"\n+\t\t\t\t     \"within %u ms. This may also be caused by an invalid \"\n+\t\t\t\t     \"timer implementation!\", (uint)timeout_ms);\n \t\t\treturn ERROR_TIMEOUT;\n \t\t}\n \t} while (status == STATUS_BUSY);\n@@ -425,7 +448,7 @@ static status_t SpiConnectionTest(s2pi_slave_t slave)\n \tstatus = SPITransferSync(slave, data, 17U);\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"SPI connection test failed!\");\n+\t\tPX4_INFO_RAW(\"SPI connection test failed!\");\n \t\treturn status;\n \t}\n \n@@ -437,17 +460,17 @@ static status_t SpiConnectionTest(s2pi_slave_t slave)\n \tstatus = SPITransferSync(slave, data, 17U);\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"SPI connection test failed!\");\n+\t\tPX4_INFO_RAW(\"SPI connection test failed!\");\n \t\treturn status;\n \t}\n \n \t/* Verify the read pattern. */\n \tfor (uint8_t i = 1; i < 17U; ++i) {\n \t\tif (data[i] != i) {\n-\t\t\terror_log(\"SPI connection test failed!\\n\"\n-\t\t\t\t  \"Verification of read data is invalid!\\n\"\n-\t\t\t\t  \"read_data[%d] = %d, but expected was %d\",\n-\t\t\t\t  i, data[i], i);\n+\t\t\tPX4_INFO_RAW(\"SPI connection test failed!\\n\"\n+\t\t\t\t     \"Verification of read data is invalid!\\n\"\n+\t\t\t\t     \"read_data[%d] = %d, but expected was %d\",\n+\t\t\t\t     i, data[i], i);\n \t\t\treturn ERROR_FAIL;\n \t\t}\n \t}\n@@ -468,9 +491,9 @@ static status_t SpiConnectionTest(s2pi_slave_t slave)\n  *****************************************************************************/\n static void DataReadyCallback(void *param)\n {\n-\tirqstate_t irqstate_flags = px4_enter_critical_section();\n+\tIRQ_LOCK();\n \t*((bool *) param) = true;\n-\tpx4_leave_critical_section(irqstate_flags);\n+\tIRQ_UNLOCK();\n }\n \n /*!***************************************************************************\n@@ -510,87 +533,87 @@ static status_t ConfigureDevice(s2pi_slave_t slave, int8_t rcoTrim)\n \tstatus_t status = SPITransferSync(slave, d1, sizeof(d1));\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Device configuration failed!\");\n+\t\tPX4_INFO_RAW(\"Device configuration failed!\");\n \t\treturn status;\n \t}\n \n \tuint8_t d2[] = { 0x16, 0x7F, 0xFF, 0x7F, 0xE9 };\n \tstatus = SPITransferSync(slave, d2, sizeof(d2));\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Device configuration failed!\");\n+\t\tPX4_INFO_RAW(\"Device configuration failed!\");\n \t\treturn status;\n \t}\n \n \tuint8_t d3[] = { 0x18, 0x00, 0x00, 0x03 };\n \tstatus = SPITransferSync(slave, d3, sizeof(d3));\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Device configuration failed!\");\n+\t\tPX4_INFO_RAW(\"Device configuration failed!\");\n \t\treturn status;\n \t}\n \n \tuint8_t d4[] = { 0x10, 0x12 };\n \tstatus = SPITransferSync(slave, d4, sizeof(d4));\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Device configuration failed!\");\n+\t\tPX4_INFO_RAW(\"Device configuration failed!\");\n \t\treturn status;\n \t}\n \n \tuint8_t d5[] = { 0x12, 0x00, 0x2B };\n \tstatus = SPITransferSync(slave, d5, sizeof(d5));\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Device configuration failed!\");\n+\t\tPX4_INFO_RAW(\"Device configuration failed!\");\n \t\treturn status;\n \t}\n \n \tuint8_t d6[] = { 0x08, 0x04, 0x84, 0x10 };\n \tstatus = SPITransferSync(slave, d6, sizeof(d6));\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Device configuration failed!\");\n+\t\tPX4_INFO_RAW(\"Device configuration failed!\");\n \t\treturn status;\n \t}\n \n \tuint8_t d7[] = { 0x0A, 0xFE, 0x51, 0x0F, 0x05 };\n \tstatus = SPITransferSync(slave, d7, sizeof(d7));\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Device configuration failed!\");\n+\t\tPX4_INFO_RAW(\"Device configuration failed!\");\n \t\treturn status;\n \t}\n \n \tuint8_t d8[] = { 0x0C, 0x00, 0x00, 0x00 };\n \tstatus = SPITransferSync(slave, d8, sizeof(d8));\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Device configuration failed!\");\n+\t\tPX4_INFO_RAW(\"Device configuration failed!\");\n \t\treturn status;\n \t}\n \n \tuint8_t d9[] = { 0x1E, 0x00, 0x00, 0x00 };\n \tstatus = SPITransferSync(slave, d9, sizeof(d9));\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Device configuration failed!\");\n+\t\tPX4_INFO_RAW(\"Device configuration failed!\");\n \t\treturn status;\n \t}\n \n \tuint8_t d10[] = { 0x20, 0x01, 0xFF, 0xFF };\n \tstatus = SPITransferSync(slave, d10, sizeof(d10));\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Device configuration failed!\");\n+\t\tPX4_INFO_RAW(\"Device configuration failed!\");\n \t\treturn status;\n \t}\n \n \tuint8_t d11[] = { 0x22, 0xFF, 0xFF, 0x04 };\n \tstatus = SPITransferSync(slave, d11, sizeof(d11));\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Device configuration failed!\");\n+\t\tPX4_INFO_RAW(\"Device configuration failed!\");\n \t\treturn status;\n \t}\n \n@@ -631,7 +654,7 @@ static status_t TriggerMeasurement(s2pi_slave_t slave, uint16_t samples)\n \tstatus_t status = SPITransferSync(slave, d, sizeof(d));\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Trigger measurement failed!\");\n+\t\tPX4_INFO_RAW(\"Trigger measurement failed!\");\n \t\treturn status;\n \t}\n \n@@ -672,8 +695,8 @@ static status_t AwaitDataReady(s2pi_slave_t slave, uint32_t timeout_ms)\n \n \twhile (S2PI_ReadIrqPin(slave)) {\n \t\tif (Time_CheckTimeoutMSec(&start, timeout_ms)) {\n-\t\t\terror_log(\"SPI interrupt test failed! The S2PI_ReadIrqPin did not \"\n-\t\t\t\t  \"determine an pending interrupt within %d ms.\", timeout_ms);\n+\t\t\tPX4_INFO_RAW(\"SPI interrupt test failed! The S2PI_ReadIrqPin did not \"\n+\t\t\t\t     \"determine an pending interrupt within %u ms.\", (uint)timeout_ms);\n \t\t\treturn ERROR_TIMEOUT;\n \t\t}\n \t}\n@@ -740,32 +763,32 @@ static status_t SpiInterruptTest(s2pi_slave_t slave)\n \tstatus_t status = S2PI_SetIrqCallback(slave, DataReadyCallback, (void *)&isDataReady);\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"SPI interrupt test failed! The call to S2PI_SetIrqCallback \"\n-\t\t\t  \"yielded error code: %d\", status);\n+\t\tPX4_INFO_RAW(\"SPI interrupt test failed! The call to S2PI_SetIrqCallback \"\n+\t\t\t     \"yielded error code: %d\", (int)status);\n \t\treturn status;\n \t}\n \n \t/* Check if IRQ is not yet pending. */\n \tif (S2PI_ReadIrqPin(slave) == 0) {\n-\t\terror_log(\"SPI interrupt test failed! The S2PI_ReadIrqPin did \"\n-\t\t\t  \"return 0 but no interrupt is pending since no \"\n-\t\t\t  \"measurements are executed yet!\");\n+\t\tPX4_INFO_RAW(\"SPI interrupt test failed! The S2PI_ReadIrqPin did \"\n+\t\t\t     \"return 0 but no interrupt is pending since no \"\n+\t\t\t     \"measurements are executed yet!\");\n \t\treturn ERROR_FAIL;\n \t};\n \n \t/* Setup Device. */\n \tstatus = ConfigureDevice(slave, 0);\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"SPI interrupt test failed!\");\n+\t\tPX4_INFO_RAW(\"SPI interrupt test failed!\");\n \t\treturn status;\n \t}\n \n \t/* Trigger Measurement. */\n \tstatus = TriggerMeasurement(slave, 0);\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"SPI interrupt test failed!\");\n+\t\tPX4_INFO_RAW(\"SPI interrupt test failed!\");\n \t\treturn status;\n \t}\n \n@@ -776,15 +799,15 @@ static status_t SpiInterruptTest(s2pi_slave_t slave)\n \tstatus = AwaitDataReady(slave, timeout_ms);\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"SPI interrupt test failed!\");\n+\t\tPX4_INFO_RAW(\"SPI interrupt test failed!\");\n \t\treturn status;\n \t}\n \n \t/* Wait for Interrupt using the callback method. */\n \twhile (!isDataReady) {\n \t\tif (Time_CheckTimeoutMSec(&start, timeout_ms)) {\n-\t\t\terror_log(\"SPI interrupt test failed! The IRQ callback was not \"\n-\t\t\t\t  \"invoked within %d ms.\", timeout_ms);\n+\t\t\tPX4_INFO_RAW(\"SPI interrupt test failed! The IRQ callback was not \"\n+\t\t\t\t     \"invoked within %u ms.\", (uint)timeout_ms);\n \t\t\treturn ERROR_TIMEOUT;\n \t\t}\n \t}\n@@ -793,8 +816,8 @@ static status_t SpiInterruptTest(s2pi_slave_t slave)\n \tstatus = S2PI_SetIrqCallback(slave, 0, 0);\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"SPI interrupt test failed! The call to S2PI_SetIrqCallback \"\n-\t\t\t  \"with null pointers yielded error code: %d\", status);\n+\t\tPX4_INFO_RAW(\"SPI interrupt test failed! The call to S2PI_SetIrqCallback \"\n+\t\t\t     \"with null pointers yielded error code: %d\", (int)status);\n \t\treturn status;\n \t}\n \n@@ -832,8 +855,8 @@ static status_t ReadEEPROM(s2pi_slave_t slave, uint8_t *eeprom)\n \tstatus_t status = SPITransferSync(slave, d1, sizeof(d1));\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"EEPROM readout failed (enable EEPROM), \"\n-\t\t\t  \"error code: %d\", status);\n+\t\tPX4_INFO_RAW(\"EEPROM readout failed (enable EEPROM), \"\n+\t\t\t     \"error code: %d\", (int)status);\n \t\treturn status;\n \t}\n \n@@ -844,8 +867,8 @@ static status_t ReadEEPROM(s2pi_slave_t slave, uint8_t *eeprom)\n \t\tstatus = EEPROM_Read(slave, address, &data[address]);\n \n \t\tif (status != STATUS_OK) {\n-\t\t\terror_log(\"EEPROM readout failed @ address 0x%02x, \"\n-\t\t\t\t  \"error code: %d!\", address, status);\n+\t\t\tPX4_INFO_RAW(\"EEPROM readout failed @ address 0x%02x, \"\n+\t\t\t\t     \"error code: %d!\", address, (int)status);\n \t\t\treturn status;\n \t\t}\n \t}\n@@ -855,17 +878,17 @@ static status_t ReadEEPROM(s2pi_slave_t slave, uint8_t *eeprom)\n \tstatus = SPITransferSync(slave, d2, sizeof(d2));\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"EEPROM readout failed (enable EEPROM), \"\n-\t\t\t  \"error code: %d\", status);\n+\t\tPX4_INFO_RAW(\"EEPROM readout failed (enable EEPROM), \"\n+\t\t\t     \"error code: %d\", (int)status);\n \t\treturn status;\n \t}\n \n \t/* Apply Hamming Code */\n \tuint8_t err = hamming_decode(data, eeprom);\n \n \tif (err != 0) {\n-\t\terror_log(\"EEPROM readout failed! Failed to decoding \"\n-\t\t\t  \"Hamming weight (error: %d)!\", err);\n+\t\tPX4_INFO_RAW(\"EEPROM readout failed! Failed to decoding \"\n+\t\t\t     \"Hamming weight (error: %d)!\", err);\n \t\treturn STATUS_ARGUS_EEPROM_BIT_ERROR;\n \t}\n \n@@ -911,29 +934,29 @@ static status_t GpioModeTest(s2pi_slave_t slave)\n \tstatus_t status = ReadEEPROM(slave, eeprom1);\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"GPIO mode test failed (1st attempt)!\");\n+\t\tPX4_INFO_RAW(\"GPIO mode test failed (1st attempt)!\");\n \t\treturn status;\n \t}\n \n \tstatus = ReadEEPROM(slave, eeprom2);\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"GPIO mode test failed (2nd attempt)!\");\n+\t\tPX4_INFO_RAW(\"GPIO mode test failed (2nd attempt)!\");\n \t\treturn status;\n \t}\n \n \tstatus = ReadEEPROM(slave, eeprom3);\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"GPIO mode test failed (3rd attempt)!\");\n+\t\tPX4_INFO_RAW(\"GPIO mode test failed (3rd attempt)!\");\n \t\treturn status;\n \t}\n \n \t/* Verify EEPROM data. */\n \tif ((memcmp(eeprom1, eeprom2, 16) != 0) ||\n \t    (memcmp(eeprom1, eeprom3, 16) != 0)) {\n-\t\terror_log(\"GPIO Mode test failed (data comparison)!\\n\"\n-\t\t\t  \"The data from 3 distinct EEPROM readout does not match!\");\n+\t\tPX4_INFO_RAW(\"GPIO Mode test failed (data comparison)!\\n\"\n+\t\t\t     \"The data from 3 distinct EEPROM readout does not match!\");\n \t\treturn ERROR_FAIL;\n \t}\n \n@@ -942,14 +965,14 @@ static status_t GpioModeTest(s2pi_slave_t slave)\n \targus_module_version_t module = EEPROM_ReadModule(eeprom1);\n \n \tif (chipID == 0 || module == 0) {\n-\t\terror_log(\"GPIO Mode test failed (data verification)!\\n\"\n-\t\t\t  \"Invalid EEPROM data: Module = %d; Chip ID = %d!\", module, chipID);\n+\t\tPX4_INFO_RAW(\"GPIO Mode test failed (data verification)!\\n\"\n+\t\t\t     \"Invalid EEPROM data: Module = %d; Chip ID = %u!\", module, (uint)chipID);\n \t\treturn ERROR_FAIL;\n \t}\n \n-\tprint(\"EEPROM Readout succeeded!\\n\");\n-\tprint(\"- Module: %d\\n\", module);\n-\tprint(\"- Device ID: %d\\n\", chipID);\n+\tPX4_INFO_RAW(\"EEPROM Readout succeeded!\\n\");\n+\tPX4_INFO_RAW(\"- Module: %d\\n\", module);\n+\tPX4_INFO_RAW(\"- Device ID: %u\\n\", (uint)chipID);\n \n \treturn STATUS_OK;\n }\n@@ -997,7 +1020,7 @@ static status_t ReadRcoTrim(s2pi_slave_t slave, int8_t *rcotrim)\n \tcase MODULE_NONE: /* Uncalibrated module; use all 0 data. */\n \tdefault:\n \n-\t\terror_log(\"EEPROM Readout failed! Unknown module number: %d\", module);\n+\t\tPX4_INFO_RAW(\"EEPROM Readout failed! Unknown module number: %d\", module);\n \t\treturn ERROR_ARGUS_UNKNOWN_MODULE;\n \t}\n \n@@ -1036,19 +1059,19 @@ static status_t RunMeasurement(s2pi_slave_t slave, uint16_t samples)\n \tstatus_t status = TriggerMeasurement(slave, samples);\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Speed test failed!\\n\"\n-\t\t\t  \"Call to TransferFrame returned code: %d\",\n-\t\t\t  status);\n+\t\tPX4_INFO_RAW(\"Speed test failed!\\n\"\n+\t\t\t     \"Call to TransferFrame returned code: %d\",\n+\t\t\t     (int)status);\n \t\treturn status;\n \t}\n \n \t/* Wait until the transfer is finished using a timeout. */\n \tstatus = AwaitDataReady(slave, 300);\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Speed test failed!\\n\"\n-\t\t\t  \"SPI Read IRQ pin didn't raised, timeout activated at 200ms, error code: %d\",\n-\t\t\t  status);\n+\t\tPX4_INFO_RAW(\"Speed test failed!\\n\"\n+\t\t\t     \"SPI Read IRQ pin didn't raised, timeout activated at 200ms, error code: %d\",\n+\t\t\t     (int)status);\n \t\treturn status;\n \t}\n \n@@ -1089,7 +1112,7 @@ static status_t TimerTest(s2pi_slave_t slave)\n \t/* Test parameter configuration: *****************************************/\n \tconst int8_t n = 10;\t\t\t\t// The number of measurements.\n \tconst uint32_t ds = 100; \t\t\t// The step size in averaging samples.\n-\tconst float exp_slope = 102.4; \t\t// Expected slope is 102.4 μs / phase / sample\n+\tconst float exp_slope = 102.4; \t\t// Expected slope is 102.4 µs / phase / sample\n \tconst float rel_slope_error = 3e-2; // Relative slope tolerance is 3%.\n \t/*************************************************************************/\n \n@@ -1098,19 +1121,19 @@ static status_t TimerTest(s2pi_slave_t slave)\n \tstatus_t status = ReadRcoTrim(slave, &RcoTrim);\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Timer test failed!\\n\"\n-\t\t\t  \"EEPROM Read test returned code: %d\", status);\n+\t\tPX4_INFO_RAW(\"Timer test failed!\\n\"\n+\t\t\t     \"EEPROM Read test returned code: %d\", (int)status);\n \t\treturn status;\n \t}\n \n-\tprint(\"RCOTrim = %d\\n\", RcoTrim);\n+\tPX4_INFO_RAW(\"RCOTrim = %d\\n\", RcoTrim);\n \n \t/* Configure the device with calibrated RCO to 24MHz. */\n \tstatus = ConfigureDevice(slave, RcoTrim);\n \n \tif (status < STATUS_OK) {\n-\t\terror_log(\"Timer test failed!\\n\"\n-\t\t\t  \"Configuration test returned code: %d\", status);\n+\t\tPX4_INFO_RAW(\"Timer test failed!\\n\"\n+\t\t\t     \"Configuration test returned code: %d\", (int)status);\n \t\treturn status;\n \t}\n \n@@ -1122,9 +1145,9 @@ static status_t TimerTest(s2pi_slave_t slave)\n \tfloat x2sum = 0;\n \tfloat xysum = 0;\n \n-\tprint(\"+-------+---------+------------+\\n\");\n-\tprint(\"| count | samples | elapsed us |\\n\");\n-\tprint(\"+-------+---------+------------+\\n\");\n+\tPX4_INFO_RAW(\"+-------+---------+------------+\\n\");\n+\tPX4_INFO_RAW(\"| count | samples | elapsed us |\\n\");\n+\tPX4_INFO_RAW(\"+-------+---------+------------+\\n\");\n \n \tfor (uint8_t i = 1; i <= n; ++i) {\n \t\tltc_t start;\n@@ -1134,9 +1157,9 @@ static status_t TimerTest(s2pi_slave_t slave)\n \t\tstatus = RunMeasurement(slave, samples);\n \n \t\tif (status < STATUS_OK) {\n-\t\t\terror_log(\"Timer test failed!\\n\"\n-\t\t\t\t  \"Run measurement returned code: %d\",\n-\t\t\t\t  status);\n+\t\t\tPX4_INFO_RAW(\"Timer test failed!\\n\"\n+\t\t\t\t     \"Run measurement returned code: %d\",\n+\t\t\t\t     (int)status);\n \t\t\treturn status;\n \t\t}\n \n@@ -1147,30 +1170,229 @@ static status_t TimerTest(s2pi_slave_t slave)\n \t\tx2sum += (float) samples * samples;\n \t\txysum += (float) samples * elapsed_usec;\n \n-\t\tprint(\"| %5d | %7d | %10d |\\n\", i, samples, elapsed_usec);\n+\t\tPX4_INFO_RAW(\"| %5d | %7d | %10d |\\n\", i, samples, (uint)elapsed_usec);\n \t}\n \n-\tprint(\"+-------+---------+------------+\\n\");\n+\tPX4_INFO_RAW(\"+-------+---------+------------+\\n\");\n \n \n \tconst float slope = (n * xysum - xsum * ysum) / (n * x2sum - xsum * xsum);\n \tconst float intercept = (ysum * x2sum - xsum * xysum) / (n * x2sum - xsum * xsum);\n-\tprint(\"Linear Regression: y(x) = %dE-7 sec * x + %dE-7 sec\\n\",\n-\t      (int)(10 * slope), (int)(10 * intercept));\n+\tPX4_INFO_RAW(\"Linear Regression: y(x) = %dE-7 sec * x + %dE-7 sec\\n\",\n+\t\t     (int)(10 * slope), (int)(10 * intercept));\n \n \t/* Check the error of the slope. */\n \tconst float max_slope = exp_slope * (1.f + rel_slope_error);\n \tconst float min_slope = exp_slope * (1.f - rel_slope_error);\n \n \tif (slope > max_slope || slope < min_slope) {\n-\t\terror_log(\"Time test failed!\\n\"\n-\t\t\t  \"The measured time slope does not match the expected value! \"\n-\t\t\t  \"(actual: %dE-7, expected: %dE-7, min: %dE-7, max: %dE-7)\\n\",\n-\t\t\t  (int)(10 * slope), (int)(10 * exp_slope),\n-\t\t\t  (int)(10 * min_slope), (int)(10 * max_slope));\n+\t\tPX4_INFO_RAW(\"Time test failed!\\n\"\n+\t\t\t     \"The measured time slope does not match the expected value! \"\n+\t\t\t     \"(actual: %dE-7, expected: %dE-7, min: %dE-7, max: %dE-7)\\n\",\n+\t\t\t     (int)(10 * slope), (int)(10 * exp_slope),\n+\t\t\t     (int)(10 * min_slope), (int)(10 * max_slope));\n \t\treturn ERROR_FAIL;\n \t}\n \n \treturn STATUS_OK;\n }\n \n+\n+/*!***************************************************************************\n+ * @brief\tData structure for the PIT test.\n+ *\n+ * @details\tContains data that is required by the PIT timer test.\n+ *****************************************************************************/\n+typedef struct {\n+\t/*! The number of PIT callback events. */\n+\tvolatile uint32_t n;\n+\n+\t/*! The time stamp of the first callback event. */\n+\tltc_t t_first;\n+\n+\t/*! The time stamp of the last callback event. */\n+\tltc_t t_last;\n+\n+} pit_data_t;\n+\n+\n+\n+/*!***************************************************************************\n+ * @brief\tCallback function invoked by the PIT.\n+ *\n+ * @details\tThe function that is invoked every time a specified interval elapses.\n+ * \t\t\tAn abstract parameter is passed to the function whenever it is called.\n+ *\n+ * \t\t\tThis implementation collects callback time stamps and counts the\n+ * \t\t\tnumber of callback events using the abstract parameter.\n+ *\n+ * @param\tparam An abstract parameter to be passed to the callback. This is\n+ * \t\t\t\t\talso the identifier of the given interval.\n+ *****************************************************************************/\n+static void PIT_Callback(void *param)\n+{\n+\tpit_data_t *data = (pit_data_t *) param;\n+\n+\tif (data->n == 0) {\n+\t\tTime_GetNow(&data->t_first);\n+\t\tdata->t_last = data->t_first;\n+\n+\t} else {\n+\t\tTime_GetNow(&data->t_last);\n+\t}\n+\n+\tdata->n++;\n+}\n+\n+/*!***************************************************************************\n+ * @brief\tExecutes a PIT measurement and verifies the callback interval.\n+ *\n+ * @details The function configures the PIT with a given interval and waits\n+ * \t\t\tseveral callback events to happen. In each callback event, the\n+ * \t\t\telapsed time is measured and the number of calls are counted.\n+ * \t\t\tFinally, the average interrupt period is compared with the\n+ * \t\t\tlifetime timer that has been already verified in a previous test\n+ * \t\t\t(see #Timer_Test).\n+ *\n+ * @param\texp_dt_us The expected timer interval in microseconds.\n+ * @param\tn The number of PIT events to await.\n+ *\n+ * @return \tReturns the \\link #status_t status\\endlink:\n+ * \t\t\t- #STATUS_OK on success.\n+ * \t\t\t- #ERROR_FAIL if the measured interval does not match the\n+ * \t\t\t  expectations or the PIT was not disabled properly.\n+ * \t\t\t- #ERROR_TIMEOUT if either the PIT events do not occur within the\n+ * \t\t\t  expected time.\n+ * \t\t\t- The PIT layer error code if #Timer_SetInterval return any\n+ * \t\t\t  negative status.\n+ *****************************************************************************/\n+static status_t RunPITTest(uint32_t exp_dt_us, uint32_t n)\n+{\n+\t/* Test parameter configuration: *****************************************/\n+\tconst float rel_dt_error = 1e-3; \t// Relative timer interval tolerance is 0.1%.\n+\tconst float abs_dt_error = 1.0; \t// Absolute timer interval tolerance is 1us.\n+\t/*************************************************************************/\n+\tfloat dt = exp_dt_us * rel_dt_error;\n+\n+\tif (dt < abs_dt_error) { dt = abs_dt_error; }\n+\n+\tconst float max_dt = exp_dt_us + dt;\n+\tconst float min_dt = exp_dt_us - dt;\n+\t/*************************************************************************/\n+\n+\t/* Setup the PIT callback with specified interval. */\n+\tpit_data_t data = { 0 };\n+\tstatus_t status = Timer_SetInterval(exp_dt_us, &data);\n+\n+\tif (status < STATUS_OK) {\n+\t\tPX4_INFO_RAW(\"PIT test failed!\\n\"\n+\t\t\t     \"Timer_SetInterval returned status code: %d\", (int)status);\n+\t\treturn status;\n+\t}\n+\n+\t/* Wait until n PIT callback have been happened. */\n+\tuint32_t timeout_us = (n + 1) * exp_dt_us;\n+\tltc_t start;\n+\tTime_GetNow(&start);\n+\n+\twhile (data.n < n) {\n+\t\tif (Time_CheckTimeoutUSec(&start, timeout_us)) {\n+\t\t\tPX4_INFO_RAW(\"PIT test failed!\\n\"\n+\t\t\t\t     \"Waiting for the PIT interrupt events yielded a timeout.\");\n+\t\t\tstatus = ERROR_TIMEOUT;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tif (status == STATUS_OK) {\n+\t\t/* Disable the PIT timer callback. */\n+\t\tstatus = Timer_SetInterval(0, &data);\n+\n+\t\tif (status < STATUS_OK) {\n+\t\t\tPX4_INFO_RAW(\"PIT test failed!\\n\"\n+\t\t\t\t     \"Timer_SetInterval returned status code: %d\", (int)status);\n+\t\t}\n+\t}\n+\n+\tif (status == STATUS_OK) {\n+\t\t/* Check if PIT callback is not invoked any more. */\n+\t\ttimeout_us = 2 * exp_dt_us;\n+\t\tTime_GetNow(&start);\n+\n+\t\twhile (!Time_CheckTimeoutUSec(&start, timeout_us)) { __asm(\"nop\"); }\n+\n+\t\tif (data.n > n) {\n+\t\t\tPX4_INFO_RAW(\"PIT test failed!\\n\"\n+\t\t\t\t     \"Timer_SetInterval has been called after it was disabled.\");\n+\t\t\tstatus = ERROR_FAIL;\n+\t\t}\n+\t}\n+\n+\t/* Verify the measured average timer interval. */\n+\tconst float act_dt_us = Time_DiffUSec(&data.t_first, &data.t_last) / (n - 1);\n+\n+\tif (status == STATUS_OK && (act_dt_us > max_dt || act_dt_us < min_dt)) {\n+\t\tPX4_INFO_RAW(\"PIT test failed!\\n\"\n+\t\t\t     \"The measured timer interval does not match the expected value!\\n\");\n+\t\tstatus = ERROR_FAIL;\n+\t}\n+\n+\tPX4_INFO_RAW(\"PIT Test Results:\\n\"\n+\t\t     \" - event count: %u\\n\"\n+\t\t     \" - actual interval: %d us\\n\"\n+\t\t     \" - expected interval: %d us, min: %d us, max: %d us\\n\",\n+\t\t     (uint)data.n, (int)act_dt_us, (uint)exp_dt_us, (int)min_dt, (int)max_dt);\n+\n+\treturn status;\n+}\n+\n+/*!***************************************************************************\n+ * @brief\tTest for PIT HAL Implementation by comparing timings to the device.\n+ *\n+ * @details\tThe test verifies the timer HAL implementation by comparing the\n+ *\n+ * @return \tReturns the \\link #status_t status\\endlink:\n+ * \t\t\t- #STATUS_OK on success.\n+ * \t\t\t- #ERROR_NOT_IMPLEMENTED if the PIT functionality is not\n+ * \t\t\t  implemented and the test is skipped.\n+ * \t\t\t- #ERROR_FAIL if the measured interval does not match the\n+ * \t\t\t  expectations or the PIT was not disabled properly.\n+ * \t\t\t- #ERROR_TIMEOUT if either the PIT events do not occur within the\n+ * \t\t\t  expected time.\n+ * \t\t\t- The PIT layer error code if #Timer_SetInterval or\n+ * \t\t\t  #Timer_SetCallback return any negative status.\n+ *****************************************************************************/\n+static status_t PITTest(void)\n+{\n+\tstatus_t status = Timer_SetCallback(PIT_Callback);\n+\n+\tif (status == ERROR_NOT_IMPLEMENTED) { return status; }\n+\n+\tif (status < STATUS_OK) {\n+\t\tPX4_INFO_RAW(\"PIT test failed!\\n\"\n+\t\t\t     \"Timer_SetCallback returned status code: %d\", (int)status);\n+\t\treturn status;\n+\t}\n+\n+\tstatus = RunPITTest(10000, 10);\n+\n+\tif (status < STATUS_OK) { return status; }\n+\n+\tstatus = RunPITTest(333, 1000);\n+\n+\tif (status < STATUS_OK) { return status; }\n+\n+\tstatus = RunPITTest(100000, 5);\n+\n+\tif (status < STATUS_OK) { return status; }\n+\n+\tstatus = Timer_SetCallback(0);\n+\n+\tif (status < STATUS_OK) {\n+\t\tPX4_INFO_RAW(\"PIT test failed!\\n\"\n+\t\t\t     \"Timer_SetCallback to 0 returned status code: %d\", (int)status);\n+\t\treturn status;\n+\t}\n+\n+\treturn STATUS_OK;\n+}"},{"sha":"5af6660dfa589d7106d015671c2f2a1062942833","filename":"src/drivers/distance_sensor/broadcom/afbrs50/argus_hal_test.h","status":"modified","additions":98,"deletions":77,"changes":175,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/810dbbd25b5a1e3a27918d1cd51f3c1059335cc4/src%2Fdrivers%2Fdistance_sensor%2Fbroadcom%2Fafbrs50%2Fargus_hal_test.h","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/810dbbd25b5a1e3a27918d1cd51f3c1059335cc4/src%2Fdrivers%2Fdistance_sensor%2Fbroadcom%2Fafbrs50%2Fargus_hal_test.h","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Fdistance_sensor%2Fbroadcom%2Fafbrs50%2Fargus_hal_test.h?ref=810dbbd25b5a1e3a27918d1cd51f3c1059335cc4","patch":"@@ -37,9 +37,20 @@\n #ifndef ARGUS_HAL_TEST_H\n #define ARGUS_HAL_TEST_H\n \n-__BEGIN_DECLS\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n \n /*!***************************************************************************\n+ * @defgroup\targustest HAL Self Test\n+ *\n+ * @brief\t\tA test module to verify implementation of the HAL.\n+ *\n+ * @details \tA series of automated tests that can be executed on the target\n+ * \t\t\t\tplatform in order to verify the\timplementation of the HAL that\n+ * \t\t\t\tare required by the API.\n+ *\n  * @addtogroup \targustest\n  * @{\n  *****************************************************************************/\n@@ -50,117 +61,127 @@ __BEGIN_DECLS\n  * @brief\tVersion number of the HAL Self Test.\n  *\n  * @details Changes:\n- *\n- *  \t\t- v1.0:\n+ *  \t\t* v1.0:\n  *  \t\t\t- Initial release.\n- *  \t\t\t.\n- *  \t\t- v1.1:\n+ *  \t\t* v1.1:\n  *  \t\t\t- Added additional print output.\n  *  \t\t\t- Increased tolerance for timer test to 3%.\n  *  \t\t\t- Fixed callback issue by disabling it after IRQ test.\n- *\t\t\t\t.\n+ *  \t\t* v1.1:\n+ *  \t\t\t- Added PIT test cases.\n  *****************************************************************************/\n-#define HAL_TEST_VERSION \"v1.1\"\n+#define HAL_TEST_VERSION \"v1.2\"\n \n /*!***************************************************************************\n  * @brief\tExecutes a series of tests in order to verify the HAL implementation.\n  *\n- * @details A series of automated tests are executed in order to verify the\n- * \t\t\timplementation of the HAL required by the API.\n+ * @details A series of automated tests are executed on the target platform in\n+ *\t\t\torder to verify the\timplementation of the HAL that are required by\n+ *\t\t\tthe API.\n+ *\n+ *\t\t\tEach test will write an error description via the print (i.e. UART)\n+ *\t\t\tfunction that shows what went wrong. Also an corresponding status is\n+ *\t\t\treturned in case no print functionality is available.\n+ *\n+ *\t\t\tThe following tests are executed:\n  *\n- * \t\t\tThe following tests are executed:\n+ *\t\t\t**1) Timer Plausibility Test:**\n  *\n- * \t\t\t1) Timer Plausibility Test:\n+ *\t\t\tRudimentary tests of the lifetime counter (LTC) implementation.\n+ *\t\t\tThis verifies that the LTC is running by checking if the returned\n+ *\t\t\tvalues of two consecutive calls to the #Timer_GetCounterValue\n+ *\t\t\tfunction are ascending. An artificial delay using the NOP operation\n+ *\t\t\tis induced such that the timer is not read to fast.\n  *\n- * \t\t\tRudimentary tests of the lifetime counter (LTC) implementation.\n- * \t\t\tThis verifies that the LTC is running by checking if the returned\n- * \t\t\tvalues of two consecutive calls to the #Timer_GetCounterValue\n- * \t\t\tfunction are ascending. An artificial delay using the NOP operation\n- * \t\t\tis induced such that the timer is not read to fast.\n+ *\t\t\t**2) Timer Wraparound Test:**\n  *\n- * \t\t\t2) Timer Wraparound Test:\n+ *\t\t\tThe LTC values must wrap from 999999 µs to 0 µs and increase the\n+ *\t\t\tseconds counter accordingly. This test verifies the correct wrapping\n+ *\t\t\tby consecutively calling the #Timer_GetCounterValue function until\n+ *\t\t\tat least 2 wraparound events have been occurred.\n  *\n- *\t\t\tThe LTC values must wrap from 999999 μs to 0 μs and increase the\n- *          seconds counter accordingly. This test verifies the correct wrapping\n- *          by consecutively calling the #Timer_GetCounterValue function until\n- *          at least 2 wraparound events have been occurred.\n+ *\t\t\t**3) SPI Connection Test:**\n  *\n- * \t\t\t3) SPI Connection Test:\n+ *\t\t\tThis test verifies the basic functionality of the SPI interface.\n+ *\t\t\tThe test utilizes the devices laser pattern register, which can\n+ *\t\t\tbe freely programmed by any 128-bit pattern. Thus, it writes a byte\n+ *\t\t\tsequence and reads back the written values on the consecutive SPI\n+ *\t\t\taccess.\n  *\n- * \t\t\tThis test verifies the basic functionality of the SPI interface.\n- * \t\t\tThe test utilizes the devices laser pattern register, which can\n- * \t\t\tbe freely programmed by any 128-bit pattern. Thus, it writes a byte\n- * \t\t\tsequence and reads back the written values on the consecutive SPI\n- * \t\t\taccess.\n+ *\t\t\t**4) SPI Interrupt Test:**\n  *\n- * \t\t\t4) SPI Interrupt Test:\n+ *\t\t\tThis test verifies the correct implementation of the device\n+ *\t\t\tintegration finished interrupt callback. Therefore it configures\n+ *\t\t\tthe device with a minimal setup to run a pseudo measurement that\n+ *\t\t\tdoes not emit any laser light.\n  *\n- * \t\t\tThis test verifies the correct implementation of the device\n- * \t\t\tintegration finished interrupt callback. Therefore it configures\n- * \t\t\tthe device with a minimal setup to run a pseudo measurement that\n- * \t\t\tdoes not emit any laser light.\n+ *\t\t\tNote that this test does verify the GPIO interrupt that occurs\n+ *\t\t\twhenever the device has finished the integration/measurement and\n+ *\t\t\tnew data is waiting to be read from the device. This does not test\n+ *\t\t\tthe interrupt that is triggered when the SPI transfer has finished.\n  *\n- * \t\t\tNote that this test does verify the GPIO interrupt that occurs\n- * \t\t\twhenever the device has finished the integration/measurement and\n- * \t\t\tnew data is waiting to be read from the device. This does not test\n- * \t\t\tthe interrupt that is triggered when the SPI transfer has finished.\n+ *\t\t\tThe data ready interrupt implies two S2PI layer functions that\n+ *\t\t\tare tested in this test: The #S2PI_SetIrqCallback function installs\n+ *\t\t\ta callback function that is invoked whenever the IRQ occurs.\n+ *\t\t\tThe IRQ can be delayed due to higher priority task, e.g. from the\n+ *\t\t\tuser code. It is essential for the laser safety timeout algorithm\n+ *\t\t\tto determine the device ready signal as fast as possible, another\n+ *\t\t\tmethod is implemented to read if the IRQ is pending but the\n+ *\t\t\tcallback has not been reset yet. This is what the #S2PI_ReadIrqPin\n+ *\t\t\tfunction is for.\n  *\n- * \t\t\tThe data ready interrupt implies two S2PI layer functions that\n- * \t\t\tare tested in this test: The #S2PI_SetIrqCallback function installs\n- * \t\t\ta callback function that is invoked whenever the IRQ occurs.\n- * \t\t\tThe IRQ can be delayed due to higher priority task, e.g. from the\n- * \t\t\tuser code. It is essential for the laser safety timeout algorithm\n- * \t\t\tto determine the device ready signal as fast as possible, another\n- * \t\t\tmethod is implemented to read if the IRQ is pending but the\n- * \t\t\tcallback has not been reset yet. This is what the #S2PI_ReadIrqPin\n- * \t\t\tfunction is for.\n+ *\t\t\t**5) GPIO Mode Test:**\n  *\n- * \t\t\t5) GPIO Mode Test:\n+ *\t\t\tThis test verifies the GPIO mode of the S2PI HAL module. This is\n+ *\t\t\tdone by leveraging the EEPROM readout sequence that accesses the\n+ *\t\t\tdevices EEPROM via a software protocol that depends on the GPIO\n+ *\t\t\tmode.\n  *\n- *          This test verifies the GPIO mode of the S2PI HAL module. This is\n- * \t\t\tdone by leveraging the EEPROM readout sequence that accesses the\n- * \t\t\tdevices EEPROM via a software protocol that depends on the GPIO\n- * \t\t\tmode.\n+ *\t\t\tThis the requires several steps, most of them are already verified\n+ *\t\t\tin previous tests:\n  *\n- * \t\t\tThis the requires several steps, most of them are already verified\n- * \t\t\tin previous tests:\n- * \t\t\t- Basic device configuration and enable EEPROM.\n- *  \t\t- Read EERPOM via GPIO mode and apply Hamming weight\n- *  \t\t- Repeat several times (to eliminate random readout issues).\n- *  \t\t- Decode the EEPROM (using EEPROM_Decode in argus_cal_eeprom.c)\n- *  \t\t- Check if Module Number and Chip ID is not 0\n+ *\t\t\t- Basic device configuration and enable EEPROM.\n+ *\t\t\t- Read EERPOM via GPIO mode and apply Hamming weight.\n+ *\t\t\t- Repeat several times (to eliminate random readout issues).\n+ *\t\t\t- Decode the EEPROM (using EEPROM_Decode in argus_cal_eeprom.c).\n+ *\t\t\t- Check if Module Number and Chip ID is not 0.\n  *\n- * \t\t\t6) Timer Test:\n+ *\t\t\t**6) Timer Test for Lifetime Counter:**\n  *\n- *         \tThe test verifies the timer HAL implementation by comparing the\n- * \t\t\ttimings\tto the AFBR-S50 device as a reference.\n- * \t\t\tTherefore several measurement are executed on the device, each with\n- * \t\t\ta different averaging sample count. The elapsed time increases\n- * \t\t\tlinearly with the number of averaging samples. In order to remove\n- * \t\t\tthe time for software/setup, a linear regression fit is applied to\n- * \t\t\tthe measurement results and only the slope is considered for the\n- * \t\t\tresult. A delta of 102.4 microseconds per sample is expected.\n- * \t\t\tIf the measured delta per sample is within an specified error range,\n- * \t\t\tthe timer implementation is considered correct.\n+ *\t\t\tThe test verifies the lifetime counter timer HAL implementation by\n+ *\t\t\tcomparing the timings to the AFBR-S50 device as a reference.\n+ *\t\t\tTherefore several measurement are executed on the device, each with\n+ *\t\t\ta different averaging sample count. The elapsed time increases\n+ *\t\t\tlinearly with the number of averaging samples. In order to remove\n+ *\t\t\tthe time for software/setup, a linear regression fit is applied to\n+ *\t\t\tthe measurement results and only the slope is considered for the\n+ *\t\t\tresult. A delta of 102.4 microseconds per sample is expected.\n+ *\t\t\tIf the measured delta per sample is within an specified error range,\n+ *\t\t\tthe timer implementation is considered correct.\n  *\n- *          -------------------------------------------------------------------\n+ *\t\t\t**7) Timer Test for Periodic Interrupt Timer:**\n  *\n- * \t\t\tEach test will write an error description via the print (i.e. UART)\n- * \t\t\tfunction that shows what went wrong. Also an corresponding status is\n- * \t\t\treturned in case no print functionality is available.\n+ *\t\t\tThe test verifies the correct implementation of the periodic\n+ *\t\t\tinterrupt timer (PIT). It sets different intervals and waits for\n+ *\t\t\ta certain number of interrupts to happen. Each interrupt event\n+ *\t\t\tis counted and the time between the first and the last interrupt\n+ *\t\t\tis measured. Finally, the measured interval is compared to the\n+ *\t\t\texpectations.\n  *\n  *\n  * @param\tspi_slave The SPI hardware slave, i.e. the specified CS and IRQ\n- * \t\t\t\t\t\tlines. This is actually just a number that is passed\n- * \t\t\t\t\t\tto the SPI interface to distinct for multiple SPI slave\n- * \t\t\t\t\t\tdevices. Note that the slave must be not equal to 0,\n- * \t\t\t\t\t\tsince is reserved for error handling.\n+ *\t\t\t\t\t\tlines. This is actually just a number that is passed\n+ *\t\t\t\t\t\tto the SPI interface to distinct for multiple SPI slave\n+ *\t\t\t\t\t\tdevices. Note that the slave must be not equal to 0,\n+ *\t\t\t\t\t\tsince is reserved for error handling.\n  *\n  * @return \tReturns the \\link #status_t status\\endlink (#STATUS_OK on success).\n  *****************************************************************************/\n status_t Argus_VerifyHALImplementation(s2pi_slave_t spi_slave);\n \n-__END_DECLS\n+#ifdef __cplusplus\n+}\n+#endif\n \n /*! @} */\n #endif /* ARGUS_CAL_API_H */"}]}