{"sha":"8c7e2546ed5222145a6d1745e77d01f7c21c24fc","node_id":"MDY6Q29tbWl0NTI5ODc5MDo4YzdlMjU0NmVkNTIyMjE0NWE2ZDE3NDVlNzdkMDFmN2MyMWMyNGZj","commit":{"author":{"name":"px4dev","email":"px4@purgatory.org","date":"2013-02-24T08:09:37Z"},"committer":{"name":"px4dev","email":"px4@purgatory.org","date":"2013-02-24T08:09:37Z"},"message":"Simplify the PX4IO main loop to cut down on memory consumption.","tree":{"sha":"36e71280c103906ee85ac29d02a6924bb0c4cbbb","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/36e71280c103906ee85ac29d02a6924bb0c4cbbb"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/8c7e2546ed5222145a6d1745e77d01f7c21c24fc","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/8c7e2546ed5222145a6d1745e77d01f7c21c24fc","html_url":"https://github.com/PX4/PX4-Autopilot/commit/8c7e2546ed5222145a6d1745e77d01f7c21c24fc","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/8c7e2546ed5222145a6d1745e77d01f7c21c24fc/comments","author":{"login":"px4dev","id":2095699,"node_id":"MDQ6VXNlcjIwOTU2OTk=","avatar_url":"https://avatars.githubusercontent.com/u/2095699?v=4","gravatar_id":"","url":"https://api.github.com/users/px4dev","html_url":"https://github.com/px4dev","followers_url":"https://api.github.com/users/px4dev/followers","following_url":"https://api.github.com/users/px4dev/following{/other_user}","gists_url":"https://api.github.com/users/px4dev/gists{/gist_id}","starred_url":"https://api.github.com/users/px4dev/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/px4dev/subscriptions","organizations_url":"https://api.github.com/users/px4dev/orgs","repos_url":"https://api.github.com/users/px4dev/repos","events_url":"https://api.github.com/users/px4dev/events{/privacy}","received_events_url":"https://api.github.com/users/px4dev/received_events","type":"User","site_admin":false},"committer":{"login":"px4dev","id":2095699,"node_id":"MDQ6VXNlcjIwOTU2OTk=","avatar_url":"https://avatars.githubusercontent.com/u/2095699?v=4","gravatar_id":"","url":"https://api.github.com/users/px4dev","html_url":"https://github.com/px4dev","followers_url":"https://api.github.com/users/px4dev/followers","following_url":"https://api.github.com/users/px4dev/following{/other_user}","gists_url":"https://api.github.com/users/px4dev/gists{/gist_id}","starred_url":"https://api.github.com/users/px4dev/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/px4dev/subscriptions","organizations_url":"https://api.github.com/users/px4dev/orgs","repos_url":"https://api.github.com/users/px4dev/repos","events_url":"https://api.github.com/users/px4dev/events{/privacy}","received_events_url":"https://api.github.com/users/px4dev/received_events","type":"User","site_admin":false},"parents":[{"sha":"5aa5645fb060c13997dc6458b530acb551c6c53e","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/5aa5645fb060c13997dc6458b530acb551c6c53e","html_url":"https://github.com/PX4/PX4-Autopilot/commit/5aa5645fb060c13997dc6458b530acb551c6c53e"}],"stats":{"total":452,"additions":206,"deletions":246},"files":[{"sha":"cad368ae43d2562d7b22380e923c8530bd31f8a6","filename":"apps/px4io/controls.c","status":"modified","additions":161,"deletions":158,"changes":319,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/8c7e2546ed5222145a6d1745e77d01f7c21c24fc/apps%2Fpx4io%2Fcontrols.c","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/8c7e2546ed5222145a6d1745e77d01f7c21c24fc/apps%2Fpx4io%2Fcontrols.c","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/apps%2Fpx4io%2Fcontrols.c?ref=8c7e2546ed5222145a6d1745e77d01f7c21c24fc","patch":"@@ -39,7 +39,6 @@\n \n #include <nuttx/config.h>\n #include <stdbool.h>\n-#include <poll.h>\n \n #include <drivers/drv_hrt.h>\n #include <systemlib/perf_counter.h>\n@@ -53,21 +52,18 @@\n \n static bool\tppm_input(uint16_t *values, uint16_t *num_values);\n \n+static perf_counter_t c_gather_dsm;\n+static perf_counter_t c_gather_sbus;\n+static perf_counter_t c_gather_ppm;\n+\n void\n-controls_main(void)\n+controls_init(void)\n {\n-\tstruct pollfd fds[2];\n-\n \t/* DSM input */\n-\tfds[0].fd = dsm_init(\"/dev/ttyS0\");\n-\tfds[0].events = POLLIN;\n+\tdsm_init(\"/dev/ttyS0\");\n \n \t/* S.bus input */\n-\tfds[1].fd = sbus_init(\"/dev/ttyS2\");\n-\tfds[1].events = POLLIN;\n-\n-\tASSERT(fds[0].fd >= 0);\n-\tASSERT(fds[1].fd >= 0);\n+\tsbus_init(\"/dev/ttyS2\");\n \n \t/* default to a 1:1 input map, all enabled */\n \tfor (unsigned i = 0; i < MAX_CONTROL_CHANNELS; i++) {\n@@ -82,200 +78,207 @@ controls_main(void)\n \t\tr_page_rc_input_config[base + PX4IO_P_RC_CONFIG_OPTIONS]    = PX4IO_P_RC_CONFIG_OPTIONS_ENABLED;\n \t}\n \n-\tfor (;;) {\n-\t\t/* run this loop at ~100Hz */\n-\t\tint result = poll(fds, 2, 10);\n+\tc_gather_dsm = perf_alloc(PC_ELAPSED, \"c_gather_dsm\");\n+\tc_gather_sbus = perf_alloc(PC_ELAPSED, \"c_gather_sbus\");\n+\tc_gather_ppm = perf_alloc(PC_ELAPSED, \"c_gather_ppm\");\n+}\n \n-\t\tASSERT(result >= 0);\n+void\n+controls_tick() {\n \n-\t\t/*\n-\t\t * Gather R/C control inputs from supported sources.\n-\t\t *\n-\t\t * Note that if you're silly enough to connect more than\n-\t\t * one control input source, they're going to fight each\n-\t\t * other.  Don't do that.\n-\t\t */\n+\t/*\n+\t * Gather R/C control inputs from supported sources.\n+\t *\n+\t * Note that if you're silly enough to connect more than\n+\t * one control input source, they're going to fight each\n+\t * other.  Don't do that.\n+\t */\n \n-\t\tbool dsm_updated = dsm_input(r_raw_rc_values, &r_raw_rc_count);\n-\t\tif (dsm_updated)\n-\t\t\tr_status_flags |= PX4IO_P_STATUS_FLAGS_RC_DSM;\n+\tperf_begin(c_gather_dsm);\n+\tbool dsm_updated = dsm_input(r_raw_rc_values, &r_raw_rc_count);\n+\tif (dsm_updated)\n+\t\tr_status_flags |= PX4IO_P_STATUS_FLAGS_RC_DSM;\n+\tperf_end(c_gather_dsm);\n \n-\t\tbool sbus_updated = sbus_input(r_raw_rc_values, &r_raw_rc_count);\n-\t\tif (sbus_updated)\n-\t\t\tr_status_flags |= PX4IO_P_STATUS_FLAGS_RC_SBUS;\n+\tperf_begin(c_gather_sbus);\n+\tbool sbus_updated = sbus_input(r_raw_rc_values, &r_raw_rc_count);\n+\tif (sbus_updated)\n+\t\tr_status_flags |= PX4IO_P_STATUS_FLAGS_RC_SBUS;\n+\tperf_end(c_gather_sbus);\n \n-\t\t/*\n-\t\t * XXX each S.bus frame will cause a PPM decoder interrupt\n-\t\t * storm (lots of edges).  It might be sensible to actually\n-\t\t * disable the PPM decoder completely if we have S.bus signal.\n-\t\t */\n-\t\tbool ppm_updated = ppm_input(r_raw_rc_values, &r_raw_rc_count);\n-\t\tif (ppm_updated)\n-\t\t\tr_status_flags |= PX4IO_P_STATUS_FLAGS_RC_PPM;\n+\t/*\n+\t * XXX each S.bus frame will cause a PPM decoder interrupt\n+\t * storm (lots of edges).  It might be sensible to actually\n+\t * disable the PPM decoder completely if we have S.bus signal.\n+\t */\n+\tperf_begin(c_gather_ppm);\n+\tbool ppm_updated = ppm_input(r_raw_rc_values, &r_raw_rc_count);\n+\tif (ppm_updated)\n+\t\tr_status_flags |= PX4IO_P_STATUS_FLAGS_RC_PPM;\n+\tperf_end(c_gather_ppm);\n \n-\t\tASSERT(r_raw_rc_count <= MAX_CONTROL_CHANNELS);\n+\tASSERT(r_raw_rc_count <= MAX_CONTROL_CHANNELS);\n \n-\t\t/*\n-\t\t * In some cases we may have received a frame, but input has still\n-\t\t * been lost.\n-\t\t */\n-\t\tbool rc_input_lost = false;\n \n-\t\t/*\n-\t\t * If we received a new frame from any of the RC sources, process it.\n-\t\t */\n-\t\tif (dsm_updated || sbus_updated || ppm_updated) {\n+\t/*\n+\t * In some cases we may have received a frame, but input has still\n+\t * been lost.\n+\t */\n+\tbool rc_input_lost = false;\n \n-\t\t\t/* update RC-received timestamp */\n-\t\t\tsystem_state.rc_channels_timestamp = hrt_absolute_time();\n+\t/*\n+\t * If we received a new frame from any of the RC sources, process it.\n+\t */\n+\tif (dsm_updated || sbus_updated || ppm_updated) {\n \n-\t\t\t/* record a bitmask of channels assigned */\n-\t\t\tunsigned assigned_channels = 0;\n+\t\t/* update RC-received timestamp */\n+\t\tsystem_state.rc_channels_timestamp = hrt_absolute_time();\n \n-\t\t\t/* map raw inputs to mapped inputs */\n-\t\t\t/* XXX mapping should be atomic relative to protocol */\n-\t\t\tfor (unsigned i = 0; i < r_raw_rc_count; i++) {\n+\t\t/* record a bitmask of channels assigned */\n+\t\tunsigned assigned_channels = 0;\n \n-\t\t\t\t/* map the input channel */\n-\t\t\t\tuint16_t *conf = &r_page_rc_input_config[i * PX4IO_P_RC_CONFIG_STRIDE];\n+\t\t/* map raw inputs to mapped inputs */\n+\t\t/* XXX mapping should be atomic relative to protocol */\n+\t\tfor (unsigned i = 0; i < r_raw_rc_count; i++) {\n \n-\t\t\t\tif (conf[PX4IO_P_RC_CONFIG_OPTIONS] & PX4IO_P_RC_CONFIG_OPTIONS_ENABLED) {\n+\t\t\t/* map the input channel */\n+\t\t\tuint16_t *conf = &r_page_rc_input_config[i * PX4IO_P_RC_CONFIG_STRIDE];\n \n-\t\t\t\t\tuint16_t raw = r_raw_rc_values[i];\n+\t\t\tif (conf[PX4IO_P_RC_CONFIG_OPTIONS] & PX4IO_P_RC_CONFIG_OPTIONS_ENABLED) {\n \n-\t\t\t\t\t/* implement the deadzone */\n-\t\t\t\t\tif (raw < conf[PX4IO_P_RC_CONFIG_CENTER]) {\n-\t\t\t\t\t\traw += conf[PX4IO_P_RC_CONFIG_DEADZONE];\n-\t\t\t\t\t\tif (raw > conf[PX4IO_P_RC_CONFIG_CENTER])\n-\t\t\t\t\t\t\traw = conf[PX4IO_P_RC_CONFIG_CENTER];\n-\t\t\t\t\t}\n-\t\t\t\t\tif (raw > conf[PX4IO_P_RC_CONFIG_CENTER]) {\n-\t\t\t\t\t\traw -= conf[PX4IO_P_RC_CONFIG_DEADZONE];\n-\t\t\t\t\t\tif (raw < conf[PX4IO_P_RC_CONFIG_CENTER])\n-\t\t\t\t\t\t\traw = conf[PX4IO_P_RC_CONFIG_CENTER];\n-\t\t\t\t\t}\n+\t\t\t\tuint16_t raw = r_raw_rc_values[i];\n \n-\t\t\t\t\t/* constrain to min/max values */\n-\t\t\t\t\tif (raw < conf[PX4IO_P_RC_CONFIG_MIN])\n-\t\t\t\t\t\traw = conf[PX4IO_P_RC_CONFIG_MIN];\n-\t\t\t\t\tif (raw > conf[PX4IO_P_RC_CONFIG_MAX])\n-\t\t\t\t\t\traw = conf[PX4IO_P_RC_CONFIG_MAX];\n+\t\t\t\t/* implement the deadzone */\n+\t\t\t\tif (raw < conf[PX4IO_P_RC_CONFIG_CENTER]) {\n+\t\t\t\t\traw += conf[PX4IO_P_RC_CONFIG_DEADZONE];\n+\t\t\t\t\tif (raw > conf[PX4IO_P_RC_CONFIG_CENTER])\n+\t\t\t\t\t\traw = conf[PX4IO_P_RC_CONFIG_CENTER];\n+\t\t\t\t}\n+\t\t\t\tif (raw > conf[PX4IO_P_RC_CONFIG_CENTER]) {\n+\t\t\t\t\traw -= conf[PX4IO_P_RC_CONFIG_DEADZONE];\n+\t\t\t\t\tif (raw < conf[PX4IO_P_RC_CONFIG_CENTER])\n+\t\t\t\t\t\traw = conf[PX4IO_P_RC_CONFIG_CENTER];\n+\t\t\t\t}\n \n-\t\t\t\t\tint16_t scaled = raw;\n+\t\t\t\t/* constrain to min/max values */\n+\t\t\t\tif (raw < conf[PX4IO_P_RC_CONFIG_MIN])\n+\t\t\t\t\traw = conf[PX4IO_P_RC_CONFIG_MIN];\n+\t\t\t\tif (raw > conf[PX4IO_P_RC_CONFIG_MAX])\n+\t\t\t\t\traw = conf[PX4IO_P_RC_CONFIG_MAX];\n \n-\t\t\t\t\t/* adjust to zero-relative (-500..500) */\n-\t\t\t\t\tscaled -= 1500;\n+\t\t\t\tint16_t scaled = raw;\n \n-\t\t\t\t\t/* scale to fixed-point representation (-10000..10000) */\n-\t\t\t\t\tscaled *= 20;\n+\t\t\t\t/* adjust to zero-relative (-500..500) */\n+\t\t\t\tscaled -= 1500;\n \n-\t\t\t\t\tASSERT(scaled >= -15000);\n-\t\t\t\t\tASSERT(scaled <= 15000);\n+\t\t\t\t/* scale to fixed-point representation (-10000..10000) */\n+\t\t\t\tscaled *= 20;\n \n-\t\t\t\t\tif (conf[PX4IO_P_RC_CONFIG_OPTIONS] & PX4IO_P_RC_CONFIG_OPTIONS_REVERSE)\n-\t\t\t\t\t\tscaled = -scaled;\n+\t\t\t\tASSERT(scaled >= -15000);\n+\t\t\t\tASSERT(scaled <= 15000);\n \n-\t\t\t\t\t/* and update the scaled/mapped version */\n-\t\t\t\t\tunsigned mapped = conf[PX4IO_P_RC_CONFIG_ASSIGNMENT];\n-\t\t\t\t\tASSERT(mapped < MAX_CONTROL_CHANNELS);\n+\t\t\t\tif (conf[PX4IO_P_RC_CONFIG_OPTIONS] & PX4IO_P_RC_CONFIG_OPTIONS_REVERSE)\n+\t\t\t\t\tscaled = -scaled;\n \n-\t\t\t\t\tr_rc_values[mapped] = SIGNED_TO_REG(scaled);\n-\t\t\t\t\tassigned_channels |= (1 << mapped);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t/* set un-assigned controls to zero */\n-\t\t\tfor (unsigned i = 0; i < MAX_CONTROL_CHANNELS; i++) {\n-\t\t\t\tif (!(assigned_channels & (1 << i)))\n-\t\t\t\t\tr_rc_values[i] = 0;\n-\t\t\t}\n+\t\t\t\t/* and update the scaled/mapped version */\n+\t\t\t\tunsigned mapped = conf[PX4IO_P_RC_CONFIG_ASSIGNMENT];\n+\t\t\t\tASSERT(mapped < MAX_CONTROL_CHANNELS);\n \n-\t\t\t/*\n-\t\t\t * If we got an update with zero channels, treat it as \n-\t\t\t * a loss of input.\n-\t\t\t *\n-\t\t\t * This might happen if a protocol-based receiver returns an update\n-\t\t\t * that contains no channels that we have mapped.\n-\t\t\t */\n-\t\t\tif (assigned_channels == 0) {\n-\t\t\t\trc_input_lost = true;\n-\t\t\t} else {\n-\t\t\t\tr_status_flags |= PX4IO_P_STATUS_FLAGS_RC_OK;\n+\t\t\t\tr_rc_values[mapped] = SIGNED_TO_REG(scaled);\n+\t\t\t\tassigned_channels |= (1 << mapped);\n \t\t\t}\n+\t\t}\n \n-\t\t\t/*\n-\t\t\t * Export the valid channel bitmap\n-\t\t\t */\n-\t\t\tr_rc_valid = assigned_channels;\n+\t\t/* set un-assigned controls to zero */\n+\t\tfor (unsigned i = 0; i < MAX_CONTROL_CHANNELS; i++) {\n+\t\t\tif (!(assigned_channels & (1 << i)))\n+\t\t\t\tr_rc_values[i] = 0;\n \t\t}\n \n \t\t/*\n-\t\t * If we haven't seen any new control data in 200ms, assume we\n-\t\t * have lost input.\n+\t\t * If we got an update with zero channels, treat it as \n+\t\t * a loss of input.\n+\t\t *\n+\t\t * This might happen if a protocol-based receiver returns an update\n+\t\t * that contains no channels that we have mapped.\n \t\t */\n-\t\tif ((hrt_absolute_time() - system_state.rc_channels_timestamp) > 200000) {\n+\t\tif (assigned_channels == 0) {\n \t\t\trc_input_lost = true;\n-\n-\t\t\t/* clear the input-kind flags here */\n-\t\t\tr_status_flags &= ~(\n-\t\t\t\tPX4IO_P_STATUS_FLAGS_RC_PPM |\n-\t\t\t\tPX4IO_P_STATUS_FLAGS_RC_DSM |\n-\t\t\t\tPX4IO_P_STATUS_FLAGS_RC_SBUS);\n+\t\t} else {\n+\t\t\tr_status_flags |= PX4IO_P_STATUS_FLAGS_RC_OK;\n \t\t}\n \n \t\t/*\n-\t\t * Handle losing RC input\n+\t\t * Export the valid channel bitmap\n \t\t */\n-\t\tif (rc_input_lost) {\n+\t\tr_rc_valid = assigned_channels;\n+\t}\n+\n+\t/*\n+\t * If we haven't seen any new control data in 200ms, assume we\n+\t * have lost input.\n+\t */\n+\tif ((hrt_absolute_time() - system_state.rc_channels_timestamp) > 200000) {\n+\t\trc_input_lost = true;\n+\n+\t\t/* clear the input-kind flags here */\n+\t\tr_status_flags &= ~(\n+\t\t\tPX4IO_P_STATUS_FLAGS_RC_PPM |\n+\t\t\tPX4IO_P_STATUS_FLAGS_RC_DSM |\n+\t\t\tPX4IO_P_STATUS_FLAGS_RC_SBUS);\n+\t}\n+\n+\t/*\n+\t * Handle losing RC input\n+\t */\n+\tif (rc_input_lost) {\n \n-\t\t\t/* Clear the RC input status flag, clear manual override flag */\n-\t\t\tr_status_flags &= ~(\n-\t\t\t\tPX4IO_P_STATUS_FLAGS_OVERRIDE |\n-\t\t\t\tPX4IO_P_STATUS_FLAGS_RC_OK);\n+\t\t/* Clear the RC input status flag, clear manual override flag */\n+\t\tr_status_flags &= ~(\n+\t\t\tPX4IO_P_STATUS_FLAGS_OVERRIDE |\n+\t\t\tPX4IO_P_STATUS_FLAGS_RC_OK);\n \n-\t\t\t/* Set the RC_LOST alarm */\n-\t\t\tr_status_alarms |= PX4IO_P_STATUS_ALARMS_RC_LOST;\n+\t\t/* Set the RC_LOST alarm */\n+\t\tr_status_alarms |= PX4IO_P_STATUS_ALARMS_RC_LOST;\n \n-\t\t\t/* Mark the arrays as empty */\n-\t\t\tr_raw_rc_count = 0;\n-\t\t\tr_rc_valid = 0;\n-\t\t}\n+\t\t/* Mark the arrays as empty */\n+\t\tr_raw_rc_count = 0;\n+\t\tr_rc_valid = 0;\n+\t}\n+\n+\t/*\n+\t * Check for manual override.\n+\t *\n+\t * The PX4IO_P_SETUP_ARMING_MANUAL_OVERRIDE_OK flag must be set, and we\n+\t * must have R/C input.\n+\t * Override is enabled if either the hardcoded channel / value combination\n+\t * is selected, or the AP has requested it.\n+\t */\n+\tif ((r_setup_arming & PX4IO_P_SETUP_ARMING_MANUAL_OVERRIDE_OK) && \n+\t\t(r_status_flags & PX4IO_P_STATUS_FLAGS_RC_OK)) {\n+\n+\t\tbool override = false;\n \n \t\t/*\n-\t\t * Check for manual override.\n+\t\t * Check mapped channel 5; if the value is 'high' then the pilot has\n+\t\t * requested override.\n \t\t *\n-\t\t * The PX4IO_P_SETUP_ARMING_MANUAL_OVERRIDE_OK flag must be set, and we\n-\t\t * must have R/C input.\n-\t\t * Override is enabled if either the hardcoded channel / value combination\n-\t\t * is selected, or the AP has requested it.\n+\t\t * XXX This should be configurable.\n \t\t */\n-\t\tif ((r_setup_arming & PX4IO_P_SETUP_ARMING_MANUAL_OVERRIDE_OK) && \n-\t\t\t(r_status_flags & PX4IO_P_STATUS_FLAGS_RC_OK)) {\n-\n-\t\t\tbool override = false;\n+\t\tif ((r_status_flags & PX4IO_P_STATUS_FLAGS_RC_OK) && (r_rc_values[4] > RC_CHANNEL_HIGH_THRESH))\n+\t\t\toverride = true;\n \n-\t\t\t/*\n-\t\t\t * Check mapped channel 5; if the value is 'high' then the pilot has\n-\t\t\t * requested override.\n-\t\t\t *\n-\t\t\t * XXX This should be configurable.\n-\t\t\t */\n-\t\t\tif ((r_status_flags & PX4IO_P_STATUS_FLAGS_RC_OK) && (r_rc_values[4] > RC_CHANNEL_HIGH_THRESH))\n-\t\t\t\toverride = true;\n+\t\tif (override) {\n \n-\t\t\tif (override) {\n+\t\t\tr_status_flags |= PX4IO_P_STATUS_FLAGS_OVERRIDE;\n \n-\t\t\t\tr_status_flags |= PX4IO_P_STATUS_FLAGS_OVERRIDE;\n+\t\t\t/* mix new RC input control values to servos */\n+\t\t\tif (dsm_updated || sbus_updated || ppm_updated)\n+\t\t\t\tmixer_tick();\n \n-\t\t\t\t/* mix new RC input control values to servos */\n-\t\t\t\tif (dsm_updated || sbus_updated || ppm_updated)\n-\t\t\t\t\tmixer_tick();\n-\n-\t\t\t} else {\n-\t\t\t\tr_status_flags &= ~PX4IO_P_STATUS_FLAGS_OVERRIDE;\n-\t\t\t}\n+\t\t} else {\n+\t\t\tr_status_flags &= ~PX4IO_P_STATUS_FLAGS_OVERRIDE;\n \t\t}\n-\n \t}\n }\n "},{"sha":"5892646612b51b8d8539f70de5ffb915caf89325","filename":"apps/px4io/px4io.c","status":"modified","additions":40,"deletions":75,"changes":115,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/8c7e2546ed5222145a6d1745e77d01f7c21c24fc/apps%2Fpx4io%2Fpx4io.c","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/8c7e2546ed5222145a6d1745e77d01f7c21c24fc/apps%2Fpx4io%2Fpx4io.c","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/apps%2Fpx4io%2Fpx4io.c?ref=8c7e2546ed5222145a6d1745e77d01f7c21c24fc","patch":"@@ -68,14 +68,8 @@ static struct hrt_call serial_dma_call;\n volatile uint8_t debug_level = 0;\n volatile uint32_t i2c_loop_resets = 0;\n \n-struct hrt_call loop_overtime_call;\n-\n-// this allows wakeup of the main task via a signal\n-static pid_t daemon_pid;\n-\n-\n /*\n-  a set of debug buffers to allow us to send debug information from ISRs\n+ * a set of debug buffers to allow us to send debug information from ISRs\n  */\n \n static volatile uint32_t msg_counter;\n@@ -91,9 +85,10 @@ static volatile uint8_t msg_next_out, msg_next_in;\n static char msg[NUM_MSG][40];\n \n /*\n-  add a debug message to be printed on the console\n+ * add a debug message to be printed on the console\n  */\n-void isr_debug(uint8_t level, const char *fmt, ...)\n+void\n+isr_debug(uint8_t level, const char *fmt, ...)\n {\n \tif (level > debug_level) {\n \t\treturn;\n@@ -107,9 +102,10 @@ void isr_debug(uint8_t level, const char *fmt, ...)\n }\n \n /*\n-  show all pending debug messages\n+ * show all pending debug messages\n  */\n-static void show_debug_messages(void)\n+static void\n+show_debug_messages(void)\n {\n \tif (msg_counter != last_msg_counter) {\n \t\tuint32_t n = msg_counter - last_msg_counter;\n@@ -122,36 +118,9 @@ static void show_debug_messages(void)\n \t}\n }\n \n-/*\n-  catch I2C lockups\n- */\n-static void loop_overtime(void *arg)\n-{\n-\tlowsyslog(\"I2C RESET\\n\");\n-\ti2c_loop_resets++;\n-\ti2c_dump();\n-\ti2c_reset();\n-\thrt_call_after(&loop_overtime_call, 50000, (hrt_callout)loop_overtime, NULL);\n-}\n-\n-static void wakeup_handler(int signo, siginfo_t *info, void *ucontext)\n-{\n-\t/* nothing to do - we just want poll() to return */\n-}\n-\n-\n-/*\n-  wakeup the main task using a signal\n- */\n-void daemon_wakeup(void)\n+int\n+user_start(int argc, char *argv[])\n {\n-\tkill(daemon_pid, SIGUSR1);\n-}\n-\n-int user_start(int argc, char *argv[])\n-{\n-\tdaemon_pid = getpid();\n-\n \t/* run C++ ctors before we go any further */\n \tup_cxxinitialize();\n \n@@ -184,18 +153,27 @@ int user_start(int argc, char *argv[])\n \t/* configure the first 8 PWM outputs (i.e. all of them) */\n \tup_pwm_servo_init(0xff);\n \n-\t/* start the flight control signal handler */\n-\tint ret = task_create(\"FCon\",\n-\t\t    SCHED_PRIORITY_DEFAULT,\n-\t\t    1024,\n-\t\t    (main_t)controls_main,\n-\t\t    NULL);\n+\t/* initialise the control inputs */\n+\tcontrols_init();\n+\n+\t/* start the i2c handler */\n+\ti2c_init();\n+\n+\t/* add a performance counter for mixing */\n+\tperf_counter_t mixer_perf = perf_alloc(PC_ELAPSED, \"mix\");\n+\n+\t/* add a performance counter for controls */\n+\tperf_counter_t controls_perf = perf_alloc(PC_ELAPSED, \"controls\");\n+\n+\t/* and one for measuring the loop rate */\n+\tperf_counter_t loop_perf = perf_alloc(PC_INTERVAL, \"loop\");\n \n \tstruct mallinfo minfo = mallinfo();\n \tlowsyslog(\"MEM: free %u, largest %u\\n\", minfo.mxordblk, minfo.fordblks);\n \n+#if 0\n \t/* not enough memory, lock down */\n-\tif (ret != OK || minfo.mxordblk < 500) {\n+\tif (minfo.mxordblk < 500) {\n \t\tlowsyslog(\"ERR: not enough MEM\");\n \t\tbool phase = false;\n \n@@ -210,46 +188,33 @@ int user_start(int argc, char *argv[])\n \t\tphase = !phase;\n \t\tusleep(300000);\n \t}\n+#endif\n \n-\t/* start the i2c handler */\n-\ti2c_init();\n-\n-\t/* add a performance counter for mixing */\n-\tperf_counter_t mixer_perf = perf_alloc(PC_ELAPSED, \"mix\");\n-\n-\t/* \n-\t *  setup a null handler for SIGUSR1 - we will use this for wakeup from poll()\n+\t/*\n+\t * Run everything in a tight loop.\n \t */\n-        struct sigaction sa;\n-\tmemset(&sa, 0, sizeof(sa));\n-        sa.sa_sigaction = wakeup_handler;\n-\tsigfillset(&sa.sa_mask);\n-\tsigdelset(&sa.sa_mask, SIGUSR1);\n-        if (sigaction(SIGUSR1, &sa, NULL) != OK) {\n-\t\tlowsyslog(\"SIGUSR1 init fail\\n\");\n-\t}\n \n-\t/* \n-\t   run the mixer at ~50Hz, using signals to run it early if\n-\t   need be \n-\t*/\n \tuint64_t last_debug_time = 0;\n \tfor (;;) {\n-\t\t/*\n-\t\t  if we are not scheduled for 30ms then reset the I2C bus\n-\t\t */\n-\t\thrt_call_after(&loop_overtime_call, 30000, (hrt_callout)loop_overtime, NULL);\n \n-\t\t// we use usleep() instead of poll() as poll() is not\n-\t\t// interrupted by signals in nuttx, whereas usleep() is\n-\t\tusleep(20000);\n+\t\t/* track the rate at which the loop is running */\n+\t\tperf_count(loop_perf);\n \n+\t\t/* kick the mixer */\n \t\tperf_begin(mixer_perf);\n \t\tmixer_tick();\n \t\tperf_end(mixer_perf);\n \n+\t\t/* kick the control inputs */\n+\t\tperf_begin(controls_perf);\n+\t\tcontrols_tick();\n+\t\tperf_end(controls_perf);\n+\n+\t\t/* check for debug activity */\n \t\tshow_debug_messages();\n-\t\tif (hrt_absolute_time() - last_debug_time > 1000000) {\n+\n+\t\t/* post debug state at ~1Hz */\n+\t\tif (hrt_absolute_time() - last_debug_time > (1000 * 1000)) {\n \t\t\tisr_debug(1, \"d:%u s=0x%x a=0x%x f=0x%x r=%u\", \n \t\t\t\t  (unsigned)debug_level,\n \t\t\t\t  (unsigned)r_status_flags,"},{"sha":"22993fb52fcc645c4495c25d6c0548d25b950781","filename":"apps/px4io/px4io.h","status":"modified","additions":2,"deletions":6,"changes":8,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/8c7e2546ed5222145a6d1745e77d01f7c21c24fc/apps%2Fpx4io%2Fpx4io.h","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/8c7e2546ed5222145a6d1745e77d01f7c21c24fc/apps%2Fpx4io%2Fpx4io.h","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/apps%2Fpx4io%2Fpx4io.h?ref=8c7e2546ed5222145a6d1745e77d01f7c21c24fc","patch":"@@ -170,7 +170,8 @@ extern uint16_t\tadc_measure(unsigned channel);\n  *\n  * Input functions return true when they receive an update from the RC controller.\n  */\n-extern void\tcontrols_main(void);\n+extern void\tcontrols_init(void);\n+extern void\tcontrols_tick(void);\n extern int\tdsm_init(const char *device);\n extern bool\tdsm_input(uint16_t *values, uint16_t *num_values);\n extern int\tsbus_init(const char *device);\n@@ -179,11 +180,6 @@ extern bool\tsbus_input(uint16_t *values, uint16_t *num_values);\n /** global debug level for isr_debug() */\n extern volatile uint8_t debug_level;\n \n-/**\n- * Wake up mixer.\n- */\n-void daemon_wakeup(void);\n-\n /* send a debug message to the console */\n extern void isr_debug(uint8_t level, const char *fmt, ...);\n "},{"sha":"5fb90b9b0c78f9d9b55ad50a888ab50fbc946e55","filename":"apps/px4io/registers.c","status":"modified","additions":0,"deletions":4,"changes":4,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/8c7e2546ed5222145a6d1745e77d01f7c21c24fc/apps%2Fpx4io%2Fregisters.c","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/8c7e2546ed5222145a6d1745e77d01f7c21c24fc/apps%2Fpx4io%2Fregisters.c","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/apps%2Fpx4io%2Fregisters.c?ref=8c7e2546ed5222145a6d1745e77d01f7c21c24fc","patch":"@@ -203,8 +203,6 @@ registers_set(uint8_t page, uint8_t offset, const uint16_t *values, unsigned num\n \t\tr_status_flags |= PX4IO_P_STATUS_FLAGS_FMU_OK;\n \t\tr_status_flags &= ~PX4IO_P_STATUS_FLAGS_RAW_PWM;\n \t\t\n-\t\t// wake up daemon to trigger mixer\n-\t\tdaemon_wakeup();\n \t\tbreak;\n \n \t\t/* handle raw PWM input */\n@@ -224,8 +222,6 @@ registers_set(uint8_t page, uint8_t offset, const uint16_t *values, unsigned num\n \t\tsystem_state.fmu_data_received_time = hrt_absolute_time();\n \t\tr_status_flags |= PX4IO_P_STATUS_FLAGS_FMU_OK | PX4IO_P_STATUS_FLAGS_RAW_PWM;\n \n-\t\t// wake up the main thread to trigger mixer\n-\t\tdaemon_wakeup();\n \t\tbreak;\n \n \t\t/* handle setup for servo failsafe values */"},{"sha":"1145fb349fe6f56776d3a89fa07601790e7308cb","filename":"nuttx/configs/px4io/io/defconfig","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/8c7e2546ed5222145a6d1745e77d01f7c21c24fc/nuttx%2Fconfigs%2Fpx4io%2Fio%2Fdefconfig","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/8c7e2546ed5222145a6d1745e77d01f7c21c24fc/nuttx%2Fconfigs%2Fpx4io%2Fio%2Fdefconfig","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/nuttx%2Fconfigs%2Fpx4io%2Fio%2Fdefconfig?ref=8c7e2546ed5222145a6d1745e77d01f7c21c24fc","patch":"@@ -401,11 +401,11 @@ CONFIG_SCHED_ATEXIT=n\n CONFIG_DISABLE_CLOCK=n\n CONFIG_DISABLE_POSIX_TIMERS=y\n CONFIG_DISABLE_PTHREAD=y\n-CONFIG_DISABLE_SIGNALS=n\n+CONFIG_DISABLE_SIGNALS=y\n CONFIG_DISABLE_MQUEUE=y\n CONFIG_DISABLE_MOUNTPOINT=y\n CONFIG_DISABLE_ENVIRON=y\n-CONFIG_DISABLE_POLL=n\n+CONFIG_DISABLE_POLL=y\n \n #\n # Misc libc settings\n@@ -541,7 +541,7 @@ CONFIG_BOOT_COPYTORAM=n\n CONFIG_CUSTOM_STACK=n\n CONFIG_STACK_POINTER=\n CONFIG_IDLETHREAD_STACKSIZE=1024\n-CONFIG_USERMAIN_STACKSIZE=1024\n+CONFIG_USERMAIN_STACKSIZE=800\n CONFIG_PTHREAD_STACK_MIN=512\n CONFIG_PTHREAD_STACK_DEFAULT=1024\n CONFIG_HEAP_BASE="}]}