{"sha":"eac6dfed3cbc4228501a681697aa2ecf74217ebd","node_id":"MDY6Q29tbWl0NTI5ODc5MDplYWM2ZGZlZDNjYmM0MjI4NTAxYTY4MTY5N2FhMmVjZjc0MjE3ZWJk","commit":{"author":{"name":"Paul Riseborough","email":"p_riseborough@live.com.au","date":"2017-01-06T09:03:03Z"},"committer":{"name":"Lorenz Meier","email":"lorenz@px4.io","date":"2017-01-19T18:24:52Z"},"message":"mc_att_control: Sync attitude loops to gyro data\n\nSync the attitude controller to the raw gyro data to remove the latency in the rate loops caused by the sensor and estimator modules.\nAttitude data latency will increase as it will be from the previous EKF update, however attitude loops are less latency sensitive.\nThermal compensation and bias data will be from the previous frame.","tree":{"sha":"293bf86933a7bd96db1c0dae61bd1d0025d3b02a","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/293bf86933a7bd96db1c0dae61bd1d0025d3b02a"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/eac6dfed3cbc4228501a681697aa2ecf74217ebd","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/eac6dfed3cbc4228501a681697aa2ecf74217ebd","html_url":"https://github.com/PX4/PX4-Autopilot/commit/eac6dfed3cbc4228501a681697aa2ecf74217ebd","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/eac6dfed3cbc4228501a681697aa2ecf74217ebd/comments","author":{"login":"priseborough","id":3596952,"node_id":"MDQ6VXNlcjM1OTY5NTI=","avatar_url":"https://avatars.githubusercontent.com/u/3596952?v=4","gravatar_id":"","url":"https://api.github.com/users/priseborough","html_url":"https://github.com/priseborough","followers_url":"https://api.github.com/users/priseborough/followers","following_url":"https://api.github.com/users/priseborough/following{/other_user}","gists_url":"https://api.github.com/users/priseborough/gists{/gist_id}","starred_url":"https://api.github.com/users/priseborough/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/priseborough/subscriptions","organizations_url":"https://api.github.com/users/priseborough/orgs","repos_url":"https://api.github.com/users/priseborough/repos","events_url":"https://api.github.com/users/priseborough/events{/privacy}","received_events_url":"https://api.github.com/users/priseborough/received_events","type":"User","site_admin":false},"committer":{"login":"LorenzMeier","id":1208119,"node_id":"MDQ6VXNlcjEyMDgxMTk=","avatar_url":"https://avatars.githubusercontent.com/u/1208119?v=4","gravatar_id":"","url":"https://api.github.com/users/LorenzMeier","html_url":"https://github.com/LorenzMeier","followers_url":"https://api.github.com/users/LorenzMeier/followers","following_url":"https://api.github.com/users/LorenzMeier/following{/other_user}","gists_url":"https://api.github.com/users/LorenzMeier/gists{/gist_id}","starred_url":"https://api.github.com/users/LorenzMeier/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/LorenzMeier/subscriptions","organizations_url":"https://api.github.com/users/LorenzMeier/orgs","repos_url":"https://api.github.com/users/LorenzMeier/repos","events_url":"https://api.github.com/users/LorenzMeier/events{/privacy}","received_events_url":"https://api.github.com/users/LorenzMeier/received_events","type":"User","site_admin":false},"parents":[{"sha":"b2113b9abe5491c72c8fb8ce7c3922ae8a8f2239","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/b2113b9abe5491c72c8fb8ce7c3922ae8a8f2239","html_url":"https://github.com/PX4/PX4-Autopilot/commit/b2113b9abe5491c72c8fb8ce7c3922ae8a8f2239"}],"stats":{"total":152,"additions":137,"deletions":15},"files":[{"sha":"4157ee4c43a071fc22e295dd31d56930e6922c86","filename":"src/modules/mc_att_control/mc_att_control_main.cpp","status":"modified","additions":137,"deletions":15,"changes":152,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/eac6dfed3cbc4228501a681697aa2ecf74217ebd/src%2Fmodules%2Fmc_att_control%2Fmc_att_control_main.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/eac6dfed3cbc4228501a681697aa2ecf74217ebd/src%2Fmodules%2Fmc_att_control%2Fmc_att_control_main.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fmc_att_control%2Fmc_att_control_main.cpp?ref=eac6dfed3cbc4228501a681697aa2ecf74217ebd","patch":"@@ -81,6 +81,8 @@\n #include <uORB/topics/multirotor_motor_limits.h>\n #include <uORB/topics/mc_att_ctrl_status.h>\n #include <uORB/topics/battery_status.h>\n+#include <uORB/topics/sensor_gyro.h>\n+#include <uORB/topics/sensor_correction.h>\n #include <systemlib/param/param.h>\n #include <systemlib/err.h>\n #include <systemlib/perf_counter.h>\n@@ -89,6 +91,7 @@\n #include <lib/mathlib/mathlib.h>\n #include <lib/geo/geo.h>\n #include <lib/tailsitter_recovery/tailsitter_recovery.h>\n+#include <conversion/rotation.h>\n \n /**\n  * Multicopter attitude control app start / stop handling function\n@@ -108,6 +111,8 @@ extern \"C\" __EXPORT int mc_att_control_main(int argc, char *argv[]);\n #define AXIS_INDEX_YAW 2\n #define AXIS_COUNT 3\n \n+#define MAX_GYRO_COUNT 1\n+\n class MulticopterAttitudeControl\n {\n public:\n@@ -143,6 +148,11 @@ class MulticopterAttitudeControl\n \tint\t\t_vehicle_status_sub;\t/**< vehicle status subscription */\n \tint \t_motor_limits_sub;\t\t/**< motor limits subscription */\n \tint \t_battery_status_sub;\t/**< battery status subscription */\n+\tint\t_sensor_gyro_sub[MAX_GYRO_COUNT];\t/**< gyro data subscription */\n+\tint\t_sensor_correction_sub;\t/**< sensor thermal correction subscription */\n+\n+\tunsigned _gyro_count;\n+\tint _selected_gyro;\n \n \torb_advert_t\t_v_rates_sp_pub;\t\t/**< rate setpoint publication */\n \torb_advert_t\t_actuators_0_pub;\t\t/**< attitude actuator controls publication */\n@@ -164,6 +174,8 @@ class MulticopterAttitudeControl\n \tstruct multirotor_motor_limits_s\t_motor_limits;\t\t/**< motor limits */\n \tstruct mc_att_ctrl_status_s \t\t_controller_status; /**< controller status */\n \tstruct battery_status_s\t\t\t\t_battery_status;\t/**< battery status */\n+\tstruct sensor_gyro_s\t\t\t_sensor_gyro;\t\t/**< gyro data before thermal correctons and ekf bias estimates are applied */\n+\tstruct sensor_correction_s\t\t_sensor_correction;\t\t/**< sensor thermal corrections */\n \n \tunion {\n \t\tstruct {\n@@ -193,6 +205,8 @@ class MulticopterAttitudeControl\n \n \tmath::Matrix<3, 3>  _I;\t\t\t\t/**< identity matrix */\n \n+\tmath::Matrix<3, 3>\t_board_rotation = {};\t/**< rotation matrix for the orientation that the board is mounted */\n+\n \tstruct {\n \t\tparam_t roll_p;\n \t\tparam_t roll_rate_p;\n@@ -237,6 +251,10 @@ class MulticopterAttitudeControl\n \n \t\tparam_t bat_scale_en;\n \n+\t\tparam_t board_rotation;\n+\n+\t\tparam_t board_offset[3];\n+\n \t}\t\t_params_handles;\t\t/**< handles for interesting parameters */\n \n \tstruct {\n@@ -268,6 +286,11 @@ class MulticopterAttitudeControl\n \t\tfloat vtol_wv_yaw_rate_scale;\t\t\t/**< Scale value [0, 1] for yaw rate setpoint  */\n \n \t\tint bat_scale_en;\n+\n+\t\tint board_rotation;\n+\n+\t\tfloat board_offset[3];\n+\n \t}\t\t_params;\n \n \tTailsitterRecovery *_ts_opt_recovery;\t/**< Computes optimal rates for tailsitter recovery */\n@@ -337,6 +360,16 @@ class MulticopterAttitudeControl\n \t */\n \tvoid\t\tbattery_status_poll();\n \n+\t/**\n+\t * Check for control state updates.\n+\t */\n+\tvoid\t\tcontrol_state_poll();\n+\n+\t/**\n+\t * Check for sensor thermal correction updates.\n+\t */\n+\tvoid\t\tsensor_correction_poll();\n+\n \t/**\n \t * Shim for calling task_main from task_create.\n \t */\n@@ -367,6 +400,13 @@ MulticopterAttitudeControl::MulticopterAttitudeControl() :\n \t_manual_control_sp_sub(-1),\n \t_armed_sub(-1),\n \t_vehicle_status_sub(-1),\n+\t_motor_limits_sub(-1),\n+\t_battery_status_sub(-1),\n+\t_sensor_correction_sub(-1),\n+\n+\t/* gyro selection */\n+\t_gyro_count(MAX_GYRO_COUNT),\n+\t_selected_gyro(0),\n \n \t/* publications */\n \t_v_rates_sp_pub(nullptr),\n@@ -388,6 +428,8 @@ MulticopterAttitudeControl::MulticopterAttitudeControl() :\n \t_motor_limits{},\n \t_controller_status{},\n \t_battery_status{},\n+\t_sensor_gyro{},\n+\t_sensor_correction{},\n \n \t_saturation_status{},\n \t/* performance counters */\n@@ -396,6 +438,10 @@ MulticopterAttitudeControl::MulticopterAttitudeControl() :\n \t_ts_opt_recovery(nullptr)\n \n {\n+\tfor (uint8_t i = 0; i < MAX_GYRO_COUNT; i++) {\n+\t\t_sensor_gyro_sub[i] = -1;\n+\t}\n+\n \t_vehicle_status.is_rotary_wing = true;\n \n \t_params.att_p.zero();\n@@ -416,6 +462,12 @@ MulticopterAttitudeControl::MulticopterAttitudeControl() :\n \t_params.vtol_wv_yaw_rate_scale = 1.0f;\n \t_params.bat_scale_en = 0;\n \n+\t_params.board_rotation = 0;\n+\n+\t_params.board_offset[0] = 0.0f;\n+\t_params.board_offset[1] = 0.0f;\n+\t_params.board_offset[2] = 0.0f;\n+\n \t_rates_prev.zero();\n \t_rates_sp.zero();\n \t_rates_sp_prev.zero();\n@@ -424,6 +476,7 @@ MulticopterAttitudeControl::MulticopterAttitudeControl() :\n \t_att_control.zero();\n \n \t_I.identity();\n+\t_board_rotation.identity();\n \n \t_params_handles.roll_p\t\t\t= \tparam_find(\"MC_ROLL_P\");\n \t_params_handles.roll_rate_p\t\t= \tparam_find(\"MC_ROLLRATE_P\");\n@@ -465,6 +518,14 @@ MulticopterAttitudeControl::MulticopterAttitudeControl() :\n \t_params_handles.vtol_wv_yaw_rate_scale\t\t= param_find(\"VT_WV_YAWR_SCL\");\n \t_params_handles.bat_scale_en\t\t= param_find(\"MC_BAT_SCALE_EN\");\n \n+\t/* rotations */\n+\t_params_handles.board_rotation = param_find(\"SENS_BOARD_ROT\");\n+\n+\t/* rotation offsets */\n+\t_params_handles.board_offset[0] = param_find(\"SENS_BOARD_X_OFF\");\n+\t_params_handles.board_offset[1] = param_find(\"SENS_BOARD_Y_OFF\");\n+\t_params_handles.board_offset[2] = param_find(\"SENS_BOARD_Z_OFF\");\n+\n \n \n \t/* fetch initial parameter values */\n@@ -606,6 +667,14 @@ MulticopterAttitudeControl::parameters_update()\n \n \t_actuators_0_circuit_breaker_enabled = circuit_breaker_enabled(\"CBRK_RATE_CTRL\", CBRK_RATE_CTRL_KEY);\n \n+\t/* rotation of the autopilot relative to the body */\n+\tparam_get(_params_handles.board_rotation, &(_params.board_rotation));\n+\n+\t/* fine adjustment of the rotation */\n+\tparam_get(_params_handles.board_offset[0], &(_params.board_offset[0]));\n+\tparam_get(_params_handles.board_offset[1], &(_params.board_offset[1]));\n+\tparam_get(_params_handles.board_offset[2], &(_params.board_offset[2]));\n+\n \treturn OK;\n }\n \n@@ -735,6 +804,33 @@ MulticopterAttitudeControl::battery_status_poll()\n \t}\n }\n \n+void\n+MulticopterAttitudeControl::control_state_poll()\n+{\n+\t/* check if there is a new message */\n+\tbool updated;\n+\torb_check(_ctrl_state_sub, &updated);\n+\n+\tif (updated) {\n+\t\torb_copy(ORB_ID(control_state), _ctrl_state_sub, &_ctrl_state);\n+\t}\n+}\n+\n+void\n+MulticopterAttitudeControl::sensor_correction_poll()\n+{\n+\t/* check if there is a new message */\n+\tbool updated;\n+\torb_check(_sensor_correction_sub, &updated);\n+\n+\tif (updated) {\n+\t\torb_copy(ORB_ID(sensor_correction), _sensor_correction_sub, &_sensor_correction);\n+\t}\n+\n+\t/* update the latest gyro selection */\n+\t_selected_gyro = _sensor_correction.gyro_select;\n+}\n+\n /**\n  * Attitude controller.\n  * Input: 'vehicle_attitude_setpoint' topics (depending on mode)\n@@ -877,11 +973,28 @@ MulticopterAttitudeControl::control_attitude_rates(float dt)\n \t\t_rates_int.zero();\n \t}\n \n-\t/* current body angular rates */\n-\tmath::Vector<3> rates;\n-\trates(0) = _ctrl_state.roll_rate;\n-\trates(1) = _ctrl_state.pitch_rate;\n-\trates(2) = _ctrl_state.yaw_rate;\n+\t/* get transformation matrix from sensor/board to body frame */\n+\tget_rot_matrix((enum Rotation)_params.board_rotation, &_board_rotation);\n+\n+\t/* fine tune the rotation */\n+\tmath::Matrix<3, 3> board_rotation_offset;\n+\tboard_rotation_offset.from_euler(M_DEG_TO_RAD_F * _params.board_offset[0],\n+\t\t\t\t\t M_DEG_TO_RAD_F * _params.board_offset[1],\n+\t\t\t\t\t M_DEG_TO_RAD_F * _params.board_offset[2]);\n+\t_board_rotation = board_rotation_offset * _board_rotation;\n+\n+\t// get the raw gyro data and correct for thermal errors\n+\tmath::Vector<3> rates(_sensor_gyro.x * _sensor_correction.gyro_scale[0] + _sensor_correction.gyro_offset[0],\n+\t\t\t      _sensor_gyro.y * _sensor_correction.gyro_scale[1] + _sensor_correction.gyro_offset[1] ,\n+\t\t\t      _sensor_gyro.z * _sensor_correction.gyro_scale[2] + _sensor_correction.gyro_offset[2]);\n+\n+\t// rotate corrected measurements from sensor to body frame\n+\trates = _board_rotation * rates;\n+\n+\t// correct for in-run bias errors\n+\trates(0) -= _ctrl_state.roll_rate_bias;\n+\trates(1) -= _ctrl_state.pitch_rate_bias;\n+\trates(2) -= _ctrl_state.yaw_rate_bias;\n \n \tmath::Vector<3> rates_p_scaled = _params.rate_p.emult(pid_attenuations(_params.tpa_breakpoint_p, _params.tpa_rate_p));\n \tmath::Vector<3> rates_i_scaled = _params.rate_i.emult(pid_attenuations(_params.tpa_breakpoint_i, _params.tpa_rate_i));\n@@ -966,19 +1079,26 @@ MulticopterAttitudeControl::task_main()\n \t_motor_limits_sub = orb_subscribe(ORB_ID(multirotor_motor_limits));\n \t_battery_status_sub = orb_subscribe(ORB_ID(battery_status));\n \n+\t_gyro_count = orb_group_count(ORB_ID(sensor_gyro));\n+\n+\tfor (unsigned s = 0; s < _gyro_count; s++) {\n+\t\t_sensor_gyro_sub[s] = orb_subscribe_multi(ORB_ID(sensor_gyro), s);\n+\t}\n+\n+\t_sensor_correction_sub = orb_subscribe(ORB_ID(sensor_correction));\n+\n \t/* initialize parameters cache */\n \tparameters_update();\n \n-\t/* wakeup source: vehicle attitude */\n-\tpx4_pollfd_struct_t fds[1];\n-\n-\tfds[0].fd = _ctrl_state_sub;\n-\tfds[0].events = POLLIN;\n+\t/* wakeup source: gyro data from sensor selected by the sensor app */\n+\tpx4_pollfd_struct_t poll_fds = {};\n+\tpoll_fds.fd = _sensor_gyro_sub[_selected_gyro];\n+\tpoll_fds.events = POLLIN;\n \n \twhile (!_task_should_exit) {\n \n \t\t/* wait for up to 100ms for data */\n-\t\tint pret = px4_poll(&fds[0], (sizeof(fds) / sizeof(fds[0])), 100);\n+\t\tint pret = px4_poll(&poll_fds, 1, 100);\n \n \t\t/* timed out - periodic check for _task_should_exit */\n \t\tif (pret == 0) {\n@@ -995,8 +1115,8 @@ MulticopterAttitudeControl::task_main()\n \n \t\tperf_begin(_loop_perf);\n \n-\t\t/* run controller on attitude changes */\n-\t\tif (fds[0].revents & POLLIN) {\n+\t\t/* run controller on gyro changes */\n+\t\tif (poll_fds.revents & POLLIN) {\n \t\t\tstatic uint64_t last_run = 0;\n \t\t\tfloat dt = (hrt_absolute_time() - last_run) / 1000000.0f;\n \t\t\tlast_run = hrt_absolute_time();\n@@ -1009,8 +1129,8 @@ MulticopterAttitudeControl::task_main()\n \t\t\t\tdt = 0.02f;\n \t\t\t}\n \n-\t\t\t/* copy attitude and control state topics */\n-\t\t\torb_copy(ORB_ID(control_state), _ctrl_state_sub, &_ctrl_state);\n+\t\t\t/* copy gyro data */\n+\t\t\torb_copy(ORB_ID(sensor_gyro), _sensor_gyro_sub[_selected_gyro], &_sensor_gyro);\n \n \t\t\t/* check for updates in other topics */\n \t\t\tparameter_update_poll();\n@@ -1020,6 +1140,8 @@ MulticopterAttitudeControl::task_main()\n \t\t\tvehicle_status_poll();\n \t\t\tvehicle_motor_limits_poll();\n \t\t\tbattery_status_poll();\n+\t\t\tcontrol_state_poll();\n+\t\t\tsensor_correction_poll();\n \n \t\t\t/* Check if we are in rattitude mode and the pilot is above the threshold on pitch\n \t\t\t * or roll (yaw can rotate 360 in normal att control).  If both are true don't"}]}