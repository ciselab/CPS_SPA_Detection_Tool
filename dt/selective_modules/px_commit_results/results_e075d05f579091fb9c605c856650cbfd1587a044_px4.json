{"sha":"e075d05f579091fb9c605c856650cbfd1587a044","node_id":"MDY6Q29tbWl0NTI5ODc5MDplMDc1ZDA1ZjU3OTA5MWZiOWM2MDVjODU2NjUwY2JmZDE1ODdhMDQ0","commit":{"author":{"name":"Lorenz Meier","email":"lm@inf.ethz.ch","date":"2014-04-04T16:05:13Z"},"committer":{"name":"Lorenz Meier","email":"lm@inf.ethz.ch","date":"2014-04-04T16:05:13Z"},"message":"Move Pauls EKF into a class and instantiate only when / if needed. Checking for low memory conditions as we should.","tree":{"sha":"0bbecbb5bed1b838555eae13a88a4f48e36a285d","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/0bbecbb5bed1b838555eae13a88a4f48e36a285d"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/e075d05f579091fb9c605c856650cbfd1587a044","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/e075d05f579091fb9c605c856650cbfd1587a044","html_url":"https://github.com/PX4/PX4-Autopilot/commit/e075d05f579091fb9c605c856650cbfd1587a044","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/e075d05f579091fb9c605c856650cbfd1587a044/comments","author":{"login":"LorenzMeier","id":1208119,"node_id":"MDQ6VXNlcjEyMDgxMTk=","avatar_url":"https://avatars.githubusercontent.com/u/1208119?v=4","gravatar_id":"","url":"https://api.github.com/users/LorenzMeier","html_url":"https://github.com/LorenzMeier","followers_url":"https://api.github.com/users/LorenzMeier/followers","following_url":"https://api.github.com/users/LorenzMeier/following{/other_user}","gists_url":"https://api.github.com/users/LorenzMeier/gists{/gist_id}","starred_url":"https://api.github.com/users/LorenzMeier/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/LorenzMeier/subscriptions","organizations_url":"https://api.github.com/users/LorenzMeier/orgs","repos_url":"https://api.github.com/users/LorenzMeier/repos","events_url":"https://api.github.com/users/LorenzMeier/events{/privacy}","received_events_url":"https://api.github.com/users/LorenzMeier/received_events","type":"User","site_admin":false},"committer":{"login":"LorenzMeier","id":1208119,"node_id":"MDQ6VXNlcjEyMDgxMTk=","avatar_url":"https://avatars.githubusercontent.com/u/1208119?v=4","gravatar_id":"","url":"https://api.github.com/users/LorenzMeier","html_url":"https://github.com/LorenzMeier","followers_url":"https://api.github.com/users/LorenzMeier/followers","following_url":"https://api.github.com/users/LorenzMeier/following{/other_user}","gists_url":"https://api.github.com/users/LorenzMeier/gists{/gist_id}","starred_url":"https://api.github.com/users/LorenzMeier/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/LorenzMeier/subscriptions","organizations_url":"https://api.github.com/users/LorenzMeier/orgs","repos_url":"https://api.github.com/users/LorenzMeier/repos","events_url":"https://api.github.com/users/LorenzMeier/events{/privacy}","received_events_url":"https://api.github.com/users/LorenzMeier/received_events","type":"User","site_admin":false},"parents":[{"sha":"0205eebaa63016b3cf4bb03a5af230554d4a581b","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/0205eebaa63016b3cf4bb03a5af230554d4a581b","html_url":"https://github.com/PX4/PX4-Autopilot/commit/0205eebaa63016b3cf4bb03a5af230554d4a581b"}],"stats":{"total":834,"additions":431,"deletions":403},"files":[{"sha":"3ce1ce56ece255e9cddf985ee533078447f163fe","filename":"src/modules/fw_att_pos_estimator/estimator.cpp","status":"modified","additions":55,"deletions":134,"changes":189,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/e075d05f579091fb9c605c856650cbfd1587a044/src%2Fmodules%2Ffw_att_pos_estimator%2Festimator.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/e075d05f579091fb9c605c856650cbfd1587a044/src%2Fmodules%2Ffw_att_pos_estimator%2Festimator.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Ffw_att_pos_estimator%2Festimator.cpp?ref=e075d05f579091fb9c605c856650cbfd1587a044","patch":"@@ -2,85 +2,6 @@\n \n #include <string.h>\n \n-// Global variables\n-float KH[n_states][n_states]; //  intermediate result used for covariance updates\n-float KHP[n_states][n_states]; // intermediate result used for covariance updates\n-float P[n_states][n_states]; // covariance matrix\n-float Kfusion[n_states]; // Kalman gains\n-float states[n_states]; // state matrix\n-Vector3f correctedDelAng; // delta angles about the xyz body axes corrected for errors (rad)\n-Vector3f correctedDelVel; // delta velocities along the XYZ body axes corrected for errors (m/s)\n-Vector3f summedDelAng; // summed delta angles about the xyz body axes corrected for errors (rad)\n-Vector3f summedDelVel; // summed delta velocities along the XYZ body axes corrected for errors (m/s)\n-float accNavMag; // magnitude of navigation accel (- used to adjust GPS obs variance (m/s^2)\n-Vector3f earthRateNED; // earths angular rate vector in NED (rad/s)\n-Vector3f angRate; // angular rate vector in XYZ body axes measured by the IMU (rad/s)\n-Vector3f accel; // acceleration vector in XYZ body axes measured by the IMU (m/s^2)\n-Vector3f dVelIMU;\n-Vector3f dAngIMU;\n-float dtIMU; // time lapsed since the last IMU measurement or covariance update (sec)\n-uint8_t fusionModeGPS = 0; // 0 = GPS outputs 3D velocity, 1 = GPS outputs 2D velocity, 2 = GPS outputs no velocity\n-float innovVelPos[6]; // innovation output\n-float varInnovVelPos[6]; // innovation variance output\n-\n-float velNED[3]; // North, East, Down velocity obs (m/s)\n-float posNE[2]; // North, East position obs (m)\n-float hgtMea; //  measured height (m)\n-float posNED[3]; // North, East Down position (m)\n-\n-float statesAtVelTime[n_states]; // States at the effective measurement time for posNE and velNED measurements\n-float statesAtPosTime[n_states]; // States at the effective measurement time for posNE and velNED measurements\n-float statesAtHgtTime[n_states]; // States at the effective measurement time for the hgtMea measurement\n-float statesAtMagMeasTime[n_states]; // filter satates at the effective measurement time\n-float statesAtVtasMeasTime[n_states]; // filter states at the effective measurement time\n-\n-float innovMag[3]; // innovation output\n-float varInnovMag[3]; // innovation variance output\n-Vector3f magData; // magnetometer flux radings in X,Y,Z body axes\n-float innovVtas; // innovation output\n-float varInnovVtas; // innovation variance output\n-float VtasMeas; // true airspeed measurement (m/s)\n-float latRef; // WGS-84 latitude of reference point (rad)\n-float lonRef; // WGS-84 longitude of reference point (rad)\n-float hgtRef; // WGS-84 height of reference point (m)\n-Vector3f magBias; // states representing magnetometer bias vector in XYZ body axes\n-uint8_t covSkipCount = 0; // Number of state prediction frames (IMU daya updates to skip before doing the covariance prediction\n-float EAS2TAS = 1.0f; // ratio f true to equivalent airspeed\n-\n-// GPS input data variables\n-float gpsCourse;\n-float gpsVelD;\n-float gpsLat;\n-float gpsLon;\n-float gpsHgt;\n-uint8_t GPSstatus;\n-\n-float storedStates[n_states][data_buffer_size]; // state vectors stored for the last 50 time steps\n-uint32_t statetimeStamp[data_buffer_size]; // time stamp for each state vector stored\n-\n-// Baro input\n-float baroHgt;\n-\n-bool statesInitialised = false;\n-\n-bool fuseVelData = false; // this boolean causes the posNE and velNED obs to be fused\n-bool fusePosData = false; // this boolean causes the posNE and velNED obs to be fused\n-bool fuseHgtData = false; // this boolean causes the hgtMea obs to be fused\n-bool fuseMagData = false; // boolean true when magnetometer data is to be fused\n-bool fuseVtasData = false; // boolean true when airspeed data is to be fused\n-\n-bool onGround    = true;    ///< boolean true when the flight vehicle is on the ground (not flying)\n-bool staticMode  = true;    ///< boolean true if no position feedback is fused\n-bool useAirspeed = true;    ///< boolean true if airspeed data is being used\n-bool useCompass  = true;    ///< boolean true if magnetometer data is being used\n-\n-struct ekf_status_report current_ekf_state;\n-struct ekf_status_report last_ekf_error;\n-\n-bool numericalProtection = true;\n-\n-static unsigned storeIndex = 0;\n-\n float Vector3f::length(void) const\n {\n     return sqrt(x*x + y*y + z*z);\n@@ -185,7 +106,7 @@ void swap_var(float &d1, float &d2)\n     d2 = tmp;\n }\n \n-void  UpdateStrapdownEquationsNED()\n+void  AttPosEKF::UpdateStrapdownEquationsNED()\n {\n     Vector3f delVelNav;\n     float q00;\n@@ -247,7 +168,7 @@ void  UpdateStrapdownEquationsNED()\n     qUpdated[3] = states[0]*deltaQuat[3] + states[3]*deltaQuat[0] + states[1]*deltaQuat[2] - states[2]*deltaQuat[1];\n \n // Normalise the quaternions and update the quaternion states\n-    quatMag = sqrt(sq(qUpdated[0]) + sq(qUpdated[1]) + sq(qUpdated[2]) + sq(qUpdated[3]));\n+    quatMag = sqrtf(sq(qUpdated[0]) + sq(qUpdated[1]) + sq(qUpdated[2]) + sq(qUpdated[3]));\n     if (quatMag > 1e-16f)\n     {\n         float quatMagInv = 1.0f/quatMag;\n@@ -312,7 +233,7 @@ void  UpdateStrapdownEquationsNED()\n     ConstrainStates();\n }\n \n-void CovariancePrediction(float dt)\n+void AttPosEKF::CovariancePrediction(float dt)\n {\n     // scalars\n     float windVelSigma;\n@@ -953,7 +874,7 @@ void CovariancePrediction(float dt)\n     ConstrainVariances();\n }\n \n-void FuseVelposNED()\n+void AttPosEKF::FuseVelposNED()\n {\n \n // declare variables used by fault isolation logic\n@@ -999,8 +920,8 @@ void FuseVelposNED()\n         observation[5] = -(hgtMea);\n \n         // Estimate the GPS Velocity, GPS horiz position and height measurement variances.\n-        velErr = 0.2*accNavMag; // additional error in GPS velocities caused by manoeuvring\n-        posErr = 0.2*accNavMag; // additional error in GPS position caused by manoeuvring\n+        velErr = 0.2f*accNavMag; // additional error in GPS velocities caused by manoeuvring\n+        posErr = 0.2f*accNavMag; // additional error in GPS position caused by manoeuvring\n         R_OBS[0] = 0.04f + sq(velErr);\n         R_OBS[1] = R_OBS[0];\n         R_OBS[2] = 0.08f + sq(velErr);\n@@ -1026,7 +947,7 @@ void FuseVelposNED()\n                 varInnovVelPos[i] = P[stateIndex][stateIndex] + R_OBS[i];\n             }\n             // apply a 5-sigma threshold\n-            current_ekf_state.velHealth = (sq(velInnov[0]) + sq(velInnov[1]) + sq(velInnov[2])) < 25.0*(varInnovVelPos[0] + varInnovVelPos[1] + varInnovVelPos[2]);\n+            current_ekf_state.velHealth = (sq(velInnov[0]) + sq(velInnov[1]) + sq(velInnov[2])) < 25.0f * (varInnovVelPos[0] + varInnovVelPos[1] + varInnovVelPos[2]);\n             current_ekf_state.velTimeout = (millis() - current_ekf_state.velFailTime) > horizRetryTime;\n             if (current_ekf_state.velHealth || current_ekf_state.velTimeout)\n             {\n@@ -1175,7 +1096,7 @@ void FuseVelposNED()\n     //printf(\"velh: %s, posh: %s, hgth: %s\\n\", ((velHealth) ? \"OK\" : \"FAIL\"), ((posHealth) ? \"OK\" : \"FAIL\"), ((hgtHealth) ? \"OK\" : \"FAIL\"));\n }\n \n-void FuseMagnetometer()\n+void AttPosEKF::FuseMagnetometer()\n {\n     uint8_t obsIndex;\n     uint8_t indexLimit;\n@@ -1482,7 +1403,7 @@ void FuseMagnetometer()\n     ConstrainVariances();\n }\n \n-void FuseAirspeed()\n+void AttPosEKF::FuseAirspeed()\n {\n     float vn;\n     float ve;\n@@ -1503,14 +1424,14 @@ void FuseAirspeed()\n \n     // Need to check that it is flying before fusing airspeed data\n     // Calculate the predicted airspeed\n-    VtasPred = sqrt((ve - vwe)*(ve - vwe) + (vn - vwn)*(vn - vwn) + vd*vd);\n+    VtasPred = sqrtf((ve - vwe)*(ve - vwe) + (vn - vwn)*(vn - vwn) + vd*vd);\n     // Perform fusion of True Airspeed measurement\n-    if (useAirspeed && fuseVtasData && (VtasPred > 1.0) && (VtasMeas > 8.0))\n+    if (useAirspeed && fuseVtasData && (VtasPred > 1.0f) && (VtasMeas > 8.0f))\n     {\n         // Calculate observation jacobians\n         SH_TAS[0] = 1/(sqrt(sq(ve - vwe) + sq(vn - vwn) + sq(vd)));\n-        SH_TAS[1] = (SH_TAS[0]*(2*ve - 2*vwe))/2;\n-        SH_TAS[2] = (SH_TAS[0]*(2*vn - 2*vwn))/2;\n+        SH_TAS[1] = (SH_TAS[0]*(2.0f*ve - 2*vwe))/2.0f;\n+        SH_TAS[2] = (SH_TAS[0]*(2.0f*vn - 2*vwn))/2.0f;\n         \n         float H_TAS[21];\n         for (uint8_t i=0; i<=20; i++) H_TAS[i] = 0.0f;\n@@ -1611,7 +1532,7 @@ void FuseAirspeed()\n     ConstrainVariances();\n }\n \n-void zeroRows(float (&covMat)[n_states][n_states], uint8_t first, uint8_t last)\n+void AttPosEKF::zeroRows(float (&covMat)[n_states][n_states], uint8_t first, uint8_t last)\n {\n     uint8_t row;\n     uint8_t col;\n@@ -1624,7 +1545,7 @@ void zeroRows(float (&covMat)[n_states][n_states], uint8_t first, uint8_t last)\n     }\n }\n \n-void zeroCols(float (&covMat)[n_states][n_states], uint8_t first, uint8_t last)\n+void AttPosEKF::zeroCols(float (&covMat)[n_states][n_states], uint8_t first, uint8_t last)\n {\n     uint8_t row;\n     uint8_t col;\n@@ -1637,13 +1558,13 @@ void zeroCols(float (&covMat)[n_states][n_states], uint8_t first, uint8_t last)\n     }\n }\n \n-float sq(float valIn)\n+float AttPosEKF::sq(float valIn)\n {\n     return valIn*valIn;\n }\n \n // Store states in a history array along with time stamp\n-void StoreStates(uint64_t timestamp_ms)\n+void AttPosEKF::StoreStates(uint64_t timestamp_ms)\n {\n     for (unsigned i=0; i<n_states; i++)\n         storedStates[i][storeIndex] = states[i];\n@@ -1653,7 +1574,7 @@ void StoreStates(uint64_t timestamp_ms)\n         storeIndex = 0;\n }\n \n-void ResetStoredStates()\n+void AttPosEKF::ResetStoredStates()\n {\n     // reset all stored states\n     memset(&storedStates[0][0], 0, sizeof(storedStates));\n@@ -1674,7 +1595,7 @@ void ResetStoredStates()\n }\n \n // Output the state vector stored at the time that best matches that specified by msec\n-int RecallStates(float statesForFusion[n_states], uint64_t msec)\n+int AttPosEKF::RecallStates(float statesForFusion[n_states], uint64_t msec)\n {\n     int ret = 0;\n \n@@ -1723,7 +1644,7 @@ int RecallStates(float statesForFusion[n_states], uint64_t msec)\n     return ret;\n }\n \n-void quat2Tnb(Mat3f &Tnb, const float (&quat)[4])\n+void AttPosEKF::quat2Tnb(Mat3f &Tnb, const float (&quat)[4])\n {\n     // Calculate the nav to body cosine matrix\n     float q00 = sq(quat[0]);\n@@ -1748,7 +1669,7 @@ void quat2Tnb(Mat3f &Tnb, const float (&quat)[4])\n     Tnb.y.z = 2*(q23 + q01);\n }\n \n-void quat2Tbn(Mat3f &Tbn, const float (&quat)[4])\n+void AttPosEKF::quat2Tbn(Mat3f &Tbn, const float (&quat)[4])\n {\n     // Calculate the body to nav cosine matrix\n     float q00 = sq(quat[0]);\n@@ -1773,7 +1694,7 @@ void quat2Tbn(Mat3f &Tbn, const float (&quat)[4])\n     Tbn.z.y = 2*(q23 + q01);\n }\n \n-void eul2quat(float (&quat)[4], const float (&eul)[3])\n+void AttPosEKF::eul2quat(float (&quat)[4], const float (&eul)[3])\n {\n     float u1 = cos(0.5f*eul[0]);\n     float u2 = cos(0.5f*eul[1]);\n@@ -1787,57 +1708,57 @@ void eul2quat(float (&quat)[4], const float (&eul)[3])\n     quat[3] = u1*u2*u6-u4*u5*u3;\n }\n \n-void quat2eul(float (&y)[3], const float (&u)[4])\n+void AttPosEKF::quat2eul(float (&y)[3], const float (&u)[4])\n {\n-    y[0] = atan2((2.0*(u[2]*u[3]+u[0]*u[1])) , (u[0]*u[0]-u[1]*u[1]-u[2]*u[2]+u[3]*u[3]));\n-    y[1] = -asin(2.0*(u[1]*u[3]-u[0]*u[2]));\n-    y[2] = atan2((2.0*(u[1]*u[2]+u[0]*u[3])) , (u[0]*u[0]+u[1]*u[1]-u[2]*u[2]-u[3]*u[3]));\n+    y[0] = atan2f((2.0f*(u[2]*u[3]+u[0]*u[1])) , (u[0]*u[0]-u[1]*u[1]-u[2]*u[2]+u[3]*u[3]));\n+    y[1] = -asinf(2.0f*(u[1]*u[3]-u[0]*u[2]));\n+    y[2] = atan2f((2.0f*(u[1]*u[2]+u[0]*u[3])) , (u[0]*u[0]+u[1]*u[1]-u[2]*u[2]-u[3]*u[3]));\n }\n \n-void calcvelNED(float (&velNED)[3], float gpsCourse, float gpsGndSpd, float gpsVelD)\n+void AttPosEKF::calcvelNED(float (&velNED)[3], float gpsCourse, float gpsGndSpd, float gpsVelD)\n {\n-    velNED[0] = gpsGndSpd*cos(gpsCourse);\n-    velNED[1] = gpsGndSpd*sin(gpsCourse);\n+    velNED[0] = gpsGndSpd*cosf(gpsCourse);\n+    velNED[1] = gpsGndSpd*sinf(gpsCourse);\n     velNED[2] = gpsVelD;\n }\n \n-void calcposNED(float (&posNED)[3], float lat, float lon, float hgt, float latRef, float lonRef, float hgtRef)\n+void AttPosEKF::calcposNED(float (&posNED)[3], float lat, float lon, float hgt, float latRef, float lonRef, float hgtRef)\n {\n     posNED[0] = earthRadius * (lat - latRef);\n     posNED[1] = earthRadius * cos(latRef) * (lon - lonRef);\n     posNED[2] = -(hgt - hgtRef);\n }\n \n-void calcLLH(float (&posNED)[3], float lat, float lon, float hgt, float latRef, float lonRef, float hgtRef)\n+void AttPosEKF::calcLLH(float (&posNED)[3], float lat, float lon, float hgt, float latRef, float lonRef, float hgtRef)\n {\n     lat = latRef + posNED[0] * earthRadiusInv;\n     lon = lonRef + posNED[1] * earthRadiusInv / cos(latRef);\n     hgt = hgtRef - posNED[2];\n }\n \n-void OnGroundCheck()\n+void AttPosEKF::OnGroundCheck()\n {\n     onGround = (((sq(velNED[0]) + sq(velNED[1]) + sq(velNED[2])) < 4.0f) && (VtasMeas < 8.0f));\n     if (staticMode) {\n         staticMode = !(GPSstatus > GPS_FIX_2D);\n     }\n }\n \n-void calcEarthRateNED(Vector3f &omega, float latitude)\n+void AttPosEKF::calcEarthRateNED(Vector3f &omega, float latitude)\n {\n     //Define Earth rotation vector in the NED navigation frame\n     omega.x  = earthRate*cosf(latitude);\n     omega.y  = 0.0f;\n     omega.z  = -earthRate*sinf(latitude);\n }\n \n-void CovarianceInit()\n+void AttPosEKF::CovarianceInit()\n {\n     // Calculate the initial covariance matrix P\n-    P[0][0]   = 0.25f*sq(1.0f*deg2rad);\n-    P[1][1]   = 0.25f*sq(1.0f*deg2rad);\n-    P[2][2]   = 0.25f*sq(1.0f*deg2rad);\n-    P[3][3]   = 0.25f*sq(10.0f*deg2rad);\n+    P[0][0]   = 0.25f * sq(1.0f*deg2rad);\n+    P[1][1]   = 0.25f * sq(1.0f*deg2rad);\n+    P[2][2]   = 0.25f * sq(1.0f*deg2rad);\n+    P[3][3]   = 0.25f * sq(10.0f*deg2rad);\n     P[4][4]   = sq(0.7);\n     P[5][5]   = P[4][4];\n     P[6][6]   = sq(0.7);\n@@ -1857,12 +1778,12 @@ void CovarianceInit()\n     P[20][20] = P[18][18];\n }\n \n-float ConstrainFloat(float val, float min, float max)\n+float AttPosEKF::ConstrainFloat(float val, float min, float max)\n {\n     return (val > max) ? max : ((val < min) ? min : val);\n }\n \n-void ConstrainVariances()\n+void AttPosEKF::ConstrainVariances()\n {\n     if (!numericalProtection) {\n         return;\n@@ -1914,7 +1835,7 @@ void ConstrainVariances()\n \n }\n \n-void ConstrainStates()\n+void AttPosEKF::ConstrainStates()\n {\n     if (!numericalProtection) {\n         return;\n@@ -1971,7 +1892,7 @@ void ConstrainStates()\n \n }\n \n-void ForceSymmetry()\n+void AttPosEKF::ForceSymmetry()\n {\n     if (!numericalProtection) {\n         return;\n@@ -1989,7 +1910,7 @@ void ForceSymmetry()\n     }\n }\n \n-bool FilterHealthy()\n+bool AttPosEKF::FilterHealthy()\n {\n     if (!statesInitialised) {\n         return false;\n@@ -2012,7 +1933,7 @@ bool FilterHealthy()\n  * This resets the position to the last GPS measurement\n  * or to zero in case of static position.\n  */\n-void ResetPosition(void)\n+void AttPosEKF::ResetPosition(void)\n {\n     if (staticMode) {\n         states[7] = 0;\n@@ -2030,7 +1951,7 @@ void ResetPosition(void)\n  *\n  * This resets the height state with the last altitude measurements\n  */\n-void ResetHeight(void)\n+void AttPosEKF::ResetHeight(void)\n {\n     // write to the state vector\n     states[9]   = -hgtMea;\n@@ -2039,7 +1960,7 @@ void ResetHeight(void)\n /**\n  * Reset the velocity state.\n  */\n-void ResetVelocity(void)\n+void AttPosEKF::ResetVelocity(void)\n {\n     if (staticMode) {\n         states[4] = 0.0f;\n@@ -2054,7 +1975,7 @@ void ResetVelocity(void)\n }\n \n \n-void FillErrorReport(struct ekf_status_report *err)\n+void AttPosEKF::FillErrorReport(struct ekf_status_report *err)\n {\n     for (int i = 0; i < n_states; i++)\n     {\n@@ -2069,7 +1990,7 @@ void FillErrorReport(struct ekf_status_report *err)\n     err->hgtTimeout = current_ekf_state.hgtTimeout;\n }\n \n-bool StatesNaN(struct ekf_status_report *err_report) {\n+bool AttPosEKF::StatesNaN(struct ekf_status_report *err_report) {\n     bool err = false;\n \n     // check all states and covariance matrices\n@@ -2122,7 +2043,7 @@ bool StatesNaN(struct ekf_status_report *err_report) {\n  * updated, but before any of the fusion steps are\n  * executed.\n  */\n-int CheckAndBound()\n+int AttPosEKF::CheckAndBound()\n {\n \n     // Store the old filter state\n@@ -2164,7 +2085,7 @@ int CheckAndBound()\n     return 0;\n }\n \n-void AttitudeInit(float ax, float ay, float az, float mx, float my, float mz, float *initQuat)\n+void AttPosEKF::AttitudeInit(float ax, float ay, float az, float mx, float my, float mz, float *initQuat)\n {\n     float initialRoll, initialPitch;\n     float cosRoll, sinRoll, cosPitch, sinPitch;\n@@ -2200,7 +2121,7 @@ void AttitudeInit(float ax, float ay, float az, float mx, float my, float mz, fl\n     initQuat[3] = cosRoll * cosPitch * sinHeading - sinRoll * sinPitch * cosHeading;\n }\n \n-void InitializeDynamic(float (&initvelNED)[3])\n+void AttPosEKF::InitializeDynamic(float (&initvelNED)[3])\n {\n \n     // Clear the init flag\n@@ -2254,7 +2175,7 @@ void InitializeDynamic(float (&initvelNED)[3])\n     summedDelVel.z = 0.0f;\n }\n \n-void InitialiseFilter(float (&initvelNED)[3])\n+void AttPosEKF::InitialiseFilter(float (&initvelNED)[3])\n {\n     //store initial lat,long and height\n     latRef = gpsLat;\n@@ -2266,7 +2187,7 @@ void InitialiseFilter(float (&initvelNED)[3])\n     InitializeDynamic(initvelNED);\n }\n \n-void ZeroVariables()\n+void AttPosEKF::ZeroVariables()\n {\n     // Do the data structure init\n     for (unsigned i = 0; i < n_states; i++) {\n@@ -2292,12 +2213,12 @@ void ZeroVariables()\n     memset(&current_ekf_state, 0, sizeof(current_ekf_state));\n }\n \n-void GetFilterState(struct ekf_status_report *state)\n+void AttPosEKF::GetFilterState(struct ekf_status_report *state)\n {\n     memcpy(state, &current_ekf_state, sizeof(state));\n }\n \n-void GetLastErrorState(struct ekf_status_report *last_error)\n+void AttPosEKF::GetLastErrorState(struct ekf_status_report *last_error)\n {\n     memcpy(last_error, &last_ekf_error, sizeof(last_error));\n }"},{"sha":"f43f4931afeea74cf63d69a64b357947bc1f3060","filename":"src/modules/fw_att_pos_estimator/estimator.h","status":"modified","additions":177,"deletions":82,"changes":259,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/e075d05f579091fb9c605c856650cbfd1587a044/src%2Fmodules%2Ffw_att_pos_estimator%2Festimator.h","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/e075d05f579091fb9c605c856650cbfd1587a044/src%2Fmodules%2Ffw_att_pos_estimator%2Festimator.h","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Ffw_att_pos_estimator%2Festimator.h?ref=e075d05f579091fb9c605c856650cbfd1587a044","patch":"@@ -48,85 +48,85 @@ void swap_var(float &d1, float &d2);\n const unsigned int n_states = 21;\n const unsigned int data_buffer_size = 50;\n \n-extern uint32_t statetimeStamp[data_buffer_size]; // time stamp for each state vector stored\n-extern Vector3f correctedDelAng; // delta angles about the xyz body axes corrected for errors (rad)\n-extern Vector3f correctedDelVel; // delta velocities along the XYZ body axes corrected for errors (m/s)\n-extern Vector3f summedDelAng; // summed delta angles about the xyz body axes corrected for errors (rad)\n-extern Vector3f summedDelVel; // summed delta velocities along the XYZ body axes corrected for errors (m/s)\n-extern float accNavMag; // magnitude of navigation accel (- used to adjust GPS obs variance (m/s^2)\n-extern Vector3f earthRateNED; // earths angular rate vector in NED (rad/s)\n-extern Vector3f angRate; // angular rate vector in XYZ body axes measured by the IMU (rad/s)\n-extern Vector3f accel; // acceleration vector in XYZ body axes measured by the IMU (m/s^2)\n-extern Vector3f dVelIMU;\n-extern Vector3f dAngIMU;\n-\n-extern float P[n_states][n_states]; // covariance matrix\n-extern float Kfusion[n_states]; // Kalman gains\n-extern float states[n_states]; // state matrix\n-extern float storedStates[n_states][data_buffer_size]; // state vectors stored for the last 50 time steps\n-\n-extern Vector3f correctedDelAng; // delta angles about the xyz body axes corrected for errors (rad)\n-extern Vector3f correctedDelVel; // delta velocities along the XYZ body axes corrected for errors (m/s)\n-extern Vector3f summedDelAng; // summed delta angles about the xyz body axes corrected for errors (rad)\n-extern Vector3f summedDelVel; // summed delta velocities along the XYZ body axes corrected for errors (m/s)\n-\n-extern float dtIMU; // time lapsed since the last IMU measurement or covariance update (sec)\n-\n-extern bool onGround; // boolean true when the flight vehicle is on the ground (not flying)\n-extern bool useAirspeed; // boolean true if airspeed data is being used\n-extern bool useCompass; // boolean true if magnetometer data is being used\n-extern uint8_t fusionModeGPS ; // 0 = GPS outputs 3D velocity, 1 = GPS outputs 2D velocity, 2 = GPS outputs no velocity\n-extern float innovVelPos[6]; // innovation output\n-extern float varInnovVelPos[6]; // innovation variance output\n-\n-extern bool fuseVelData; // this boolean causes the posNE and velNED obs to be fused\n-extern bool fusePosData; // this boolean causes the posNE and velNED obs to be fused\n-extern bool fuseHgtData; // this boolean causes the hgtMea obs to be fused\n-extern bool fuseMagData; // boolean true when magnetometer data is to be fused\n-\n-extern float velNED[3]; // North, East, Down velocity obs (m/s)\n-extern float posNE[2]; // North, East position obs (m)\n-extern float hgtMea; //  measured height (m)\n-extern float posNED[3]; // North, East Down position (m)\n-\n-extern float statesAtVelTime[n_states]; // States at the effective measurement time for posNE and velNED measurements\n-extern float statesAtPosTime[n_states]; // States at the effective measurement time for posNE and velNED measurements\n-extern float statesAtHgtTime[n_states]; // States at the effective measurement time for the hgtMea measurement\n-\n-extern float innovMag[3]; // innovation output\n-extern float varInnovMag[3]; // innovation variance output\n-extern Vector3f magData; // magnetometer flux radings in X,Y,Z body axes\n-extern float statesAtMagMeasTime[n_states]; // filter satates at the effective measurement time\n-extern float innovVtas; // innovation output\n-extern float varInnovVtas; // innovation variance output\n-extern bool fuseVtasData; // boolean true when airspeed data is to be fused\n-extern float VtasMeas; // true airspeed measurement (m/s)\n-extern float statesAtVtasMeasTime[n_states]; // filter states at the effective measurement time\n-extern float latRef; // WGS-84 latitude of reference point (rad)\n-extern float lonRef; // WGS-84 longitude of reference point (rad)\n-extern float hgtRef; // WGS-84 height of reference point (m)\n-extern Vector3f magBias; // states representing magnetometer bias vector in XYZ body axes\n-extern uint8_t covSkipCount; // Number of state prediction frames (IMU daya updates to skip before doing the covariance prediction\n-extern float EAS2TAS; // ratio f true to equivalent airspeed\n-\n-// GPS input data variables\n-extern float gpsCourse;\n-extern float gpsVelD;\n-extern float gpsLat;\n-extern float gpsLon;\n-extern float gpsHgt;\n-extern uint8_t GPSstatus;\n-\n-// Baro input\n-extern float baroHgt;\n-\n-extern bool statesInitialised;\n-extern bool numericalProtection;\n+// extern uint32_t statetimeStamp[data_buffer_size]; // time stamp for each state vector stored\n+// extern Vector3f correctedDelAng; // delta angles about the xyz body axes corrected for errors (rad)\n+// extern Vector3f correctedDelVel; // delta velocities along the XYZ body axes corrected for errors (m/s)\n+// extern Vector3f summedDelAng; // summed delta angles about the xyz body axes corrected for errors (rad)\n+// extern Vector3f summedDelVel; // summed delta velocities along the XYZ body axes corrected for errors (m/s)\n+// extern float accNavMag; // magnitude of navigation accel (- used to adjust GPS obs variance (m/s^2)\n+// extern Vector3f earthRateNED; // earths angular rate vector in NED (rad/s)\n+// extern Vector3f angRate; // angular rate vector in XYZ body axes measured by the IMU (rad/s)\n+// extern Vector3f accel; // acceleration vector in XYZ body axes measured by the IMU (m/s^2)\n+// extern Vector3f dVelIMU;\n+// extern Vector3f dAngIMU;\n+\n+// extern float P[n_states][n_states]; // covariance matrix\n+// extern float Kfusion[n_states]; // Kalman gains\n+// extern float states[n_states]; // state matrix\n+// extern float storedStates[n_states][data_buffer_size]; // state vectors stored for the last 50 time steps\n+\n+// extern Vector3f correctedDelAng; // delta angles about the xyz body axes corrected for errors (rad)\n+// extern Vector3f correctedDelVel; // delta velocities along the XYZ body axes corrected for errors (m/s)\n+// extern Vector3f summedDelAng; // summed delta angles about the xyz body axes corrected for errors (rad)\n+// extern Vector3f summedDelVel; // summed delta velocities along the XYZ body axes corrected for errors (m/s)\n+\n+// extern float dtIMU; // time lapsed since the last IMU measurement or covariance update (sec)\n+\n+// extern bool onGround; // boolean true when the flight vehicle is on the ground (not flying)\n+// extern bool useAirspeed; // boolean true if airspeed data is being used\n+// extern bool useCompass; // boolean true if magnetometer data is being used\n+// extern uint8_t fusionModeGPS ; // 0 = GPS outputs 3D velocity, 1 = GPS outputs 2D velocity, 2 = GPS outputs no velocity\n+// extern float innovVelPos[6]; // innovation output\n+// extern float varInnovVelPos[6]; // innovation variance output\n+\n+// extern bool fuseVelData; // this boolean causes the posNE and velNED obs to be fused\n+// extern bool fusePosData; // this boolean causes the posNE and velNED obs to be fused\n+// extern bool fuseHgtData; // this boolean causes the hgtMea obs to be fused\n+// extern bool fuseMagData; // boolean true when magnetometer data is to be fused\n+\n+// extern float velNED[3]; // North, East, Down velocity obs (m/s)\n+// extern float posNE[2]; // North, East position obs (m)\n+// extern float hgtMea; //  measured height (m)\n+// extern float posNED[3]; // North, East Down position (m)\n+\n+// extern float statesAtVelTime[n_states]; // States at the effective measurement time for posNE and velNED measurements\n+// extern float statesAtPosTime[n_states]; // States at the effective measurement time for posNE and velNED measurements\n+// extern float statesAtHgtTime[n_states]; // States at the effective measurement time for the hgtMea measurement\n+\n+// extern float innovMag[3]; // innovation output\n+// extern float varInnovMag[3]; // innovation variance output\n+// extern Vector3f magData; // magnetometer flux radings in X,Y,Z body axes\n+// extern float statesAtMagMeasTime[n_states]; // filter satates at the effective measurement time\n+// extern float innovVtas; // innovation output\n+// extern float varInnovVtas; // innovation variance output\n+// extern bool fuseVtasData; // boolean true when airspeed data is to be fused\n+// extern float VtasMeas; // true airspeed measurement (m/s)\n+// extern float statesAtVtasMeasTime[n_states]; // filter states at the effective measurement time\n+// extern float latRef; // WGS-84 latitude of reference point (rad)\n+// extern float lonRef; // WGS-84 longitude of reference point (rad)\n+// extern float hgtRef; // WGS-84 height of reference point (m)\n+// extern Vector3f magBias; // states representing magnetometer bias vector in XYZ body axes\n+// extern uint8_t covSkipCount; // Number of state prediction frames (IMU daya updates to skip before doing the covariance prediction\n+// extern float EAS2TAS; // ratio f true to equivalent airspeed\n+\n+// // GPS input data variables\n+// extern float gpsCourse;\n+// extern float gpsVelD;\n+// extern float gpsLat;\n+// extern float gpsLon;\n+// extern float gpsHgt;\n+// extern uint8_t GPSstatus;\n+\n+// // Baro input\n+// extern float baroHgt;\n+\n+// extern bool statesInitialised;\n+// extern bool numericalProtection;\n \n const float covTimeStepMax = 0.07f; // maximum time allowed between covariance predictions\n const float covDelAngMax = 0.02f; // maximum delta angle between covariance predictions\n \n-extern bool staticMode;\n+// extern bool staticMode;\n \n enum GPS_FIX {\n     GPS_FIX_NOFIX = 0,\n@@ -150,6 +150,89 @@ struct ekf_status_report {\n     bool kalmanGainsNaN;\n };\n \n+class AttPosEKF {\n+\n+public:\n+    // Global variables\n+    float KH[n_states][n_states]; //  intermediate result used for covariance updates\n+    float KHP[n_states][n_states]; // intermediate result used for covariance updates\n+    float P[n_states][n_states]; // covariance matrix\n+    float Kfusion[n_states]; // Kalman gains\n+    float states[n_states]; // state matrix\n+    float storedStates[n_states][data_buffer_size]; // state vectors stored for the last 50 time steps\n+    uint32_t statetimeStamp[data_buffer_size]; // time stamp for each state vector stored\n+\n+    float statesAtVelTime[n_states]; // States at the effective measurement time for posNE and velNED measurements\n+    float statesAtPosTime[n_states]; // States at the effective measurement time for posNE and velNED measurements\n+    float statesAtHgtTime[n_states]; // States at the effective measurement time for the hgtMea measurement\n+    float statesAtMagMeasTime[n_states]; // filter satates at the effective measurement time\n+    float statesAtVtasMeasTime[n_states]; // filter states at the effective measurement time\n+\n+    Vector3f correctedDelAng; // delta angles about the xyz body axes corrected for errors (rad)\n+    Vector3f correctedDelVel; // delta velocities along the XYZ body axes corrected for errors (m/s)\n+    Vector3f summedDelAng; // summed delta angles about the xyz body axes corrected for errors (rad)\n+    Vector3f summedDelVel; // summed delta velocities along the XYZ body axes corrected for errors (m/s)\n+    float accNavMag; // magnitude of navigation accel (- used to adjust GPS obs variance (m/s^2)\n+    Vector3f earthRateNED; // earths angular rate vector in NED (rad/s)\n+    Vector3f angRate; // angular rate vector in XYZ body axes measured by the IMU (rad/s)\n+    Vector3f accel; // acceleration vector in XYZ body axes measured by the IMU (m/s^2)\n+    Vector3f dVelIMU;\n+    Vector3f dAngIMU;\n+    float dtIMU; // time lapsed since the last IMU measurement or covariance update (sec)\n+    uint8_t fusionModeGPS = 0; // 0 = GPS outputs 3D velocity, 1 = GPS outputs 2D velocity, 2 = GPS outputs no velocity\n+    float innovVelPos[6]; // innovation output\n+    float varInnovVelPos[6]; // innovation variance output\n+\n+    float velNED[3]; // North, East, Down velocity obs (m/s)\n+    float posNE[2]; // North, East position obs (m)\n+    float hgtMea; //  measured height (m)\n+    float posNED[3]; // North, East Down position (m)\n+\n+    float innovMag[3]; // innovation output\n+    float varInnovMag[3]; // innovation variance output\n+    Vector3f magData; // magnetometer flux radings in X,Y,Z body axes\n+    float innovVtas; // innovation output\n+    float varInnovVtas; // innovation variance output\n+    float VtasMeas; // true airspeed measurement (m/s)\n+    float latRef; // WGS-84 latitude of reference point (rad)\n+    float lonRef; // WGS-84 longitude of reference point (rad)\n+    float hgtRef; // WGS-84 height of reference point (m)\n+    Vector3f magBias; // states representing magnetometer bias vector in XYZ body axes\n+    uint8_t covSkipCount = 0; // Number of state prediction frames (IMU daya updates to skip before doing the covariance prediction\n+    float EAS2TAS = 1.0f; // ratio f true to equivalent airspeed\n+\n+    // GPS input data variables\n+    float gpsCourse;\n+    float gpsVelD;\n+    float gpsLat;\n+    float gpsLon;\n+    float gpsHgt;\n+    uint8_t GPSstatus;\n+\n+    // Baro input\n+    float baroHgt;\n+\n+    bool statesInitialised = false;\n+\n+    bool fuseVelData = false; // this boolean causes the posNE and velNED obs to be fused\n+    bool fusePosData = false; // this boolean causes the posNE and velNED obs to be fused\n+    bool fuseHgtData = false; // this boolean causes the hgtMea obs to be fused\n+    bool fuseMagData = false; // boolean true when magnetometer data is to be fused\n+    bool fuseVtasData = false; // boolean true when airspeed data is to be fused\n+\n+    bool onGround    = true;    ///< boolean true when the flight vehicle is on the ground (not flying)\n+    bool staticMode  = true;    ///< boolean true if no position feedback is fused\n+    bool useAirspeed = true;    ///< boolean true if airspeed data is being used\n+    bool useCompass  = true;    ///< boolean true if magnetometer data is being used\n+\n+    struct ekf_status_report current_ekf_state;\n+    struct ekf_status_report last_ekf_error;\n+\n+    bool numericalProtection = true;\n+\n+    unsigned storeIndex = 0;\n+\n+\n void  UpdateStrapdownEquationsNED();\n \n void CovariancePrediction(float dt);\n@@ -164,8 +247,6 @@ void zeroRows(float (&covMat)[n_states][n_states], uint8_t first, uint8_t last);\n \n void zeroCols(float (&covMat)[n_states][n_states], uint8_t first, uint8_t last);\n \n-float sq(float valIn);\n-\n void quatNorm(float (&quatOut)[4], const float quatIn[4]);\n \n // store staes along with system time stamp in msces\n@@ -190,15 +271,19 @@ void quat2Tbn(Mat3f &Tbn, const float (&quat)[4]);\n \n void calcEarthRateNED(Vector3f &omega, float latitude);\n \n-void eul2quat(float (&quat)[4], const float (&eul)[3]);\n+static void eul2quat(float (&quat)[4], const float (&eul)[3]);\n+\n+static void quat2eul(float (&eul)[3], const float (&quat)[4]);\n+\n+static void calcvelNED(float (&velNED)[3], float gpsCourse, float gpsGndSpd, float gpsVelD);\n \n-void quat2eul(float (&eul)[3], const float (&quat)[4]);\n+static void calcposNED(float (&posNED)[3], float lat, float lon, float hgt, float latRef, float lonRef, float hgtRef);\n \n-void calcvelNED(float (&velNED)[3], float gpsCourse, float gpsGndSpd, float gpsVelD);\n+static void calcLLH(float (&posNED)[3], float lat, float lon, float hgt, float latRef, float lonRef, float hgtRef);\n \n-void calcposNED(float (&posNED)[3], float lat, float lon, float hgt, float latRef, float lonRef, float hgtRef);\n+static void quat2Tnb(Mat3f &Tnb, const float (&quat)[4]);\n \n-void calcLLH(float (&posNED)[3], float lat, float lon, float hgt, float latRef, float lonRef, float hgtRef);\n+static float sq(float valIn);\n \n void OnGroundCheck();\n \n@@ -231,5 +316,15 @@ void FillErrorReport(struct ekf_status_report *err);\n \n void InitializeDynamic(float (&initvelNED)[3]);\n \n+protected:\n+\n+bool FilterHealthy();\n+\n+void ResetHeight(void);\n+\n+void AttitudeInit(float ax, float ay, float az, float mx, float my, float mz, float *initQuat);\n+\n+};\n+\n uint32_t millis();\n "},{"sha":"20c5d37190cc2208fc527fb7aecb2a41087c9b46","filename":"src/modules/fw_att_pos_estimator/fw_att_pos_estimator_main.cpp","status":"modified","additions":199,"deletions":187,"changes":386,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/e075d05f579091fb9c605c856650cbfd1587a044/src%2Fmodules%2Ffw_att_pos_estimator%2Ffw_att_pos_estimator_main.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/e075d05f579091fb9c605c856650cbfd1587a044/src%2Fmodules%2Ffw_att_pos_estimator%2Ffw_att_pos_estimator_main.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Ffw_att_pos_estimator%2Ffw_att_pos_estimator_main.cpp?ref=e075d05f579091fb9c605c856650cbfd1587a044","patch":"@@ -124,6 +124,16 @@ class FixedwingEstimator\n \t */\n \tint\t\tstart();\n \n+\t/**\n+\t * Print the current status.\n+\t */\n+\tvoid\t\tprint_status();\n+\n+\t/**\n+\t * Trip the filter by feeding it NaN values.\n+\t */\n+\tint\t\ttrip_nan();\n+\n private:\n \n \tbool\t\t_task_should_exit;\t\t/**< if true, sensor task should exit */\n@@ -199,6 +209,7 @@ class FixedwingEstimator\n \t\tparam_t\ttas_delay_ms;\n \t}\t\t_parameter_handles;\t\t/**< handles for interesting parameters */\n \n+\tAttPosEKF\t\t\t\t\t*_ekf;\n \n \t/**\n \t * Update our local parameter cache.\n@@ -280,7 +291,8 @@ FixedwingEstimator::FixedwingEstimator() :\n /* states */\n \t_initialized(false),\n \t_gps_initialized(false),\n-\t_mavlink_fd(-1)\n+\t_mavlink_fd(-1),\n+\t_ekf(new AttPosEKF())\n {\n \n \t_mavlink_fd = open(MAVLINK_LOG_DEVICE, 0);\n@@ -384,6 +396,10 @@ void\n FixedwingEstimator::task_main()\n {\n \n+\tif (!_ekf) {\n+\t\terrx(1, \"failed allocating EKF filter - out of RAM!\");\n+\t}\n+\n \t/*\n \t * do subscriptions\n \t */\n@@ -414,23 +430,23 @@ FixedwingEstimator::task_main()\n \tparameters_update();\n \n \t/* set initial filter state */\n-\tfuseVelData = false;\n-\tfusePosData = false;\n-\tfuseHgtData = false;\n-\tfuseMagData = false;\n-\tfuseVtasData = false;\n-\tstatesInitialised = false;\n+\t_ekf->fuseVelData = false;\n+\t_ekf->fusePosData = false;\n+\t_ekf->fuseHgtData = false;\n+\t_ekf->fuseMagData = false;\n+\t_ekf->fuseVtasData = false;\n+\t_ekf->statesInitialised = false;\n \n \t/* initialize measurement data */\n-\tVtasMeas = 0.0f;\n+\t_ekf->VtasMeas = 0.0f;\n \tVector3f lastAngRate = {0.0f, 0.0f, 0.0f};\n \tVector3f lastAccel = {0.0f, 0.0f, -9.81f};\n-\tdVelIMU.x = 0.0f;\n-\tdVelIMU.y = 0.0f;\n-\tdVelIMU.z = 0.0f;\n-\tdAngIMU.x = 0.0f;\n-\tdAngIMU.y = 0.0f;\n-\tdAngIMU.z = 0.0f;\n+\t_ekf->dVelIMU.x = 0.0f;\n+\t_ekf->dVelIMU.y = 0.0f;\n+\t_ekf->dVelIMU.z = 0.0f;\n+\t_ekf->dAngIMU.x = 0.0f;\n+\t_ekf->dAngIMU.y = 0.0f;\n+\t_ekf->dAngIMU.z = 0.0f;\n \n \t/* wakeup source(s) */\n \tstruct pollfd fds[2];\n@@ -509,7 +525,7 @@ FixedwingEstimator::task_main()\n \t\t\t}\n \n \t\t\tlast_sensor_timestamp = _gyro.timestamp;\n-\t\t\tIMUmsec = _gyro.timestamp / 1e3f;\n+\t\t\t_ekf.IMUmsec = _gyro.timestamp / 1e3f;\n \n \t\t\tfloat deltaT = (_gyro.timestamp - last_run) / 1e6f;\n \t\t\tlast_run = _gyro.timestamp;\n@@ -521,20 +537,20 @@ FixedwingEstimator::task_main()\n \n \t\t\t// Always store data, independent of init status\n \t\t\t/* fill in last data set */\n-\t\t\tdtIMU = deltaT;\n+\t\t\t_ekf->dtIMU = deltaT;\n \n-\t\t\tangRate.x = _gyro.x;\n-\t\t\tangRate.y = _gyro.y;\n-\t\t\tangRate.z = _gyro.z;\n+\t\t\t_ekf->angRate.x = _gyro.x;\n+\t\t\t_ekf->angRate.y = _gyro.y;\n+\t\t\t_ekf->angRate.z = _gyro.z;\n \n-\t\t\taccel.x = _accel.x;\n-\t\t\taccel.y = _accel.y;\n-\t\t\taccel.z = _accel.z;\n+\t\t\t_ekf->accel.x = _accel.x;\n+\t\t\t_ekf->accel.y = _accel.y;\n+\t\t\t_ekf->accel.z = _accel.z;\n \n-\t\t\tdAngIMU = 0.5f * (angRate + lastAngRate) * dtIMU;\n-\t\t\tlastAngRate = angRate;\n-\t\t\tdVelIMU = 0.5f * (accel + lastAccel) * dtIMU;\n-\t\t\tlastAccel = accel;\n+\t\t\t_ekf->dAngIMU = 0.5f * (angRate + lastAngRate) * dtIMU;\n+\t\t\t_ekf->lastAngRate = angRate;\n+\t\t\t_ekf->dVelIMU = 0.5f * (accel + lastAccel) * dtIMU;\n+\t\t\t_ekf->lastAccel = accel;\n \n \n #else\n@@ -563,20 +579,20 @@ FixedwingEstimator::task_main()\n \n \t\t\t// Always store data, independent of init status\n \t\t\t/* fill in last data set */\n-\t\t\tdtIMU = deltaT;\n+\t\t\t_ekf->dtIMU = deltaT;\n \n-\t\t\tangRate.x = _sensor_combined.gyro_rad_s[0];\n-\t\t\tangRate.y = _sensor_combined.gyro_rad_s[1];\n-\t\t\tangRate.z = _sensor_combined.gyro_rad_s[2];\n+\t\t\t_ekf->angRate.x = _sensor_combined.gyro_rad_s[0];\n+\t\t\t_ekf->angRate.y = _sensor_combined.gyro_rad_s[1];\n+\t\t\t_ekf->angRate.z = _sensor_combined.gyro_rad_s[2];\n \n-\t\t\taccel.x = _sensor_combined.accelerometer_m_s2[0];\n-\t\t\taccel.y = _sensor_combined.accelerometer_m_s2[1];\n-\t\t\taccel.z = _sensor_combined.accelerometer_m_s2[2];\n+\t\t\t_ekf->accel.x = _sensor_combined.accelerometer_m_s2[0];\n+\t\t\t_ekf->accel.y = _sensor_combined.accelerometer_m_s2[1];\n+\t\t\t_ekf->accel.z = _sensor_combined.accelerometer_m_s2[2];\n \n-\t\t\tdAngIMU = 0.5f * (angRate + lastAngRate) * dtIMU;\n-\t\t\tlastAngRate = angRate;\n-\t\t\tdVelIMU = 0.5f * (accel + lastAccel) * dtIMU;\n-\t\t\tlastAccel = accel;\n+\t\t\t_ekf->dAngIMU = 0.5f * (_ekf->angRate + lastAngRate) * _ekf->dtIMU;\n+\t\t\tlastAngRate = _ekf->angRate;\n+\t\t\t_ekf->dVelIMU = 0.5f * (_ekf->accel + lastAccel) * _ekf->dtIMU;\n+\t\t\tlastAccel = _ekf->accel;\n \n \t\t\tif (last_mag != _sensor_combined.magnetometer_timestamp) {\n \t\t\t\tmag_updated = true;\n@@ -597,7 +613,7 @@ FixedwingEstimator::task_main()\n \t\t\t\torb_copy(ORB_ID(airspeed), _airspeed_sub, &_airspeed);\n \t\t\t\tperf_count(_perf_airspeed);\n \n-\t\t\t\tVtasMeas = _airspeed.true_airspeed_m_s;\n+\t\t\t\t_ekf->VtasMeas = _airspeed.true_airspeed_m_s;\n \t\t\t\tnewAdsData = true;\n \n \t\t\t} else {\n@@ -622,24 +638,24 @@ FixedwingEstimator::task_main()\n \n \t\t\t\t\t/* check if we had a GPS outage for a long time */\n \t\t\t\t\tif (hrt_elapsed_time(&last_gps) > 5 * 1000 * 1000) {\n-\t\t\t\t\t\tResetPosition();\n-\t\t\t\t\t\tResetVelocity();\n-\t\t\t\t\t\tResetStoredStates();\n+\t\t\t\t\t\t_ekf->ResetPosition();\n+\t\t\t\t\t\t_ekf->ResetVelocity();\n+\t\t\t\t\t\t_ekf->ResetStoredStates();\n \t\t\t\t\t}\n \n \t\t\t\t\t/* fuse GPS updates */\n \n \t\t\t\t\t//_gps.timestamp / 1e3;\n-\t\t\t\t\tGPSstatus = _gps.fix_type;\n-\t\t\t\t\tvelNED[0] = _gps.vel_n_m_s;\n-\t\t\t\t\tvelNED[1] = _gps.vel_e_m_s;\n-\t\t\t\t\tvelNED[2] = _gps.vel_d_m_s;\n+\t\t\t\t\t_ekf->GPSstatus = _gps.fix_type;\n+\t\t\t\t\t_ekf->velNED[0] = _gps.vel_n_m_s;\n+\t\t\t\t\t_ekf->velNED[1] = _gps.vel_e_m_s;\n+\t\t\t\t\t_ekf->velNED[2] = _gps.vel_d_m_s;\n \n \t\t\t\t\t// warnx(\"GPS updated: status: %d, vel: %8.4f %8.4f %8.4f\", (int)GPSstatus, velNED[0], velNED[1], velNED[2]);\n \n-\t\t\t\t\tgpsLat = math::radians(_gps.lat / (double)1e7);\n-\t\t\t\t\tgpsLon = math::radians(_gps.lon / (double)1e7) - M_PI;\n-\t\t\t\t\tgpsHgt = _gps.alt / 1e3f;\n+\t\t\t\t\t_ekf->gpsLat = math::radians(_gps.lat / (double)1e7);\n+\t\t\t\t\t_ekf->gpsLon = math::radians(_gps.lon / (double)1e7) - M_PI;\n+\t\t\t\t\t_ekf->gpsHgt = _gps.alt / 1e3f;\n \t\t\t\t\tnewDataGps = true;\n \n \t\t\t\t}\n@@ -652,10 +668,10 @@ FixedwingEstimator::task_main()\n \t\t\tif (baro_updated) {\n \t\t\t\torb_copy(ORB_ID(sensor_baro), _baro_sub, &_baro);\n \n-\t\t\t\tbaroHgt = _baro.altitude - _baro_ref;\n+\t\t\t\t_ekf->baroHgt = _baro.altitude - _baro_ref;\n \n \t\t\t\t// Could use a blend of GPS and baro alt data if desired\n-\t\t\t\thgtMea = 1.0f * baroHgt + 0.0f * gpsHgt;\n+\t\t\t\t_ekf->hgtMea = 1.0f * _ekf->baroHgt + 0.0f * _ekf->gpsHgt;\n \t\t\t}\n \n #ifndef SENSOR_COMBINED_SUB\n@@ -671,27 +687,27 @@ FixedwingEstimator::task_main()\n \n \t\t\t\t// XXX we compensate the offsets upfront - should be close to zero.\n \t\t\t\t// 0.001f\n-\t\t\t\tmagData.x = _mag.x;\n-\t\t\t\tmagBias.x = 0.000001f; // _mag_offsets.x_offset\n+\t\t\t\t_ekf->magData.x = _mag.x;\n+\t\t\t\t_ekf->magBias.x = 0.000001f; // _mag_offsets.x_offset\n \n-\t\t\t\tmagData.y = _mag.y;\n-\t\t\t\tmagBias.y = 0.000001f; // _mag_offsets.y_offset\n+\t\t\t\t_ekf->magData.y = _mag.y;\n+\t\t\t\t_ekf->magBias.y = 0.000001f; // _mag_offsets.y_offset\n \n-\t\t\t\tmagData.z = _mag.z;\n-\t\t\t\tmagBias.z = 0.000001f; // _mag_offsets.y_offset\n+\t\t\t\t_ekf->magData.z = _mag.z;\n+\t\t\t\t_ekf->magBias.z = 0.000001f; // _mag_offsets.y_offset\n \n #else\n \n \t\t\t\t// XXX we compensate the offsets upfront - should be close to zero.\n \t\t\t\t// 0.001f\n-\t\t\t\tmagData.x = _sensor_combined.magnetometer_ga[0];\n-\t\t\t\tmagBias.x = 0.000001f; // _mag_offsets.x_offset\n+\t\t\t\t_ekf->magData.x = _sensor_combined.magnetometer_ga[0];\n+\t\t\t\t_ekf->magBias.x = 0.000001f; // _mag_offsets.x_offset\n \n-\t\t\t\tmagData.y = _sensor_combined.magnetometer_ga[1];\n-\t\t\t\tmagBias.y = 0.000001f; // _mag_offsets.y_offset\n+\t\t\t\t_ekf->magData.y = _sensor_combined.magnetometer_ga[1];\n+\t\t\t\t_ekf->magBias.y = 0.000001f; // _mag_offsets.y_offset\n \n-\t\t\t\tmagData.z = _sensor_combined.magnetometer_ga[2];\n-\t\t\t\tmagBias.z = 0.000001f; // _mag_offsets.y_offset\n+\t\t\t\t_ekf->magData.z = _sensor_combined.magnetometer_ga[2];\n+\t\t\t\t_ekf->magBias.z = 0.000001f; // _mag_offsets.y_offset\n \n #endif\n \n@@ -705,7 +721,7 @@ FixedwingEstimator::task_main()\n \t\t\t/**\n \t\t\t *    CHECK IF THE INPUT DATA IS SANE\n \t\t\t */\n-\t\t\tint check = CheckAndBound();\n+\t\t\tint check = _ekf->CheckAndBound();\n \n \t\t\tswitch (check) {\n \t\t\t\tcase 0:\n@@ -739,7 +755,7 @@ FixedwingEstimator::task_main()\n \n \t\t\t\tstruct ekf_status_report ekf_report;\n \n-\t\t\t\tGetLastErrorState(&ekf_report);\n+\t\t\t\t_ekf->GetLastErrorState(&ekf_report);\n \n \t\t\t\tstruct estimator_status_report rep;\n \t\t\t\tmemset(&rep, 0, sizeof(rep));\n@@ -779,16 +795,16 @@ FixedwingEstimator::task_main()\n \n \t\t\tif (hrt_elapsed_time(&start_time) > 100000) {\n \n-\t\t\t\tif (!_gps_initialized && (GPSstatus == 3)) {\n-\t\t\t\t\tvelNED[0] = _gps.vel_n_m_s;\n-\t\t\t\t\tvelNED[1] = _gps.vel_e_m_s;\n-\t\t\t\t\tvelNED[2] = _gps.vel_d_m_s;\n+\t\t\t\tif (!_gps_initialized && (_ekf->GPSstatus == 3)) {\n+\t\t\t\t\t_ekf->velNED[0] = _gps.vel_n_m_s;\n+\t\t\t\t\t_ekf->velNED[1] = _gps.vel_e_m_s;\n+\t\t\t\t\t_ekf->velNED[2] = _gps.vel_d_m_s;\n \n \t\t\t\t\tdouble lat = _gps.lat * 1e-7;\n \t\t\t\t\tdouble lon = _gps.lon * 1e-7;\n \t\t\t\t\tfloat alt = _gps.alt * 1e-3;\n \n-\t\t\t\t\tInitialiseFilter(velNED);\n+\t\t\t\t\t_ekf->InitialiseFilter(_ekf->velNED);\n \n \t\t\t\t\t// Initialize projection\n \t\t\t\t\t_local_pos.ref_lat = _gps.lat;\n@@ -799,7 +815,7 @@ FixedwingEstimator::task_main()\n \t\t\t\t\t// Store \n \t\t\t\t\torb_copy(ORB_ID(sensor_baro), _baro_sub, &_baro);\n \t\t\t\t\t_baro_ref = _baro.altitude;\n-\t\t\t\t\tbaroHgt = _baro.altitude - _baro_ref;\n+\t\t\t\t\t_ekf->baroHgt = _baro.altitude - _baro_ref;\n \t\t\t\t\t_baro_gps_offset = _baro_ref - _local_pos.ref_alt;\n \n \t\t\t\t\t// XXX this is not multithreading safe\n@@ -808,24 +824,24 @@ FixedwingEstimator::task_main()\n \n \t\t\t\t\t_gps_initialized = true;\n \n-\t\t\t\t} else if (!statesInitialised) {\n-\t\t\t\t\tvelNED[0] = 0.0f;\n-\t\t\t\t\tvelNED[1] = 0.0f;\n-\t\t\t\t\tvelNED[2] = 0.0f;\n-\t\t\t\t\tposNED[0] = 0.0f;\n-\t\t\t\t\tposNED[1] = 0.0f;\n-\t\t\t\t\tposNED[2] = 0.0f;\n-\n-\t\t\t\t\tposNE[0] = posNED[0];\n-\t\t\t\t\tposNE[1] = posNED[1];\n-\t\t\t\t\tInitialiseFilter(velNED);\n+\t\t\t\t} else if (!_ekf->statesInitialised) {\n+\t\t\t\t\t_ekf->velNED[0] = 0.0f;\n+\t\t\t\t\t_ekf->velNED[1] = 0.0f;\n+\t\t\t\t\t_ekf->velNED[2] = 0.0f;\n+\t\t\t\t\t_ekf->posNED[0] = 0.0f;\n+\t\t\t\t\t_ekf->posNED[1] = 0.0f;\n+\t\t\t\t\t_ekf->posNED[2] = 0.0f;\n+\n+\t\t\t\t\t_ekf->posNE[0] = _ekf->posNED[0];\n+\t\t\t\t\t_ekf->posNE[1] = _ekf->posNED[1];\n+\t\t\t\t\t_ekf->InitialiseFilter(_ekf->velNED);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t// If valid IMU data and states initialised, predict states and covariances\n-\t\t\tif (statesInitialised) {\n+\t\t\tif (_ekf->statesInitialised) {\n \t\t\t\t// Run the strapdown INS equations every IMU update\n-\t\t\t\tUpdateStrapdownEquationsNED();\n+\t\t\t\t_ekf->UpdateStrapdownEquationsNED();\n #if 0\n \t\t\t\t// debug code - could be tunred into a filter mnitoring/watchdog function\n \t\t\t\tfloat tempQuat[4];\n@@ -842,20 +858,20 @@ FixedwingEstimator::task_main()\n \n #endif\n \t\t\t\t// store the predicted states for subsequent use by measurement fusion\n-\t\t\t\tStoreStates(IMUmsec);\n+\t\t\t\t_ekf->StoreStates(IMUmsec);\n \t\t\t\t// Check if on ground - status is used by covariance prediction\n-\t\t\t\tOnGroundCheck();\n+\t\t\t\t_ekf->OnGroundCheck();\n \t\t\t\t// sum delta angles and time used by covariance prediction\n-\t\t\t\tsummedDelAng = summedDelAng + correctedDelAng;\n-\t\t\t\tsummedDelVel = summedDelVel + dVelIMU;\n-\t\t\t\tdt += dtIMU;\n+\t\t\t\t_ekf->summedDelAng = _ekf->summedDelAng + _ekf->correctedDelAng;\n+\t\t\t\t_ekf->summedDelVel = _ekf->summedDelVel + _ekf->dVelIMU;\n+\t\t\t\tdt += _ekf->dtIMU;\n \n \t\t\t\t// perform a covariance prediction if the total delta angle has exceeded the limit\n \t\t\t\t// or the time limit will be exceeded at the next IMU update\n-\t\t\t\tif ((dt >= (covTimeStepMax - dtIMU)) || (summedDelAng.length() > covDelAngMax)) {\n-\t\t\t\t\tCovariancePrediction(dt);\n-\t\t\t\t\tsummedDelAng = summedDelAng.zero();\n-\t\t\t\t\tsummedDelVel = summedDelVel.zero();\n+\t\t\t\tif ((dt >= (covTimeStepMax - _ekf->dtIMU)) || (_ekf->summedDelAng.length() > covDelAngMax)) {\n+\t\t\t\t\t_ekf->CovariancePrediction(dt);\n+\t\t\t\t\t_ekf->summedDelAng = _ekf->summedDelAng.zero();\n+\t\t\t\t\t_ekf->summedDelVel = _ekf->summedDelVel.zero();\n \t\t\t\t\tdt = 0.0f;\n \t\t\t\t}\n \n@@ -865,79 +881,79 @@ FixedwingEstimator::task_main()\n \t\t\t// Fuse GPS Measurements\n \t\t\tif (newDataGps && _gps_initialized) {\n \t\t\t\t// Convert GPS measurements to Pos NE, hgt and Vel NED\n-\t\t\t\tvelNED[0] = _gps.vel_n_m_s;\n-\t\t\t\tvelNED[1] = _gps.vel_e_m_s;\n-\t\t\t\tvelNED[2] = _gps.vel_d_m_s;\n-\t\t\t\tcalcposNED(posNED, gpsLat, gpsLon, gpsHgt, latRef, lonRef, hgtRef);\n+\t\t\t\t_ekf->velNED[0] = _gps.vel_n_m_s;\n+\t\t\t\t_ekf->velNED[1] = _gps.vel_e_m_s;\n+\t\t\t\t_ekf->velNED[2] = _gps.vel_d_m_s;\n+\t\t\t\t_ekf->calcposNED(_ekf->posNED, _ekf->gpsLat, _ekf->gpsLon, _ekf->gpsHgt, _ekf->latRef, _ekf->lonRef, _ekf->hgtRef);\n \n-\t\t\t\tposNE[0] = posNED[0];\n-\t\t\t\tposNE[1] = posNED[1];\n+\t\t\t\t_ekf->posNE[0] = _ekf->posNED[0];\n+\t\t\t\t_ekf->posNE[1] = _ekf->posNED[1];\n \t\t\t\t// set fusion flags\n-\t\t\t\tfuseVelData = true;\n-\t\t\t\tfusePosData = true;\n+\t\t\t\t_ekf->fuseVelData = true;\n+\t\t\t\t_ekf->fusePosData = true;\n \t\t\t\t// recall states stored at time of measurement after adjusting for delays\n-\t\t\t\tRecallStates(statesAtVelTime, (IMUmsec - _parameters.vel_delay_ms));\n-\t\t\t\tRecallStates(statesAtPosTime, (IMUmsec - _parameters.pos_delay_ms));\n+\t\t\t\t_ekf->RecallStates(_ekf->statesAtVelTime, (IMUmsec - _parameters.vel_delay_ms));\n+\t\t\t\t_ekf->RecallStates(_ekf->statesAtPosTime, (IMUmsec - _parameters.pos_delay_ms));\n \t\t\t\t// run the fusion step\n-\t\t\t\tFuseVelposNED();\n+\t\t\t\t_ekf->FuseVelposNED();\n \n-\t\t\t} else if (statesInitialised) {\n+\t\t\t} else if (_ekf->statesInitialised) {\n \t\t\t\t// Convert GPS measurements to Pos NE, hgt and Vel NED\n-\t\t\t\tvelNED[0] = 0.0f;\n-\t\t\t\tvelNED[1] = 0.0f;\n-\t\t\t\tvelNED[2] = 0.0f;\n-\t\t\t\tposNED[0] = 0.0f;\n-\t\t\t\tposNED[1] = 0.0f;\n-\t\t\t\tposNED[2] = 0.0f;\n-\n-\t\t\t\tposNE[0] = posNED[0];\n-\t\t\t\tposNE[1] = posNED[1];\n+\t\t\t\t_ekf->velNED[0] = 0.0f;\n+\t\t\t\t_ekf->velNED[1] = 0.0f;\n+\t\t\t\t_ekf->velNED[2] = 0.0f;\n+\t\t\t\t_ekf->posNED[0] = 0.0f;\n+\t\t\t\t_ekf->posNED[1] = 0.0f;\n+\t\t\t\t_ekf->posNED[2] = 0.0f;\n+\n+\t\t\t\t_ekf->posNE[0] = _ekf->posNED[0];\n+\t\t\t\t_ekf->posNE[1] = _ekf->posNED[1];\n \t\t\t\t// set fusion flags\n-\t\t\t\tfuseVelData = true;\n-\t\t\t\tfusePosData = true;\n+\t\t\t\t_ekf->fuseVelData = true;\n+\t\t\t\t_ekf->fusePosData = true;\n \t\t\t\t// recall states stored at time of measurement after adjusting for delays\n-\t\t\t\tRecallStates(statesAtVelTime, (IMUmsec - _parameters.vel_delay_ms));\n-\t\t\t\tRecallStates(statesAtPosTime, (IMUmsec - _parameters.pos_delay_ms));\n+\t\t\t\t_ekf->RecallStates(_ekf->statesAtVelTime, (IMUmsec - _parameters.vel_delay_ms));\n+\t\t\t\t_ekf->RecallStates(_ekf->statesAtPosTime, (IMUmsec - _parameters.pos_delay_ms));\n \t\t\t\t// run the fusion step\n-\t\t\t\tFuseVelposNED();\n+\t\t\t\t_ekf->FuseVelposNED();\n \n \t\t\t} else {\n-\t\t\t\tfuseVelData = false;\n-\t\t\t\tfusePosData = false;\n+\t\t\t\t_ekf->fuseVelData = false;\n+\t\t\t\t_ekf->fusePosData = false;\n \t\t\t}\n \n-\t\t\tif (newAdsData && statesInitialised) {\n+\t\t\tif (newAdsData && _ekf->statesInitialised) {\n \t\t\t\t// Could use a blend of GPS and baro alt data if desired\n-\t\t\t\thgtMea = 1.0f * baroHgt + 0.0f * gpsHgt;\n-\t\t\t\tfuseHgtData = true;\n+\t\t\t\t_ekf->hgtMea = 1.0f * _ekf->baroHgt + 0.0f * _ekf->gpsHgt;\n+\t\t\t\t_ekf->fuseHgtData = true;\n \t\t\t\t// recall states stored at time of measurement after adjusting for delays\n-\t\t\t\tRecallStates(statesAtHgtTime, (IMUmsec - _parameters.height_delay_ms));\n+\t\t\t\t_ekf->RecallStates(_ekf->statesAtHgtTime, (IMUmsec - _parameters.height_delay_ms));\n \t\t\t\t// run the fusion step\n-\t\t\t\tFuseVelposNED();\n+\t\t\t\t_ekf->FuseVelposNED();\n \n \t\t\t} else {\n-\t\t\t\tfuseHgtData = false;\n+\t\t\t\t_ekf->fuseHgtData = false;\n \t\t\t}\n \n \t\t\t// Fuse Magnetometer Measurements\n-\t\t\tif (newDataMag && statesInitialised) {\n-\t\t\t\tfuseMagData = true;\n-\t\t\t\tRecallStates(statesAtMagMeasTime, (IMUmsec - _parameters.mag_delay_ms)); // Assume 50 msec avg delay for magnetometer data\n+\t\t\tif (newDataMag && _ekf->statesInitialised) {\n+\t\t\t\t_ekf->fuseMagData = true;\n+\t\t\t\t_ekf->RecallStates(_ekf->statesAtMagMeasTime, (IMUmsec - _parameters.mag_delay_ms)); // Assume 50 msec avg delay for magnetometer data\n \n \t\t\t} else {\n-\t\t\t\tfuseMagData = false;\n+\t\t\t\t_ekf->fuseMagData = false;\n \t\t\t}\n \n-\t\t\tif (statesInitialised) FuseMagnetometer();\n+\t\t\tif (_ekf->statesInitialised) _ekf->FuseMagnetometer();\n \n \t\t\t// Fuse Airspeed Measurements\n-\t\t\tif (newAdsData && statesInitialised && VtasMeas > 8.0f) {\n-\t\t\t\tfuseVtasData = true;\n-\t\t\t\tRecallStates(statesAtVtasMeasTime, (IMUmsec - _parameters.tas_delay_ms)); // assume 100 msec avg delay for airspeed data\n-\t\t\t\tFuseAirspeed();\n+\t\t\tif (newAdsData && _ekf->statesInitialised && _ekf->VtasMeas > 8.0f) {\n+\t\t\t\t_ekf->fuseVtasData = true;\n+\t\t\t\t_ekf->RecallStates(_ekf->statesAtVtasMeasTime, (IMUmsec - _parameters.tas_delay_ms)); // assume 100 msec avg delay for airspeed data\n+\t\t\t\t_ekf->FuseAirspeed();\n \n \t\t\t} else {\n-\t\t\t\tfuseVtasData = false;\n+\t\t\t\t_ekf->fuseVtasData = false;\n \t\t\t}\n \n \t\t\t// Publish results\n@@ -954,18 +970,18 @@ FixedwingEstimator::task_main()\n \t\t\t\t// 15-17: Earth Magnetic Field Vector - milligauss (North, East, Down)\n \t\t\t\t// 18-20: Body Magnetic Field Vector - milligauss (X,Y,Z)\n \n-\t\t\t\tmath::Quaternion q(states[0], states[1], states[2], states[3]);\n+\t\t\t\tmath::Quaternion q(_ekf->states[0], _ekf->states[1], _ekf->states[2], _ekf->states[3]);\n \t\t\t\tmath::Matrix<3, 3> R = q.to_dcm();\n \t\t\t\tmath::Vector<3> euler = R.to_euler();\n \n \t\t\t\tfor (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++)\n \t\t\t\t\t\t_att.R[i][j] = R(i, j);\n \n \t\t\t\t_att.timestamp = last_sensor_timestamp;\n-\t\t\t\t_att.q[0] = states[0];\n-\t\t\t\t_att.q[1] = states[1];\n-\t\t\t\t_att.q[2] = states[2];\n-\t\t\t\t_att.q[3] = states[3];\n+\t\t\t\t_att.q[0] = _ekf->states[0];\n+\t\t\t\t_att.q[1] = _ekf->states[1];\n+\t\t\t\t_att.q[2] = _ekf->states[2];\n+\t\t\t\t_att.q[3] = _ekf->states[3];\n \t\t\t\t_att.q_valid = true;\n \t\t\t\t_att.R_valid = true;\n \n@@ -974,13 +990,13 @@ FixedwingEstimator::task_main()\n \t\t\t\t_att.pitch = euler(1);\n \t\t\t\t_att.yaw = euler(2);\n \n-\t\t\t\t_att.rollspeed = angRate.x - states[10];\n-\t\t\t\t_att.pitchspeed = angRate.y - states[11];\n-\t\t\t\t_att.yawspeed = angRate.z - states[12];\n+\t\t\t\t_att.rollspeed = _ekf->angRate.x - _ekf->states[10];\n+\t\t\t\t_att.pitchspeed = _ekf->angRate.y - _ekf->states[11];\n+\t\t\t\t_att.yawspeed = _ekf->angRate.z - _ekf->states[12];\n \t\t\t\t// gyro offsets\n-\t\t\t\t_att.rate_offsets[0] = states[10];\n-\t\t\t\t_att.rate_offsets[1] = states[11];\n-\t\t\t\t_att.rate_offsets[2] = states[12];\n+\t\t\t\t_att.rate_offsets[0] = _ekf->states[10];\n+\t\t\t\t_att.rate_offsets[1] = _ekf->states[11];\n+\t\t\t\t_att.rate_offsets[2] = _ekf->states[12];\n \n \t\t\t\t/* lazily publish the attitude only once available */\n \t\t\t\tif (_att_pub > 0) {\n@@ -993,20 +1009,15 @@ FixedwingEstimator::task_main()\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tif (!isfinite(states[0])) {\n-\t\t\t\tprint_status();\n-\t\t\t\t_exit(0);\n-\t\t\t}\n-\n \t\t\tif (_gps_initialized) {\n \t\t\t\t_local_pos.timestamp = last_sensor_timestamp;\n-\t\t\t\t_local_pos.x = states[7];\n-\t\t\t\t_local_pos.y = states[8];\n-\t\t\t\t_local_pos.z = states[9];\n+\t\t\t\t_local_pos.x = _ekf->states[7];\n+\t\t\t\t_local_pos.y = _ekf->states[8];\n+\t\t\t\t_local_pos.z = _ekf->states[9];\n \n-\t\t\t\t_local_pos.vx = states[4];\n-\t\t\t\t_local_pos.vy = states[5];\n-\t\t\t\t_local_pos.vz = states[6];\n+\t\t\t\t_local_pos.vx = _ekf->states[4];\n+\t\t\t\t_local_pos.vy = _ekf->states[5];\n+\t\t\t\t_local_pos.vz = _ekf->states[6];\n \n \t\t\t\t_local_pos.xy_valid = _gps_initialized;\n \t\t\t\t_local_pos.z_valid = true;\n@@ -1107,9 +1118,10 @@ FixedwingEstimator::start()\n \treturn OK;\n }\n \n-void print_status()\n+void\n+FixedwingEstimator::print_status()\n {\n-\tmath::Quaternion q(states[0], states[1], states[2], states[3]);\n+\tmath::Quaternion q(_ekf->states[0], _ekf->states[1], _ekf->states[2], _ekf->states[3]);\n \tmath::Matrix<3, 3> R = q.to_dcm();\n \tmath::Vector<3> euler = R.to_euler();\n \n@@ -1125,30 +1137,30 @@ void print_status()\n \t// 15-17: Earth Magnetic Field Vector - gauss (North, East, Down)\n \t// 18-20: Body Magnetic Field Vector - gauss (X,Y,Z)\n \n-\tprintf(\"dtIMU: %8.6f dt: %8.6f IMUmsec: %d\\n\", dtIMU, dt, (int)IMUmsec);\n-\tprintf(\"dvel: %8.6f %8.6f %8.6f accel: %8.6f %8.6f %8.6f\\n\", (double)dVelIMU.x, (double)dVelIMU.y, (double)dVelIMU.z, (double)accel.x, (double)accel.y, (double)accel.z);\n-\tprintf(\"dang: %8.4f %8.4f %8.4f dang corr: %8.4f %8.4f %8.4f\\n\" , (double)dAngIMU.x, (double)dAngIMU.y, (double)dAngIMU.z, (double)correctedDelAng.x, (double)correctedDelAng.y, (double)correctedDelAng.z);\n-\tprintf(\"states (quat)        [1-4]: %8.4f, %8.4f, %8.4f, %8.4f\\n\", (double)states[0], (double)states[1], (double)states[2], (double)states[3]);\n-\tprintf(\"states (vel m/s)     [5-7]: %8.4f, %8.4f, %8.4f\\n\", (double)states[4], (double)states[5], (double)states[6]);\n-\tprintf(\"states (pos m)      [8-10]: %8.4f, %8.4f, %8.4f\\n\", (double)states[7], (double)states[8], (double)states[9]);\n-\tprintf(\"states (delta ang) [11-13]: %8.4f, %8.4f, %8.4f\\n\", (double)states[10], (double)states[11], (double)states[12]);\n-\tprintf(\"states (wind)      [14-15]: %8.4f, %8.4f\\n\", (double)states[13], (double)states[14]);\n-\tprintf(\"states (earth mag) [16-18]: %8.4f, %8.4f, %8.4f\\n\", (double)states[15], (double)states[16], (double)states[17]);\n-\tprintf(\"states (body mag)  [19-21]: %8.4f, %8.4f, %8.4f\\n\", (double)states[18], (double)states[19], (double)states[20]);\n+\tprintf(\"dtIMU: %8.6f dt: %8.6f IMUmsec: %d\\n\", _ekf->dtIMU, dt, (int)IMUmsec);\n+\tprintf(\"dvel: %8.6f %8.6f %8.6f accel: %8.6f %8.6f %8.6f\\n\", (double)_ekf->dVelIMU.x, (double)_ekf->dVelIMU.y, (double)_ekf->dVelIMU.z, (double)_ekf->accel.x, (double)_ekf->accel.y, (double)_ekf->accel.z);\n+\tprintf(\"dang: %8.4f %8.4f %8.4f dang corr: %8.4f %8.4f %8.4f\\n\" , (double)_ekf->dAngIMU.x, (double)_ekf->dAngIMU.y, (double)_ekf->dAngIMU.z, (double)_ekf->correctedDelAng.x, (double)_ekf->correctedDelAng.y, (double)_ekf->correctedDelAng.z);\n+\tprintf(\"states (quat)        [1-4]: %8.4f, %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[0], (double)_ekf->states[1], (double)_ekf->states[2], (double)_ekf->states[3]);\n+\tprintf(\"states (vel m/s)     [5-7]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[4], (double)_ekf->states[5], (double)_ekf->states[6]);\n+\tprintf(\"states (pos m)      [8-10]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[7], (double)_ekf->states[8], (double)_ekf->states[9]);\n+\tprintf(\"states (delta ang) [11-13]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[10], (double)_ekf->states[11], (double)_ekf->states[12]);\n+\tprintf(\"states (wind)      [14-15]: %8.4f, %8.4f\\n\", (double)_ekf->states[13], (double)_ekf->states[14]);\n+\tprintf(\"states (earth mag) [16-18]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[15], (double)_ekf->states[16], (double)_ekf->states[17]);\n+\tprintf(\"states (body mag)  [19-21]: %8.4f, %8.4f, %8.4f\\n\", (double)_ekf->states[18], (double)_ekf->states[19], (double)_ekf->states[20]);\n \tprintf(\"states: %s %s %s %s %s %s %s %s %s %s\\n\",\n-\t       (statesInitialised) ? \"INITIALIZED\" : \"NON_INIT\",\n-\t       (onGround) ? \"ON_GROUND\" : \"AIRBORNE\",\n-\t       (fuseVelData) ? \"FUSE_VEL\" : \"INH_VEL\",\n-\t       (fusePosData) ? \"FUSE_POS\" : \"INH_POS\",\n-\t       (fuseHgtData) ? \"FUSE_HGT\" : \"INH_HGT\",\n-\t       (fuseMagData) ? \"FUSE_MAG\" : \"INH_MAG\",\n-\t       (fuseVtasData) ? \"FUSE_VTAS\" : \"INH_VTAS\",\n-\t       (useAirspeed) ? \"USE_AIRSPD\" : \"IGN_AIRSPD\",\n-\t       (useCompass) ? \"USE_COMPASS\" : \"IGN_COMPASS\",\n-\t       (staticMode) ? \"STATIC_MODE\" : \"DYNAMIC_MODE\");\n+\t       (_ekf->statesInitialised) ? \"INITIALIZED\" : \"NON_INIT\",\n+\t       (_ekf->onGround) ? \"ON_GROUND\" : \"AIRBORNE\",\n+\t       (_ekf->fuseVelData) ? \"FUSE_VEL\" : \"INH_VEL\",\n+\t       (_ekf->fusePosData) ? \"FUSE_POS\" : \"INH_POS\",\n+\t       (_ekf->fuseHgtData) ? \"FUSE_HGT\" : \"INH_HGT\",\n+\t       (_ekf->fuseMagData) ? \"FUSE_MAG\" : \"INH_MAG\",\n+\t       (_ekf->fuseVtasData) ? \"FUSE_VTAS\" : \"INH_VTAS\",\n+\t       (_ekf->useAirspeed) ? \"USE_AIRSPD\" : \"IGN_AIRSPD\",\n+\t       (_ekf->useCompass) ? \"USE_COMPASS\" : \"IGN_COMPASS\",\n+\t       (_ekf->staticMode) ? \"STATIC_MODE\" : \"DYNAMIC_MODE\");\n }\n \n-int trip_nan() {\n+int FixedwingEstimator::trip_nan() {\n \n \tint ret = 0;\n \n@@ -1166,7 +1178,7 @@ int trip_nan() {\n \t\tfloat nan_val = 0.0f / 0.0f;\n \n \t\twarnx(\"system not armed, tripping state vector with NaN values\");\n-\t\tstates[5] = nan_val;\n+\t\t_ekf->states[5] = nan_val;\n \t\tusleep(100000);\n \n \t\t// warnx(\"tripping covariance #1 with NaN values\");\n@@ -1178,15 +1190,15 @@ int trip_nan() {\n \t\t// usleep(100000);\n \n \t\twarnx(\"tripping covariance #3 with NaN values\");\n-\t\tP[3][3] = nan_val; // covariance matrix\n+\t\t_ekf->P[3][3] = nan_val; // covariance matrix\n \t\tusleep(100000);\n \n \t\twarnx(\"tripping Kalman gains with NaN values\");\n-\t\tKfusion[0] = nan_val; // Kalman gains\n+\t\t_ekf->Kfusion[0] = nan_val; // Kalman gains\n \t\tusleep(100000);\n \n \t\twarnx(\"tripping stored states[0] with NaN values\");\n-\t\tstoredStates[0][0] = nan_val;\n+\t\t_ekf->storedStates[0][0] = nan_val;\n \t\tusleep(100000);\n \n \t\twarnx(\"\\nDONE - FILTER STATE:\");\n@@ -1234,7 +1246,7 @@ int fw_att_pos_estimator_main(int argc, char *argv[])\n \t\tif (estimator::g_estimator) {\n \t\t\twarnx(\"running\");\n \n-\t\t\tprint_status();\n+\t\t\testimator::g_estimator->print_status();\n \n \t\t\texit(0);\n \n@@ -1245,7 +1257,7 @@ int fw_att_pos_estimator_main(int argc, char *argv[])\n \n \tif (!strcmp(argv[1], \"trip\")) {\n \t\tif (estimator::g_estimator) {\n-\t\t\tint ret = trip_nan();\n+\t\t\tint ret = estimator::g_estimator->trip_nan();\n \n \t\t\texit(ret);\n "}]}