{"sha":"0e3afd21b0f44f81c4f2befca6da6d2914f06e80","node_id":"MDY6Q29tbWl0NTI5ODc5MDowZTNhZmQyMWIwZjQ0ZjgxYzRmMmJlZmNhNmRhNmQyOTE0ZjA2ZTgw","commit":{"author":{"name":"patacongo","email":"patacongo@7fd9a85b-ad96-42d3-883c-3090e2eb8679","date":"2012-06-27T15:35:35Z"},"committer":{"name":"patacongo","email":"patacongo@7fd9a85b-ad96-42d3-883c-3090e2eb8679","date":"2012-06-27T15:35:35Z"},"message":"The SST25 driver now works with SST25 (at least using the slow write mode)\n\ngit-svn-id: https://nuttx.svn.sourceforge.net/svnroot/nuttx/trunk@4875 7fd9a85b-ad96-42d3-883c-3090e2eb8679","tree":{"sha":"87622b31e3c2d7e8d0e1821669d99779745631c5","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/87622b31e3c2d7e8d0e1821669d99779745631c5"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/0e3afd21b0f44f81c4f2befca6da6d2914f06e80","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/0e3afd21b0f44f81c4f2befca6da6d2914f06e80","html_url":"https://github.com/PX4/PX4-Autopilot/commit/0e3afd21b0f44f81c4f2befca6da6d2914f06e80","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/0e3afd21b0f44f81c4f2befca6da6d2914f06e80/comments","author":null,"committer":null,"parents":[{"sha":"1a1acf6b7c68e44e4ee8d7db50a0e00da5d65c26","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/1a1acf6b7c68e44e4ee8d7db50a0e00da5d65c26","html_url":"https://github.com/PX4/PX4-Autopilot/commit/1a1acf6b7c68e44e4ee8d7db50a0e00da5d65c26"}],"stats":{"total":231,"additions":151,"deletions":80},"files":[{"sha":"7ef2f5b3fba468abf5e603e9a7c5ff5a06952d1a","filename":"nuttx/configs/mirtoo/README.txt","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/0e3afd21b0f44f81c4f2befca6da6d2914f06e80/nuttx%2Fconfigs%2Fmirtoo%2FREADME.txt","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/0e3afd21b0f44f81c4f2befca6da6d2914f06e80/nuttx%2Fconfigs%2Fmirtoo%2FREADME.txt","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/nuttx%2Fconfigs%2Fmirtoo%2FREADME.txt?ref=0e3afd21b0f44f81c4f2befca6da6d2914f06e80","patch":"@@ -872,10 +872,10 @@ Where <subdir> is one of the following:\n \n      NOTES:  (1) It takes many seconds to boot the sytem using the NXFFS\n      file system because the entire FLASH must be verified on power up\n-     (and many *minutes* the first time that NXFFS comes up and has to\n-     format the file system). (2) FAT does not have these delays and this\n-     configuration can be modified to use the (larger) FAT file system as\n-     described below:\n+     (and longer the first time that NXFFS comes up and has to format the\n+     entire FLASH). (2) FAT does not have these delays and this configuration\n+     can be modified to use the (larger) FAT file system as described below.\n+     But you will, or course, lose the wear-leveling feature if FAT is used.\n \n   fat:\n      There is no FAT configuration, but the nxffx configuration can be used"},{"sha":"717a9c898592d57a49096cc5b548d6fae481bf54","filename":"nuttx/drivers/mtd/sst25.c","status":"modified","additions":147,"deletions":76,"changes":223,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/0e3afd21b0f44f81c4f2befca6da6d2914f06e80/nuttx%2Fdrivers%2Fmtd%2Fsst25.c","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/0e3afd21b0f44f81c4f2befca6da6d2914f06e80/nuttx%2Fdrivers%2Fmtd%2Fsst25.c","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/nuttx%2Fdrivers%2Fmtd%2Fsst25.c?ref=0e3afd21b0f44f81c4f2befca6da6d2914f06e80","patch":"@@ -77,6 +77,17 @@\n #  define CONFIG_SST25_SPIFREQUENCY 20000000\n #endif\n \n+/* There is a  bug in the current code when using the higher speed AAI write sequence.\n+ * The nature of the bug is that the WRDI instruction is not working.  At the end\n+ * of the AAI sequence, the status register continues to report that the SST25 is\n+ * write enabled (WEL bit) and in AAI mode (AAI bit).  This *must* be fixed in any\n+ * production code if you want to have proper write performance.\n+ */\n+\n+#warning \"REVISIT\"\n+#undef  CONFIG_SST25_SLOWWRITE\n+#define CONFIG_SST25_SLOWWRITE 1\n+\n /* SST25 Instructions ***************************************************************/\n /*      Command                    Value      Description               Addr   Data */\n /*                                                                         Dummy    */\n@@ -150,7 +161,7 @@\n #  define SST25_SECTOR_SIZE       512         /* Sector size = 512 bytes */\n #endif\n \n-#define SST25_ERASE_STATE         0xff        /* State of FLASH when erased */\n+#define SST25_ERASED_STATE        0xff        /* State of FLASH when erased */\n \n /* Cache flags */\n \n@@ -205,7 +216,7 @@ static inline int sst25_readid(FAR struct sst25_dev_s *priv);\n #ifndef CONFIG_SST25_READONLY\n static void sst25_unprotect(FAR struct spi_dev_s *dev);\n #endif\n-static void sst25_waitwritecomplete(FAR struct sst25_dev_s *priv);\n+static uint8_t sst25_waitwritecomplete(FAR struct sst25_dev_s *priv);\n static inline void sst25_wren(FAR struct sst25_dev_s *priv);\n static inline void sst25_wrdi(FAR struct sst25_dev_s *priv);\n static void sst25_sectorerase(FAR struct sst25_dev_s *priv, off_t offset);\n@@ -214,17 +225,17 @@ static void sst25_byteread(FAR struct sst25_dev_s *priv, FAR uint8_t *buffer,\n                            off_t address, size_t nbytes);\n #ifndef CONFIG_SST25_READONLY\n #ifdef CONFIG_SST25_SLOWWRITE\n-static void sst32_bytewrite(FAR struct sst25_dev_s *priv, FAR const uint8_t *buffer,\n+static void sst25_bytewrite(FAR struct sst25_dev_s *priv, FAR const uint8_t *buffer,\n                             off_t address, size_t nbytes);\n #else\n-static void sst32_wordwrite(FAR struct sst25_dev_s *priv, FAR const uint8_t *buffer,\n+static void sst25_wordwrite(FAR struct sst25_dev_s *priv, FAR const uint8_t *buffer,\n                             off_t address, size_t nbytes);\n #endif\n #ifdef CONFIG_SST25_SECTOR512\n static void sst25_cacheflush(struct sst25_dev_s *priv);\n static FAR uint8_t *sst25_cacheread(struct sst25_dev_s *priv, off_t sector);\n static void sst25_cacheerase(struct sst25_dev_s *priv, off_t sector);\n-static void sst32_cachewrite(FAR struct sst25_dev_s *priv, FAR const uint8_t *buffer,\n+static void sst25_cachewrite(FAR struct sst25_dev_s *priv, FAR const uint8_t *buffer,\n                              off_t sector, size_t nsectors);\n #endif\n #endif\n@@ -373,7 +384,7 @@ static void sst25_unprotect(FAR struct spi_dev_s *dev)\n  * Name: sst25_waitwritecomplete\n  ************************************************************************************/\n \n-static void sst25_waitwritecomplete(struct sst25_dev_s *priv)\n+static uint8_t sst25_waitwritecomplete(struct sst25_dev_s *priv)\n {\n   uint8_t status;\n \n@@ -430,15 +441,19 @@ static void sst25_waitwritecomplete(struct sst25_dev_s *priv)\n        * other peripherals to access the SPI bus.\n        */\n \n+#if 0 /* Makes writes too slow */\n       if ((status & SST25_SR_BUSY) != 0)\n         {\n           sst25_unlock(priv->dev);\n           usleep(1000);\n           sst25_lock(priv->dev);\n         }\n+#endif\n     }\n   while ((status & SST25_SR_BUSY) != 0);\n #endif\n+\n+  return status;\n }\n \n /************************************************************************************\n@@ -477,7 +492,6 @@ static inline void sst25_wrdi(struct sst25_dev_s *priv)\n   /* Deselect the FLASH */\n \n   SPI_SELECT(priv->dev, SPIDEV_FLASH, false);\n-  fvdbg(\"Enabled\\n\");\n }\n \n /************************************************************************************\n@@ -492,7 +506,7 @@ static void sst25_sectorerase(struct sst25_dev_s *priv, off_t sector)\n \n   /* Wait for any preceding write or erase operation to complete. */\n \n-  sst25_waitwritecomplete(priv);\n+  (void)sst25_waitwritecomplete(priv);\n \n   /* Send write enable instruction */\n \n@@ -529,7 +543,7 @@ static inline int sst25_chiperase(struct sst25_dev_s *priv)\n \n   /* Wait for any preceding write or erase operation to complete. */\n \n-  sst25_waitwritecomplete(priv);\n+  (void)sst25_waitwritecomplete(priv);\n \n   /* Send write enable instruction */\n \n@@ -557,11 +571,14 @@ static inline int sst25_chiperase(struct sst25_dev_s *priv)\n static void sst25_byteread(FAR struct sst25_dev_s *priv, FAR uint8_t *buffer,\n                            off_t address, size_t nbytes)\n {\n+  uint8_t status;\n+\n   fvdbg(\"address: %08lx nbytes: %d\\n\", (long)address, (int)nbytes);\n \n   /* Wait for any preceding write or erase operation to complete. */\n \n-  sst25_waitwritecomplete(priv);\n+  status = sst25_waitwritecomplete(priv);\n+  DEBUGASSERT((status & (SST25_SR_WEL|SST25_SR_BP_MASK|SST25_SR_AAI)) == 0);\n \n   /* Select this FLASH part */\n \n@@ -597,130 +614,184 @@ static void sst25_byteread(FAR struct sst25_dev_s *priv, FAR uint8_t *buffer,\n }\n \n /************************************************************************************\n- * Name:  sst32_bytewrite\n+ * Name:  sst25_bytewrite\n  ************************************************************************************/\n \n #if defined(CONFIG_SST25_SLOWWRITE) && !defined(CONFIG_SST25_READONLY)\n-static void sst32_bytewrite(struct sst25_dev_s *priv, FAR const uint8_t *buffer,\n+static void sst25_bytewrite(struct sst25_dev_s *priv, FAR const uint8_t *buffer,\n                             off_t address, size_t nbytes)\n {\n+  uint8_t status;\n+\n   fvdbg(\"address: %08lx nwords: %d\\n\", (long)address, (int)nbytes);\n   DEBUGASSERT(priv && buffer);\n \n   /* Write each byte individually */\n \n   for (; nbytes > 0; nbytes--)\n     {\n-      /* Wait for any preceding write or erase operation to complete. */\n+      /* Skip over bytes that are begin written to the erased state */\n \n-      sst25_waitwritecomplete(priv);\n+      if (*buffer != SST25_ERASED_STATE)\n+        {\n+          /* Wait for any preceding write or erase operation to complete. */\n \n-      /* Enable write access to the FLASH */\n+          status = sst25_waitwritecomplete(priv);\n+          DEBUGASSERT((status & (SST25_SR_WEL|SST25_SR_BP_MASK|SST25_SR_AAI)) == 0);\n \n-      sst25_wren(priv);\n+          /* Enable write access to the FLASH */\n+\n+          sst25_wren(priv);\n   \n-      /* Select this FLASH part */\n+          /* Select this FLASH part */\n \n-      SPI_SELECT(priv->dev, SPIDEV_FLASH, true);\n+          SPI_SELECT(priv->dev, SPIDEV_FLASH, true);\n \n-      /* Send \"Byte Program (BP)\" command */\n+          /* Send \"Byte Program (BP)\" command */\n \n-      (void)SPI_SEND(priv->dev, SST25_BP);\n+          (void)SPI_SEND(priv->dev, SST25_BP);\n \n-      /* Send the byte address high byte first. */\n+          /* Send the byte address high byte first. */\n \n-      (void)SPI_SEND(priv->dev, (address >> 16) & 0xff);\n-      (void)SPI_SEND(priv->dev, (address >> 8) & 0xff);\n-      (void)SPI_SEND(priv->dev, address & 0xff);\n+          (void)SPI_SEND(priv->dev, (address >> 16) & 0xff);\n+          (void)SPI_SEND(priv->dev, (address >> 8) & 0xff);\n+          (void)SPI_SEND(priv->dev, address & 0xff);\n \n-      /* Then write the single byte */\n+          /* Then write the single byte */\n \n-      (void)SPI_SEND(priv->dev, *buffer);\n+          (void)SPI_SEND(priv->dev, *buffer);\n   \n-      /* Deselect the FLASH and setup for the next pass through the loop */\n+          /* Deselect the FLASH and setup for the next pass through the loop */\n+\n+          SPI_SELECT(priv->dev, SPIDEV_FLASH, false);\n+        }\n+\n+      /* Advance to the next byte */\n \n-      SPI_SELECT(priv->dev, SPIDEV_FLASH, false);\n       buffer++;\n       address++;\n     }\n }\n #endif\n \n /************************************************************************************\n- * Name:  sst32_wordwrite\n+ * Name:  sst25_wordwrite\n  ************************************************************************************/\n \n #if !defined(CONFIG_SST25_SLOWWRITE) && !defined(CONFIG_SST25_READONLY)\n-static void sst32_wordwrite(struct sst25_dev_s *priv, FAR const uint8_t *buffer,\n+static void sst25_wordwrite(struct sst25_dev_s *priv, FAR const uint8_t *buffer,\n                             off_t address, size_t nbytes)\n {\n   size_t nwords = (nbytes + 1) >> 1;\n+  uint8_t status;\n \n   fvdbg(\"address: %08lx nwords: %d\\n\", (long)address, (int)nwords);\n   DEBUGASSERT(priv && buffer);\n \n-  /* Wait for any preceding write or erase operation to complete. */\n+  /* Loop until all of the bytes have been written */\n \n-  sst25_waitwritecomplete(priv);\n+  while (nwords > 0)\n+    {\n+      /* Skip over any data that is being written to the erased state */\n \n-  /* Enable write access to the FLASH */\n+      while (nwords > 0 &&\n+             buffer[0] == SST25_ERASED_STATE &&\n+             buffer[1] == SST25_ERASED_STATE)\n+        {\n+          /* Decrement the word count and advance the write position */\n \n-  sst25_wren(priv);\n+          nwords--;\n+          buffer  += 2;\n+          address += 2;\n+        }\n+\n+      /* If there are no further non-erased bytes in the user buffer, then\n+       * we are finished.\n+       */\n+ \n+      if (nwords <= 0)\n+        {\n+          return;\n+        }\n+\n+      /* Wait for any preceding write or erase operation to complete. */\n+\n+      status = sst25_waitwritecomplete(priv);\n+      DEBUGASSERT((status & (SST25_SR_WEL|SST25_SR_BP_MASK|SST25_SR_AAI)) == 0);\n+\n+      /* Enable write access to the FLASH */\n+\n+      sst25_wren(priv);\n   \n-  /* Select this FLASH part */\n+      /* Select this FLASH part */\n \n-  SPI_SELECT(priv->dev, SPIDEV_FLASH, true);\n+      SPI_SELECT(priv->dev, SPIDEV_FLASH, true);\n \n-  /* Send \"Auto Address Increment (AAI)\" command */\n+      /* Send \"Auto Address Increment (AAI)\" command */\n \n-  (void)SPI_SEND(priv->dev, SST25_AAI);\n+      (void)SPI_SEND(priv->dev, SST25_AAI);\n \n-  /* Send the word address high byte first. */\n+      /* Send the word address high byte first. */\n \n-  (void)SPI_SEND(priv->dev, (address >> 16) & 0xff);\n-  (void)SPI_SEND(priv->dev, (address >> 8) & 0xff);\n-  (void)SPI_SEND(priv->dev, address & 0xff);\n+      (void)SPI_SEND(priv->dev, (address >> 16) & 0xff);\n+      (void)SPI_SEND(priv->dev, (address >> 8) & 0xff);\n+      (void)SPI_SEND(priv->dev, address & 0xff);\n \n-  /* Then write one 16-bit word */\n+      /* Then write one 16-bit word */\n \n-  SPI_SNDBLOCK(priv->dev, buffer, 2);\n+      SPI_SNDBLOCK(priv->dev, buffer, 2);\n   \n-  /* Deselect the FLASH: Chip Select high */\n+      /* Deselect the FLASH: Chip Select high */\n \n-  SPI_SELECT(priv->dev, SPIDEV_FLASH, false);\n-  buffer += 2;\n+      SPI_SELECT(priv->dev, SPIDEV_FLASH, false);\n \n-  /* Now loop, writing 16-bits of data on each pass through the loop until all\n-   * of the words have been transferred.\n-   */\n+      /* Decrement the word count and advance the write position */\n \n-  for (nwords--; nwords > 0; nwords--)\n-    {\n-      /* Wait for the preceding write to complete. */\n+      nwords--;\n+      buffer  += 2;\n+      address += 2;\n \n-      sst25_waitwritecomplete(priv);\n+      /* Now loop, writing 16-bits of data on each pass through the loop\n+       * until all of the words have been transferred or until we encounter\n+       * data to be written to the erased state.\n+       */\n \n-      /* Select this FLASH part */\n+      while (nwords > 0 &&\n+             (buffer[0] != SST25_ERASED_STATE ||\n+              buffer[1] != SST25_ERASED_STATE))\n+        {\n+          /* Wait for the preceding write to complete. */\n \n-      SPI_SELECT(priv->dev, SPIDEV_FLASH, true);\n+          status = sst25_waitwritecomplete(priv);\n+          DEBUGASSERT((status & (SST25_SR_WEL|SST25_SR_BP_MASK|SST25_SR_AAI)) == (SST25_SR_WEL|SST25_SR_AAI));\n \n-      /* Send \"Auto Address Increment (AAI)\" command with no address */\n+          /* Select this FLASH part */\n \n-      (void)SPI_SEND(priv->dev, SST25_AAI);\n+          SPI_SELECT(priv->dev, SPIDEV_FLASH, true);\n \n-      /* Then write one 16-bit word */\n+          /* Send \"Auto Address Increment (AAI)\" command with no address */\n \n-      SPI_SNDBLOCK(priv->dev, buffer, 2);\n-      buffer += 2;\n+          (void)SPI_SEND(priv->dev, SST25_AAI);\n \n-      /* Deselect the FLASH: Chip Select high */\n+          /* Then write one 16-bit word */\n \n-      SPI_SELECT(priv->dev, SPIDEV_FLASH, false);\n-    }\n+          SPI_SNDBLOCK(priv->dev, buffer, 2);\n+\n+          /* Deselect the FLASH: Chip Select high */\n+\n+          SPI_SELECT(priv->dev, SPIDEV_FLASH, false);\n \n-  /* Disable writing */\n+          /* Decrement the word count and advance the write position */\n+\n+          nwords--;\n+          buffer  += 2;\n+          address += 2;\n+        }\n \n-  sst25_wrdi(priv);\n+      /* Disable writing */\n+\n+      sst25_wrdi(priv);\n+    }\n }\n #endif\n \n@@ -741,10 +812,10 @@ static void sst25_cacheflush(struct sst25_dev_s *priv)\n       /* Write entire erase block to FLASH */\n \n #ifdef CONFIG_SST25_SLOWWRITE\n-      sst32_bytewrite(priv, priv->sector, (off_t)priv->esectno << priv->sectorshift,\n+      sst25_bytewrite(priv, priv->sector, (off_t)priv->esectno << priv->sectorshift,\n                       (1 << priv->sectorshift));\n #else\n-      sst32_wordwrite(priv, priv->sector, (off_t)priv->esectno << priv->sectorshift,\n+      sst25_wordwrite(priv, priv->sector, (off_t)priv->esectno << priv->sectorshift,\n                       (1 << priv->sectorshift));\n #endif\n \n@@ -841,7 +912,7 @@ static void sst25_cacheerase(struct sst25_dev_s *priv, off_t sector)\n    * time).\n    */\n \n-  memset(dest, SST25_ERASE_STATE, SST25_SECTOR_SIZE);\n+  memset(dest, SST25_ERASED_STATE, SST25_SECTOR_SIZE);\n   SET_DIRTY(priv);\n }\n #endif\n@@ -851,7 +922,7 @@ static void sst25_cacheerase(struct sst25_dev_s *priv, off_t sector)\n  ************************************************************************************/\n \n #if defined(CONFIG_SST25_SECTOR512) && !defined(CONFIG_SST25_READONLY)\n-static void sst32_cachewrite(FAR struct sst25_dev_s *priv, FAR const uint8_t *buffer,\n+static void sst25_cachewrite(FAR struct sst25_dev_s *priv, FAR const uint8_t *buffer,\n                             off_t sector, size_t nsectors)\n {\n   FAR uint8_t *dest;\n@@ -941,7 +1012,7 @@ static int sst25_erase(FAR struct mtd_dev_s *dev, off_t startblock, size_t nbloc\n  ************************************************************************************/\n \n static ssize_t sst25_bread(FAR struct mtd_dev_s *dev, off_t startblock, size_t nblocks,\n-                          FAR uint8_t *buffer)\n+                           FAR uint8_t *buffer)\n {\n #ifdef CONFIG_SST25_SECTOR512\n   ssize_t nbytes;\n@@ -980,7 +1051,7 @@ static ssize_t sst25_bread(FAR struct mtd_dev_s *dev, off_t startblock, size_t n\n  ************************************************************************************/\n \n static ssize_t sst25_bwrite(FAR struct mtd_dev_s *dev, off_t startblock, size_t nblocks,\n-                           FAR const uint8_t *buffer)\n+                            FAR const uint8_t *buffer)\n {\n #ifdef CONFIG_SST25_READONLY\n   return -EACCESS;\n@@ -994,12 +1065,12 @@ static ssize_t sst25_bwrite(FAR struct mtd_dev_s *dev, off_t startblock, size_t\n   sst25_lock(priv->dev);\n \n #if defined(CONFIG_SST25_SECTOR512)\n-  sst32_cachewrite(priv, buffer, startblock, nblocks);\n+  sst25_cachewrite(priv, buffer, startblock, nblocks);\n #elif defined(CONFIG_SST25_SLOWWRITE)\n-  sst32_bytewrite(priv, buffer, startblock << priv->sectorshift,\n+  sst25_bytewrite(priv, buffer, startblock << priv->sectorshift,\n                   nblocks << priv->sectorshift);\n #else\n-  sst32_wordwrite(priv, buffer, startblock << priv->sectorshift,\n+  sst25_wordwrite(priv, buffer, startblock << priv->sectorshift,\n                   nblocks << priv->sectorshift);\n #endif\n   sst25_unlock(priv->dev);\n@@ -1013,7 +1084,7 @@ static ssize_t sst25_bwrite(FAR struct mtd_dev_s *dev, off_t startblock, size_t\n  ************************************************************************************/\n \n static ssize_t sst25_read(FAR struct mtd_dev_s *dev, off_t offset, size_t nbytes,\n-                         FAR uint8_t *buffer)\n+                          FAR uint8_t *buffer)\n {\n   FAR struct sst25_dev_s *priv = (FAR struct sst25_dev_s *)dev;\n "}]}