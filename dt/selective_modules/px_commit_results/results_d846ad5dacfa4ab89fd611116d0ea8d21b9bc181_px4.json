{"sha":"d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","node_id":"MDY6Q29tbWl0NTI5ODc5MDpkODQ2YWQ1ZGFjZmE0YWI4OWZkNjExMTE2ZDBlYThkMjFiOWJjMTgx","commit":{"author":{"name":"Beat KÃ¼ng","email":"beat-kueng@gmx.net","date":"2016-06-25T10:28:02Z"},"committer":{"name":"Lorenz Meier","email":"lm@inf.ethz.ch","date":"2016-07-07T09:35:50Z"},"message":"sensors: move voting into sensors module\n\n- voting is now at a central place instead of duplicated within the\n  estimators\n  -> this also means that estimators that did not do voting so far,\n     now have voting, like ekf2\n- estimators requiring more than that can still subscribe to the raw\n  sensors\n- allows sensors_combined to be 3 times smaller\n  - reduces logger, memcpy (cache) & RAM overhead\n- all modules requiring only 1 or 2 sensor values now automatically get\n  the voted result\n- this also adds voting to baro","tree":{"sha":"f54acde746fddad7c8f4a88f7bf2574573b74b83","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/f54acde746fddad7c8f4a88f7bf2574573b74b83"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","html_url":"https://github.com/PX4/PX4-Autopilot/commit/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/comments","author":{"login":"bkueng","id":281593,"node_id":"MDQ6VXNlcjI4MTU5Mw==","avatar_url":"https://avatars.githubusercontent.com/u/281593?v=4","gravatar_id":"","url":"https://api.github.com/users/bkueng","html_url":"https://github.com/bkueng","followers_url":"https://api.github.com/users/bkueng/followers","following_url":"https://api.github.com/users/bkueng/following{/other_user}","gists_url":"https://api.github.com/users/bkueng/gists{/gist_id}","starred_url":"https://api.github.com/users/bkueng/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bkueng/subscriptions","organizations_url":"https://api.github.com/users/bkueng/orgs","repos_url":"https://api.github.com/users/bkueng/repos","events_url":"https://api.github.com/users/bkueng/events{/privacy}","received_events_url":"https://api.github.com/users/bkueng/received_events","type":"User","site_admin":false},"committer":{"login":"LorenzMeier","id":1208119,"node_id":"MDQ6VXNlcjEyMDgxMTk=","avatar_url":"https://avatars.githubusercontent.com/u/1208119?v=4","gravatar_id":"","url":"https://api.github.com/users/LorenzMeier","html_url":"https://github.com/LorenzMeier","followers_url":"https://api.github.com/users/LorenzMeier/followers","following_url":"https://api.github.com/users/LorenzMeier/following{/other_user}","gists_url":"https://api.github.com/users/LorenzMeier/gists{/gist_id}","starred_url":"https://api.github.com/users/LorenzMeier/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/LorenzMeier/subscriptions","organizations_url":"https://api.github.com/users/LorenzMeier/orgs","repos_url":"https://api.github.com/users/LorenzMeier/repos","events_url":"https://api.github.com/users/LorenzMeier/events{/privacy}","received_events_url":"https://api.github.com/users/LorenzMeier/received_events","type":"User","site_admin":false},"parents":[{"sha":"c50d267bfb9248fe2178fabe78deff78abe04048","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/c50d267bfb9248fe2178fabe78deff78abe04048","html_url":"https://github.com/PX4/PX4-Autopilot/commit/c50d267bfb9248fe2178fabe78deff78abe04048"}],"stats":{"total":1194,"additions":561,"deletions":633},"files":[{"sha":"8a7045f9d79753ce6005eba03b5f3e4a2483c053","filename":"msg/sensor_combined.msg","status":"modified","additions":11,"deletions":11,"changes":22,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/msg%2Fsensor_combined.msg","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/msg%2Fsensor_combined.msg","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/msg%2Fsensor_combined.msg?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -5,18 +5,18 @@\n # change with board revisions and sensor updates.\n #\n \n-uint64[3] gyro_timestamp\t\t\t# Gyro timestamps\n-float32[9] gyro_integral_rad\t\t# delta angle in the NED body frame in rad in the integration time frame\n-uint64[3] gyro_integral_dt\t\t\t# delta time for gyro integral in us\n+# gyro timstamp is equal to the timestamp of the message\n+float32[3] gyro_integral_rad\t\t# delta angle in the NED body frame in rad in the integration time frame\n+uint64 gyro_integral_dt\t\t\t# delta time for gyro integral in us\n \n-float32[9] accelerometer_integral_m_s\t\t# velocity in NED body frame, in m/s^2\n-uint64[3] accelerometer_integral_dt\t\t# delta time for accel integral in us\n-uint64[3] accelerometer_timestamp\t# Accelerometer timestamp\n+uint64 accelerometer_timestamp\t# Accelerometer timestamp\n+float32[3] accelerometer_integral_m_s\t\t# velocity in NED body frame, in m/s^2\n+uint64 accelerometer_integral_dt\t\t# delta time for accel integral in us\n \n-float32[9] magnetometer_ga\t\t# Magnetic field in NED body frame, in Gauss\n-uint64[3] magnetometer_timestamp\t# Magnetometer timestamp\n+uint64 magnetometer_timestamp\t# Magnetometer timestamp\n+float32[3] magnetometer_ga\t\t# Magnetic field in NED body frame, in Gauss\n \n-float32[3] baro_alt_meter\t\t\t# Altitude, already temp. comp.\n-float32[3] baro_temp_celcius\t\t# Temperature in degrees celsius\n-uint64[3] baro_timestamp\t\t# Barometer timestamp\n+uint64 baro_timestamp\t\t# Barometer timestamp\n+float32 baro_alt_meter\t\t\t# Altitude, already temp. comp.\n+float32 baro_temp_celcius\t\t# Temperature in degrees celsius\n "},{"sha":"47330774a3187ed99767df20bc18ce658e04f228","filename":"src/drivers/frsky_telemetry/frsky_data.c","status":"modified","additions":4,"deletions":4,"changes":8,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fdrivers%2Ffrsky_telemetry%2Ffrsky_data.c","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fdrivers%2Ffrsky_telemetry%2Ffrsky_data.c","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Ffrsky_telemetry%2Ffrsky_data.c?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -205,7 +205,7 @@ void frsky_send_frame1(int uart)\n {\n \t/* send formatted frame */\n \tfloat acceleration[3];\n-\tfloat accel_dt = sensor_combined->accelerometer_integral_dt[0] / 1.e6f;\n+\tfloat accel_dt = sensor_combined->accelerometer_integral_dt / 1.e6f;\n \tacceleration[0] = sensor_combined->accelerometer_integral_m_s[0] / accel_dt;\n \tacceleration[1] = sensor_combined->accelerometer_integral_m_s[1] / accel_dt;\n \tacceleration[2] = sensor_combined->accelerometer_integral_m_s[2] / accel_dt;\n@@ -214,12 +214,12 @@ void frsky_send_frame1(int uart)\n \tfrsky_send_data(uart, FRSKY_ID_ACCEL_Z, roundf(acceleration[2] * 1000.0f));\n \n \tfrsky_send_data(uart, FRSKY_ID_BARO_ALT_BP,\n-\t\t\tsensor_combined->baro_alt_meter[0]);\n+\t\t\tsensor_combined->baro_alt_meter);\n \tfrsky_send_data(uart, FRSKY_ID_BARO_ALT_AP,\n-\t\t\troundf(frac(sensor_combined->baro_alt_meter[0]) * 100.0f));\n+\t\t\troundf(frac(sensor_combined->baro_alt_meter) * 100.0f));\n \n \tfrsky_send_data(uart, FRSKY_ID_TEMP1,\n-\t\t\troundf(sensor_combined->baro_temp_celcius[0]));\n+\t\t\troundf(sensor_combined->baro_temp_celcius));\n \n \tfrsky_send_data(uart, FRSKY_ID_VFAS,\n \t\t\troundf(battery_status->voltage_v * 10.0f));"},{"sha":"c728ea6f8a3e1b8b807e1c3c6dc54bad1f935f3a","filename":"src/drivers/frsky_telemetry/sPort_data.c","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fdrivers%2Ffrsky_telemetry%2FsPort_data.c","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fdrivers%2Ffrsky_telemetry%2FsPort_data.c","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Ffrsky_telemetry%2FsPort_data.c?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -236,7 +236,7 @@ void sPort_send_CUR(int uart)\n void sPort_send_ALT(int uart)\n {\n \t/* send data */\n-\tuint32_t alt = (int)(100 * sensor_combined->baro_alt_meter[0]);\n+\tuint32_t alt = (int)(100 * sensor_combined->baro_alt_meter);\n \tsPort_send_data(uart, SMARTPORT_ID_ALT, alt);\n }\n "},{"sha":"92b1664ccf6e8b4b9f2c56f05e9bc3bfebd68c49","filename":"src/drivers/hott/messages.cpp","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fdrivers%2Fhott%2Fmessages.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fdrivers%2Fhott%2Fmessages.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fdrivers%2Fhott%2Fmessages.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -149,12 +149,12 @@ build_eam_response(uint8_t *buffer, size_t *size)\n \tmsg.eam_sensor_id = EAM_SENSOR_ID;\n \tmsg.sensor_text_id = EAM_SENSOR_TEXT_ID;\n \n-\tmsg.temperature1 = (uint8_t)(raw.baro_temp_celcius[0] + 20);\n+\tmsg.temperature1 = (uint8_t)(raw.baro_temp_celcius + 20);\n \tmsg.temperature2 = msg.temperature1 - BOARD_TEMP_OFFSET_DEG;\n \n \tmsg.main_voltage_L = (uint8_t)(battery.voltage_v * 10);\n \n-\tuint16_t alt = (uint16_t)(raw.baro_alt_meter[0] + 500);\n+\tuint16_t alt = (uint16_t)(raw.baro_alt_meter + 500);\n \tmsg.altitude_L = (uint8_t)alt & 0xff;\n \tmsg.altitude_H = (uint8_t)(alt >> 8) & 0xff;\n "},{"sha":"58ec07717032434774daaaf145932013ccd4e5f2","filename":"src/examples/px4_simple_app/px4_simple_app.c","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fexamples%2Fpx4_simple_app%2Fpx4_simple_app.c","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fexamples%2Fpx4_simple_app%2Fpx4_simple_app.c","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fexamples%2Fpx4_simple_app%2Fpx4_simple_app.c?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -102,7 +102,7 @@ int px4_simple_app_main(int argc, char *argv[])\n \t\t\t\t/* copy sensors raw data into local buffer */\n \t\t\t\torb_copy(ORB_ID(sensor_combined), sensor_sub_fd, &raw);\n \t\t\t\tfloat sensor_accel[3];\n-\t\t\t\tfloat accel_dt = raw.accelerometer_integral_dt[0] / 1.e6f;\n+\t\t\t\tfloat accel_dt = raw.accelerometer_integral_dt / 1.e6f;\n \t\t\t\tsensor_accel[0] = raw.accelerometer_integral_m_s[0] / accel_dt;\n \t\t\t\tsensor_accel[1] = raw.accelerometer_integral_m_s[1] / accel_dt;\n \t\t\t\tsensor_accel[2] = raw.accelerometer_integral_m_s[2] / accel_dt;"},{"sha":"d42f57b27e9609e26face0d9f87ac503ac71082d","filename":"src/lib/terrain_estimation/terrain_estimator.cpp","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Flib%2Fterrain_estimation%2Fterrain_estimator.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Flib%2Fterrain_estimation%2Fterrain_estimator.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Flib%2Fterrain_estimation%2Fterrain_estimator.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -68,7 +68,7 @@ void TerrainEstimator::predict(float dt, const struct vehicle_attitude_s *attitu\n \tif (attitude->R_valid) {\n \t\tmatrix::Matrix<float, 3, 3> R_att(attitude->R);\n \t\tmatrix::Vector<float, 3> a;\n-\t\tfloat accel_dt = sensor->accelerometer_integral_dt[0] / 1.e6f;\n+\t\tfloat accel_dt = sensor->accelerometer_integral_dt / 1.e6f;\n \t\ta(0) = sensor->accelerometer_integral_m_s[0] / accel_dt;\n \t\ta(1) = sensor->accelerometer_integral_m_s[1] / accel_dt;\n \t\ta(2) = sensor->accelerometer_integral_m_s[2] / accel_dt;"},{"sha":"1a66b19f9455e7837faa9a09ffeeb077ec5ccb9c","filename":"src/modules/attitude_estimator_ekf/attitude_estimator_ekf_main.cpp","status":"modified","additions":8,"deletions":8,"changes":16,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fattitude_estimator_ekf%2Fattitude_estimator_ekf_main.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fattitude_estimator_ekf%2Fattitude_estimator_ekf_main.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fattitude_estimator_ekf%2Fattitude_estimator_ekf_main.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -396,7 +396,7 @@ int attitude_estimator_ekf_thread_main(int argc, char *argv[])\n \t\t\t\t}\n \n \t\t\t\tfloat gyro_rad_s[3];\n-\t\t\t\tfloat gyro_dt = raw.gyro_integral_dt[0] / 1.e6f;\n+\t\t\t\tfloat gyro_dt = raw.gyro_integral_dt / 1.e6f;\n \t\t\t\tgyro_rad_s[0] = raw.gyro_integral_rad[0] / gyro_dt;\n \t\t\t\tgyro_rad_s[1] = raw.gyro_integral_rad[1] / gyro_dt;\n \t\t\t\tgyro_rad_s[2] = raw.gyro_integral_rad[2] / gyro_dt;\n@@ -427,21 +427,21 @@ int attitude_estimator_ekf_thread_main(int argc, char *argv[])\n \t\t\t\t\tuint8_t update_vect[3] = {0, 0, 0};\n \n \t\t\t\t\t/* Fill in gyro measurements */\n-\t\t\t\t\tif (sensor_last_timestamp[0] != raw.gyro_timestamp[0]) {\n+\t\t\t\t\tif (sensor_last_timestamp[0] != raw.timestamp) {\n \t\t\t\t\t\tupdate_vect[0] = 1;\n \t\t\t\t\t\t// sensor_update_hz[0] = 1e6f / (raw.timestamp - sensor_last_timestamp[0]);\n-\t\t\t\t\t\tsensor_last_timestamp[0] = raw.gyro_timestamp[0];\n+\t\t\t\t\t\tsensor_last_timestamp[0] = raw.timestamp;\n \t\t\t\t\t}\n \n \t\t\t\t\tz_k[0] =  gyro_rad_s[0] - gyro_offsets[0];\n \t\t\t\t\tz_k[1] =  gyro_rad_s[1] - gyro_offsets[1];\n \t\t\t\t\tz_k[2] =  gyro_rad_s[2] - gyro_offsets[2];\n \n \t\t\t\t\t/* update accelerometer measurements */\n-\t\t\t\t\tif (sensor_last_timestamp[1] != raw.accelerometer_timestamp[0]) {\n+\t\t\t\t\tif (sensor_last_timestamp[1] != raw.accelerometer_timestamp) {\n \t\t\t\t\t\tupdate_vect[1] = 1;\n \t\t\t\t\t\t// sensor_update_hz[1] = 1e6f / (raw.timestamp - sensor_last_timestamp[1]);\n-\t\t\t\t\t\tsensor_last_timestamp[1] = raw.accelerometer_timestamp[0];\n+\t\t\t\t\t\tsensor_last_timestamp[1] = raw.accelerometer_timestamp;\n \t\t\t\t\t}\n \n \t\t\t\t\thrt_abstime vel_t = 0;\n@@ -477,7 +477,7 @@ int attitude_estimator_ekf_thread_main(int argc, char *argv[])\n \t\t\t\t\t}\n \n \t\t\t\t\tmatrix::Vector3f raw_accel;\n-\t\t\t\t\tfloat accel_dt = raw.accelerometer_integral_dt[0] / 1.e6f;\n+\t\t\t\t\tfloat accel_dt = raw.accelerometer_integral_dt / 1.e6f;\n \t\t\t\t\traw_accel(0) = raw.accelerometer_integral_m_s[0] / accel_dt;\n \t\t\t\t\traw_accel(1) = raw.accelerometer_integral_m_s[1] / accel_dt;\n \t\t\t\t\traw_accel(2) = raw.accelerometer_integral_m_s[2] / accel_dt;\n@@ -487,14 +487,14 @@ int attitude_estimator_ekf_thread_main(int argc, char *argv[])\n \t\t\t\t\tz_k[5] = raw_accel(2) - acc(2);\n \n \t\t\t\t\t/* update magnetometer measurements */\n-\t\t\t\t\tif (sensor_last_timestamp[2] != raw.magnetometer_timestamp[0] &&\n+\t\t\t\t\tif (sensor_last_timestamp[2] != raw.magnetometer_timestamp &&\n \t\t\t\t\t\t/* check that the mag vector is > 0 */\n \t\t\t\t\t\tfabsf(sqrtf(raw.magnetometer_ga[0] * raw.magnetometer_ga[0] +\n \t\t\t\t\t\t\traw.magnetometer_ga[1] * raw.magnetometer_ga[1] +\n \t\t\t\t\t\t\traw.magnetometer_ga[2] * raw.magnetometer_ga[2])) > 0.1f) {\n \t\t\t\t\t\tupdate_vect[2] = 1;\n \t\t\t\t\t\t// sensor_update_hz[2] = 1e6f / (raw.timestamp - sensor_last_timestamp[2]);\n-\t\t\t\t\t\tsensor_last_timestamp[2] = raw.magnetometer_timestamp[0];\n+\t\t\t\t\t\tsensor_last_timestamp[2] = raw.magnetometer_timestamp;\n \t\t\t\t\t}\n \n \t\t\t\t\tbool vision_updated = false;"},{"sha":"f56a6793aa312ef64674c230b792b4202bec2ddd","filename":"src/modules/attitude_estimator_q/attitude_estimator_q_main.cpp","status":"modified","additions":30,"deletions":143,"changes":173,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fattitude_estimator_q%2Fattitude_estimator_q_main.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fattitude_estimator_q%2Fattitude_estimator_q_main.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fattitude_estimator_q%2Fattitude_estimator_q_main.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -67,7 +67,6 @@\n #include <mathlib/mathlib.h>\n #include <mathlib/math/filter/LowPassFilter2p.hpp>\n #include <lib/geo/geo.h>\n-#include <lib/ecl/validation/data_validator_group.h>\n \n #include <systemlib/systemlib.h>\n #include <systemlib/param/param.h>\n@@ -139,7 +138,6 @@ class AttitudeEstimatorQ\n \t\tparam_t\tmag_decl_auto;\n \t\tparam_t\tacc_comp;\n \t\tparam_t\tbias_max;\n-\t\tparam_t vibe_thresh;\n \t\tparam_t\text_hdg_mode;\n \t\tparam_t airspeed_mode;\n \t}\t\t_params_handles;\t\t/**< handles for interesting parameters */\n@@ -152,8 +150,6 @@ class AttitudeEstimatorQ\n \tbool\t\t_mag_decl_auto = false;\n \tbool\t\t_acc_comp = false;\n \tfloat\t\t_bias_max = 0.0f;\n-\tfloat\t\t_vibration_warning_threshold = 2.0f;\n-\thrt_abstime\t_vibration_warning_timestamp = 0;\n \tint\t\t_ext_hdg_mode = 0;\n \tint \t_airspeed_mode = 0;\n \n@@ -177,10 +173,6 @@ class AttitudeEstimatorQ\n \tVector<3>\t_vel_prev;\n \tVector<3>\t_pos_acc;\n \n-\tDataValidatorGroup _voter_gyro;\n-\tDataValidatorGroup _voter_accel;\n-\tDataValidatorGroup _voter_mag;\n-\n \t/* Low pass filter for attitude rates */\n \tmath::LowPassFilter2p _lp_roll_rate;\n \tmath::LowPassFilter2p _lp_pitch_rate;\n@@ -190,8 +182,6 @@ class AttitudeEstimatorQ\n \n \tbool\t\t_inited = false;\n \tbool\t\t_data_good = false;\n-\tbool\t\t_failsafe = false;\n-\tbool\t\t_vibration_warning = false;\n \tbool\t\t_ext_hdg_good = false;\n \n \torb_advert_t\t_mavlink_log_pub = nullptr;\n@@ -215,15 +205,10 @@ class AttitudeEstimatorQ\n AttitudeEstimatorQ::AttitudeEstimatorQ() :\n \t_vel_prev(0, 0, 0),\n \t_pos_acc(0, 0, 0),\n-\t_voter_gyro(3),\n-\t_voter_accel(3),\n-\t_voter_mag(3),\n \t_lp_roll_rate(250.0f, 30.0f),\n \t_lp_pitch_rate(250.0f, 30.0f),\n \t_lp_yaw_rate(250.0f, 20.0f)\n {\n-\t_voter_mag.set_timeout(200000);\n-\n \t_params_handles.w_acc\t\t= param_find(\"ATT_W_ACC\");\n \t_params_handles.w_mag\t\t= param_find(\"ATT_W_MAG\");\n \t_params_handles.w_ext_hdg\t= param_find(\"ATT_W_EXT_HDG\");\n@@ -232,7 +217,6 @@ AttitudeEstimatorQ::AttitudeEstimatorQ() :\n \t_params_handles.mag_decl_auto\t= param_find(\"ATT_MAG_DECL_A\");\n \t_params_handles.acc_comp\t= param_find(\"ATT_ACC_COMP\");\n \t_params_handles.bias_max\t= param_find(\"ATT_BIAS_MAX\");\n-\t_params_handles.vibe_thresh\t= param_find(\"ATT_VIBE_THRESH\");\n \t_params_handles.ext_hdg_mode\t= param_find(\"ATT_EXT_HDG_M\");\n \t_params_handles.airspeed_mode = param_find(\"FW_ARSP_MODE\");\n }\n@@ -286,12 +270,6 @@ int AttitudeEstimatorQ::start()\n \n void AttitudeEstimatorQ::print()\n {\n-\twarnx(\"gyro status:\");\n-\t_voter_gyro.print();\n-\twarnx(\"accel status:\");\n-\t_voter_accel.print();\n-\twarnx(\"mag status:\");\n-\t_voter_mag.print();\n }\n \n void AttitudeEstimatorQ::task_main_trampoline(int argc, char *argv[])\n@@ -346,129 +324,40 @@ void AttitudeEstimatorQ::task_main()\n \t\t// Update sensors\n \t\tsensor_combined_s sensors;\n \n-\t\tint best_gyro = 0;\n-\t\tint best_accel = 0;\n-\t\tint best_mag = 0;\n-\n \t\tif (!orb_copy(ORB_ID(sensor_combined), _sensors_sub, &sensors)) {\n \t\t\t// Feed validator with recent sensor data\n \n-\t\t\tfor (unsigned i = 0; i < (sizeof(sensors.gyro_timestamp) / sizeof(sensors.gyro_timestamp[0])); i++) {\n-\n-\t\t\t\t/* ignore empty fields */\n-\t\t\t\tif (sensors.gyro_timestamp[i] > 0) {\n-\n-\t\t\t\t\tfloat gyro[3];\n-\t\t\t\t\tfloat gyro_dt = sensors.gyro_integral_dt[i] / 1e6;\n-\t\t\t\t\tgyro[0] = sensors.gyro_integral_rad[i * 3 + 0] / gyro_dt;\n-\t\t\t\t\tgyro[1] = sensors.gyro_integral_rad[i * 3 + 1] / gyro_dt;\n-\t\t\t\t\tgyro[2] = sensors.gyro_integral_rad[i * 3 + 2] / gyro_dt;\n-\n-\t\t\t\t\t//TODO: note: voter will be moved into sensors module\n-\t\t\t\t\t//_voter_gyro.put(i, sensors.gyro_timestamp[i], &gyro[0], sensors.gyro_errcount[i], sensors.gyro_priority[i]);\n-\t\t\t\t\t_voter_gyro.put(i, sensors.gyro_timestamp[i], &gyro[0], 0, 75);\n-\t\t\t\t}\n-\n-\t\t\t\tif (sensors.accelerometer_timestamp[i] > 0) {\n-\t\t\t\t\tfloat acceleration[3];\n-\t\t\t\t\tfloat accel_dt = sensors.accelerometer_integral_dt[i] / 1.e6f;\n-\t\t\t\t\tacceleration[0] = sensors.accelerometer_integral_m_s[i * 3 + 0] / accel_dt;\n-\t\t\t\t\tacceleration[1] = sensors.accelerometer_integral_m_s[i * 3 + 1] / accel_dt;\n-\t\t\t\t\tacceleration[2] = sensors.accelerometer_integral_m_s[i * 3 + 2] / accel_dt;\n-\t\t\t\t\t_voter_accel.put(i, sensors.accelerometer_timestamp[i], acceleration, 0, 75);\n-\t\t\t\t}\n-\n-\t\t\t\tif (sensors.magnetometer_timestamp[i] > 0) {\n-\t\t\t\t\t_voter_mag.put(i, sensors.magnetometer_timestamp[i], &sensors.magnetometer_ga[i * 3], 0, 75);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// Get best measurement values\n-\t\t\thrt_abstime curr_time = hrt_absolute_time();\n-\t\t\t_gyro.set(_voter_gyro.get_best(curr_time, &best_gyro));\n-\t\t\t_accel.set(_voter_accel.get_best(curr_time, &best_accel));\n-\t\t\t_mag.set(_voter_mag.get_best(curr_time, &best_mag));\n-\n-\t\t\tif (_accel.length() < 0.01f) {\n-\t\t\t\twarnx(\"WARNING: degenerate accel!\");\n-\t\t\t\tcontinue;\n+\t\t\tif (sensors.timestamp > 0) {\n+\t\t\t\tfloat gyro_dt = sensors.gyro_integral_dt / 1e6;\n+\t\t\t\t_gyro(0) = sensors.gyro_integral_rad[0] / gyro_dt;\n+\t\t\t\t_gyro(1) = sensors.gyro_integral_rad[1] / gyro_dt;\n+\t\t\t\t_gyro(2) = sensors.gyro_integral_rad[2] / gyro_dt;\n \t\t\t}\n \n-\t\t\tif (_mag.length() < 0.01f) {\n-\t\t\t\twarnx(\"WARNING: degenerate mag!\");\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\t_data_good = true;\n-\n-\t\t\tif (!_failsafe) {\n-\t\t\t\tuint32_t flags = DataValidator::ERROR_FLAG_NO_ERROR;\n+\t\t\tif (sensors.accelerometer_timestamp > 0) {\n+\t\t\t\tfloat accel_dt = sensors.accelerometer_integral_dt / 1.e6f;\n+\t\t\t\t_accel(0) = sensors.accelerometer_integral_m_s[0] / accel_dt;\n+\t\t\t\t_accel(1) = sensors.accelerometer_integral_m_s[1] / accel_dt;\n+\t\t\t\t_accel(2) = sensors.accelerometer_integral_m_s[2] / accel_dt;\n \n-#ifdef __PX4_POSIX\n-\t\t\t\tperf_end(_perf_accel);\n-\t\t\t\tperf_end(_perf_mpu);\n-\t\t\t\tperf_end(_perf_mag);\n-#endif\n-\n-\t\t\t\tif (_voter_gyro.failover_count() > 0) {\n-\t\t\t\t\t_failsafe = true;\n-\t\t\t\t\tflags = _voter_gyro.failover_state();\n-\t\t\t\t\tmavlink_and_console_log_emergency(&_mavlink_log_pub, \"Gyro #%i failure :%s%s%s%s%s!\",\n-\t\t\t\t\t\t\t\t\t  _voter_gyro.failover_index(),\n-\t\t\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_NO_DATA) ? \" No data\" : \"\"),\n-\t\t\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_STALE_DATA) ? \" Stale data\" : \"\"),\n-\t\t\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_TIMEOUT) ? \" Data timeout\" : \"\"),\n-\t\t\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_HIGH_ERRCOUNT) ? \" High error count\" : \"\"),\n-\t\t\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_HIGH_ERRDENSITY) ? \" High error density\" : \"\"));\n-\t\t\t\t}\n-\n-\t\t\t\tif (_voter_accel.failover_count() > 0) {\n-\t\t\t\t\t_failsafe = true;\n-\t\t\t\t\tflags = _voter_accel.failover_state();\n-\t\t\t\t\tmavlink_and_console_log_emergency(&_mavlink_log_pub, \"Accel #%i failure :%s%s%s%s%s!\",\n-\t\t\t\t\t\t\t\t\t  _voter_accel.failover_index(),\n-\t\t\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_NO_DATA) ? \" No data\" : \"\"),\n-\t\t\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_STALE_DATA) ? \" Stale data\" : \"\"),\n-\t\t\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_TIMEOUT) ? \" Data timeout\" : \"\"),\n-\t\t\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_HIGH_ERRCOUNT) ? \" High error count\" : \"\"),\n-\t\t\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_HIGH_ERRDENSITY) ? \" High error density\" : \"\"));\n-\t\t\t\t}\n-\n-\t\t\t\tif (_voter_mag.failover_count() > 0) {\n-\t\t\t\t\t_failsafe = true;\n-\t\t\t\t\tflags = _voter_mag.failover_state();\n-\t\t\t\t\tmavlink_and_console_log_emergency(&_mavlink_log_pub, \"Mag #%i failure :%s%s%s%s%s!\",\n-\t\t\t\t\t\t\t\t\t  _voter_mag.failover_index(),\n-\t\t\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_NO_DATA) ? \" No data\" : \"\"),\n-\t\t\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_STALE_DATA) ? \" Stale data\" : \"\"),\n-\t\t\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_TIMEOUT) ? \" Data timeout\" : \"\"),\n-\t\t\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_HIGH_ERRCOUNT) ? \" High error count\" : \"\"),\n-\t\t\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_HIGH_ERRDENSITY) ? \" High error density\" : \"\"));\n-\t\t\t\t}\n-\n-\t\t\t\tif (_failsafe) {\n-\t\t\t\t\tmavlink_and_console_log_emergency(&_mavlink_log_pub, \"SENSOR FAILSAFE! RETURN TO LAND IMMEDIATELY\");\n+\t\t\t\tif (_accel.length() < 0.01f) {\n+\t\t\t\t\twarnx(\"WARNING: degenerate accel!\");\n+\t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tif (!_vibration_warning && (_voter_gyro.get_vibration_factor(curr_time) > _vibration_warning_threshold ||\n-\t\t\t\t\t\t    _voter_accel.get_vibration_factor(curr_time) > _vibration_warning_threshold ||\n-\t\t\t\t\t\t    _voter_mag.get_vibration_factor(curr_time) > _vibration_warning_threshold)) {\n+\t\t\tif (sensors.magnetometer_timestamp > 0) {\n+\t\t\t\t_mag(0) = sensors.magnetometer_ga[0];\n+\t\t\t\t_mag(1) = sensors.magnetometer_ga[1];\n+\t\t\t\t_mag(2) = sensors.magnetometer_ga[2];\n \n-\t\t\t\tif (_vibration_warning_timestamp == 0) {\n-\t\t\t\t\t_vibration_warning_timestamp = curr_time;\n-\n-\t\t\t\t} else if (hrt_elapsed_time(&_vibration_warning_timestamp) > 10000000) {\n-\t\t\t\t\t_vibration_warning = true;\n-\t\t\t\t\t// mavlink_and_console_log_critical(&_mavlink_log_pub, \"HIGH VIBRATION! g: %d a: %d m: %d\",\n-\t\t\t\t\t// \t\t\t\t (int)(100 * _voter_gyro.get_vibration_factor(curr_time)),\n-\t\t\t\t\t// \t\t\t\t (int)(100 * _voter_accel.get_vibration_factor(curr_time)),\n-\t\t\t\t\t// \t\t\t\t (int)(100 * _voter_mag.get_vibration_factor(curr_time)));\n+\t\t\t\tif (_mag.length() < 0.01f) {\n+\t\t\t\t\twarnx(\"WARNING: degenerate mag!\");\n+\t\t\t\t\tcontinue;\n \t\t\t\t}\n-\n-\t\t\t} else {\n-\t\t\t\t_vibration_warning_timestamp = 0;\n \t\t\t}\n+\n+\t\t\t_data_good = true;\n \t\t}\n \n \t\t// Update vision and motion capture heading\n@@ -596,10 +485,6 @@ void AttitudeEstimatorQ::task_main()\n \t\tmemcpy(&att.q[0], _q.data, sizeof(att.q));\n \t\tatt.q_valid = true;\n \n-\t\tatt.rate_vibration = _voter_gyro.get_vibration_factor(hrt_absolute_time());\n-\t\tatt.accel_vibration = _voter_accel.get_vibration_factor(hrt_absolute_time());\n-\t\tatt.mag_vibration = _voter_mag.get_vibration_factor(hrt_absolute_time());\n-\n \t\t/* the instance count is not used here */\n \t\tint att_inst;\n \t\torb_publish_auto(ORB_ID(vehicle_attitude), &_att_pub, &att, &att_inst, ORB_PRIO_HIGH);\n@@ -656,12 +541,9 @@ void AttitudeEstimatorQ::task_main()\n \t\t}\n \n \t\t{\n-\t\t\tstruct estimator_status_s est = {};\n+\t\t\t//struct estimator_status_s est = {};\n \n-\t\t\test.timestamp = sensors.timestamp;\n-\t\t\test.vibe[0] = _voter_accel.get_vibration_offset(est.timestamp, 0);\n-\t\t\test.vibe[1] = _voter_accel.get_vibration_offset(est.timestamp, 1);\n-\t\t\test.vibe[2] = _voter_accel.get_vibration_offset(est.timestamp, 2);\n+\t\t\t//est.timestamp = sensors.timestamp;\n \n \t\t\t/* the instance count is not used here */\n \t\t\t//int est_inst;\n@@ -672,6 +554,12 @@ void AttitudeEstimatorQ::task_main()\n \t\t}\n \t}\n \n+#ifdef __PX4_POSIX\n+\tperf_end(_perf_accel);\n+\tperf_end(_perf_mpu);\n+\tperf_end(_perf_mag);\n+#endif\n+\n \torb_unsubscribe(_sensors_sub);\n \torb_unsubscribe(_vision_sub);\n \torb_unsubscribe(_mocap_sub);\n@@ -706,7 +594,6 @@ void AttitudeEstimatorQ::update_parameters(bool force)\n \t\tparam_get(_params_handles.acc_comp, &acc_comp_int);\n \t\t_acc_comp = acc_comp_int != 0;\n \t\tparam_get(_params_handles.bias_max, &_bias_max);\n-\t\tparam_get(_params_handles.vibe_thresh, &_vibration_warning_threshold);\n \t\tparam_get(_params_handles.ext_hdg_mode, &_ext_hdg_mode);\n \t\tparam_get(_params_handles.airspeed_mode, &_airspeed_mode);\n \t}"},{"sha":"7138f3430965395c7c14e7ef52ae3cfb2d9874f0","filename":"src/modules/commander/calibration_routines.cpp","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fcommander%2Fcalibration_routines.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fcommander%2Fcalibration_routines.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fcommander%2Fcalibration_routines.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -273,7 +273,7 @@ enum detect_orientation_return detect_orientation(orb_advert_t *mavlink_log_pub,\n \n \t\t\tfor (unsigned i = 0; i < ndim; i++) {\n \n-\t\t\t\tfloat di = sensor.accelerometer_integral_m_s[i] / (sensor.accelerometer_integral_dt[0] / 1.e6f);\n+\t\t\t\tfloat di = sensor.accelerometer_integral_m_s[i] / (sensor.accelerometer_integral_dt / 1.e6f);\n \n \t\t\t\tfloat d = di - accel_ema[i];\n \t\t\t\taccel_ema[i] += d * w;"},{"sha":"c55c2d57d024e1777a3105bb8b621622d08af77e","filename":"src/modules/commander/commander.cpp","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fcommander%2Fcommander.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fcommander%2Fcommander.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fcommander%2Fcommander.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -1788,7 +1788,7 @@ int commander_thread_main(int argc, char *argv[])\n \t\t\t * vertical separation from other airtraffic the operator has to know when the\n \t\t\t * barometer is inoperational.\n \t\t\t * */\n-\t\t\tif (hrt_elapsed_time(&sensors.baro_timestamp[0]) < FAILSAFE_DEFAULT_TIMEOUT) {\n+\t\t\tif (hrt_elapsed_time(&sensors.baro_timestamp) < FAILSAFE_DEFAULT_TIMEOUT) {\n \t\t\t\t/* handle the case where baro was regained */\n \t\t\t\tif (status_flags.barometer_failure) {\n \t\t\t\t\tstatus_flags.barometer_failure = false;"},{"sha":"cb6e21d3aacef1cf5c4b2049a7086c0dd9db17e3","filename":"src/modules/ekf2/ekf2_main.cpp","status":"modified","additions":15,"deletions":15,"changes":30,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fekf2%2Fekf2_main.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fekf2%2Fekf2_main.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fekf2%2Fekf2_main.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -505,14 +505,14 @@ void Ekf2::task_main()\n \t\t}\n \n \t\t// push imu data into estimator\n-\t\t_ekf.setIMUData(now, sensors.gyro_integral_dt[0], sensors.accelerometer_integral_dt[0],\n-\t\t\t\t&sensors.gyro_integral_rad[0], &sensors.accelerometer_integral_m_s[0]);\n+\t\t_ekf.setIMUData(now, sensors.gyro_integral_dt, sensors.accelerometer_integral_dt,\n+\t\t\t\tsensors.gyro_integral_rad, sensors.accelerometer_integral_m_s);\n \n \t\t// read mag data\n-\t\t_ekf.setMagData(sensors.magnetometer_timestamp[0], &sensors.magnetometer_ga[0]);\n+\t\t_ekf.setMagData(sensors.magnetometer_timestamp, sensors.magnetometer_ga);\n \n \t\t// read baro data\n-\t\t_ekf.setBaroData(sensors.baro_timestamp[0], &sensors.baro_alt_meter[0]);\n+\t\t_ekf.setBaroData(sensors.baro_timestamp, &sensors.baro_alt_meter);\n \n \t\t// read gps data if available\n \t\tif (gps_updated) {\n@@ -615,7 +615,7 @@ void Ekf2::task_main()\n \t\t\tfloat gyro_bias[3] = {};\n \t\t\t_ekf.get_gyro_bias(gyro_bias);\n \t\t\tfloat gyro_rad_s[3];\n-\t\t\tfloat gyro_dt = sensors.gyro_integral_dt[0] / 1.e6f;\n+\t\t\tfloat gyro_dt = sensors.gyro_integral_dt / 1.e6f;\n \t\t\tgyro_rad_s[0] = sensors.gyro_integral_rad[0] / gyro_dt - gyro_bias[0];\n \t\t\tgyro_rad_s[1] = sensors.gyro_integral_rad[1] / gyro_dt - gyro_bias[1];\n \t\t\tgyro_rad_s[2] = sensors.gyro_integral_rad[2] / gyro_dt - gyro_bias[2];\n@@ -650,7 +650,7 @@ void Ekf2::task_main()\n \n \t\t\t// Acceleration data\n \t\t\tmatrix::Vector<float, 3> acceleration;\n-\t\t\tfloat accel_dt = sensors.accelerometer_integral_dt[0] / 1.e6f;\n+\t\t\tfloat accel_dt = sensors.accelerometer_integral_dt / 1.e6f;\n \t\t\tacceleration(0) = sensors.accelerometer_integral_m_s[0] / accel_dt;\n \t\t\tacceleration(1) = sensors.accelerometer_integral_m_s[1] / accel_dt;\n \t\t\tacceleration(2) = sensors.accelerometer_integral_m_s[2] / accel_dt;\n@@ -811,7 +811,7 @@ void Ekf2::task_main()\n \t\t\t\t// TODO use innovatun consistency check timouts to set this\n \t\t\t\tglobal_pos.dead_reckoning = false; // True if this position is estimated through dead-reckoning\n \n-\t\t\t\tglobal_pos.pressure_alt = sensors.baro_alt_meter[0]; // Pressure altitude AMSL (m)\n+\t\t\t\tglobal_pos.pressure_alt = sensors.baro_alt_meter; // Pressure altitude AMSL (m)\n \n \t\t\t\tif (_vehicle_global_position_pub == nullptr) {\n \t\t\t\t\t_vehicle_global_position_pub = orb_advertise(ORB_ID(vehicle_global_position), &global_pos);\n@@ -905,15 +905,15 @@ void Ekf2::task_main()\n \t\tif (publish_replay_message) {\n \t\t\tstruct ekf2_replay_s replay = {};\n \t\t\treplay.time_ref = now;\n-\t\t\treplay.gyro_integral_dt = sensors.gyro_integral_dt[0];\n-\t\t\treplay.accelerometer_integral_dt = sensors.accelerometer_integral_dt[0];\n-\t\t\treplay.magnetometer_timestamp = sensors.magnetometer_timestamp[0];\n-\t\t\treplay.baro_timestamp = sensors.baro_timestamp[0];\n-\t\t\tmemcpy(&replay.gyro_integral_rad[0], &sensors.gyro_integral_rad[0], sizeof(replay.gyro_integral_rad));\n-\t\t\tmemcpy(&replay.accelerometer_integral_m_s[0], &sensors.accelerometer_integral_m_s[0],\n+\t\t\treplay.gyro_integral_dt = sensors.gyro_integral_dt;\n+\t\t\treplay.accelerometer_integral_dt = sensors.accelerometer_integral_dt;\n+\t\t\treplay.magnetometer_timestamp = sensors.magnetometer_timestamp;\n+\t\t\treplay.baro_timestamp = sensors.baro_timestamp;\n+\t\t\tmemcpy(replay.gyro_integral_rad, sensors.gyro_integral_rad, sizeof(replay.gyro_integral_rad));\n+\t\t\tmemcpy(replay.accelerometer_integral_m_s, sensors.accelerometer_integral_m_s,\n \t\t\t       sizeof(replay.accelerometer_integral_m_s));\n-\t\t\tmemcpy(&replay.magnetometer_ga[0], &sensors.magnetometer_ga[0], sizeof(replay.magnetometer_ga));\n-\t\t\treplay.baro_alt_meter = sensors.baro_alt_meter[0];\n+\t\t\tmemcpy(replay.magnetometer_ga, sensors.magnetometer_ga, sizeof(replay.magnetometer_ga));\n+\t\t\treplay.baro_alt_meter = sensors.baro_alt_meter;\n \n \t\t\t// only write gps data if we had a gps update.\n \t\t\tif (gps_updated) {"},{"sha":"b92014081f26f79d402d3b732d16a9e7e88d7df7","filename":"src/modules/ekf2_replay/ekf2_replay_main.cpp","status":"modified","additions":5,"deletions":5,"changes":10,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fekf2_replay%2Fekf2_replay_main.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fekf2_replay%2Fekf2_replay_main.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fekf2_replay%2Fekf2_replay_main.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -377,10 +377,10 @@ void Ekf2Replay::setEstimatorInput(uint8_t *data, uint8_t type)\n \t\tuint8_t *dest_ptr = (uint8_t *)&replay_part1.time_ref;\n \t\tparseMessage(data, dest_ptr, type);\n \t\t_sensors.timestamp = replay_part1.time_ref;\n-\t\t_sensors.gyro_integral_dt[0] = replay_part1.gyro_integral_dt;\n-\t\t_sensors.accelerometer_integral_dt[0] = replay_part1.accelerometer_integral_dt;\n-\t\t_sensors.magnetometer_timestamp[0] = replay_part1.magnetometer_timestamp;\n-\t\t_sensors.baro_timestamp[0] = replay_part1.baro_timestamp;\n+\t\t_sensors.gyro_integral_dt = replay_part1.gyro_integral_dt;\n+\t\t_sensors.accelerometer_integral_dt = replay_part1.accelerometer_integral_dt;\n+\t\t_sensors.magnetometer_timestamp = replay_part1.magnetometer_timestamp;\n+\t\t_sensors.baro_timestamp = replay_part1.baro_timestamp;\n \t\t_sensors.gyro_integral_rad[0] = replay_part1.gyro_integral_x_rad;\n \t\t_sensors.gyro_integral_rad[1] = replay_part1.gyro_integral_y_rad;\n \t\t_sensors.gyro_integral_rad[2] = replay_part1.gyro_integral_z_rad;\n@@ -390,7 +390,7 @@ void Ekf2Replay::setEstimatorInput(uint8_t *data, uint8_t type)\n \t\t_sensors.magnetometer_ga[0] = replay_part1.magnetometer_x_ga;\n \t\t_sensors.magnetometer_ga[1] = replay_part1.magnetometer_y_ga;\n \t\t_sensors.magnetometer_ga[2] = replay_part1.magnetometer_z_ga;\n-\t\t_sensors.baro_alt_meter[0] = replay_part1.baro_alt_meter;\n+\t\t_sensors.baro_alt_meter = replay_part1.baro_alt_meter;\n \t\t_part1_counter_ref = _message_counter;\n \n \t} else if (type == LOG_RPL2_MSG) {"},{"sha":"92a729a413b789b656f46576e661b85211b535e2","filename":"src/modules/ekf_att_pos_estimator/AttitudePositionEstimatorEKF.h","status":"modified","additions":0,"deletions":11,"changes":11,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fekf_att_pos_estimator%2FAttitudePositionEstimatorEKF.h","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fekf_att_pos_estimator%2FAttitudePositionEstimatorEKF.h","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fekf_att_pos_estimator%2FAttitudePositionEstimatorEKF.h?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -71,7 +71,6 @@\n #include <geo/geo.h>\n #include <terrain_estimation/terrain_estimator.h>\n #include <systemlib/perf_counter.h>\n-#include <lib/ecl/validation/data_validator_group.h>\n #include \"estimator_22states.h\"\n \n #include <controllib/blocks.hpp>\n@@ -191,8 +190,6 @@ class AttitudePositionEstimatorEKF : public control::SuperBlock\n     float                       _filter_ref_offset;   /**< offset between initial baro reference and GPS init baro altitude */\n     float                       _baro_gps_offset;   /**< offset between baro altitude (at GPS init time) and GPS altitude */\n     hrt_abstime                 _last_debug_print = 0;\n-    float       _vibration_warning_threshold = 2.0f;\n-    hrt_abstime _vibration_warning_timestamp = 0;\n \n     perf_counter_t  _loop_perf;         ///< loop performance counter\n     perf_counter_t  _loop_intvl;        ///< loop rate counter\n@@ -213,15 +210,7 @@ class AttitudePositionEstimatorEKF : public control::SuperBlock\n     hrt_abstime     _filter_start_time;\n     hrt_abstime     _last_sensor_timestamp;\n     hrt_abstime     _distance_last_valid;\n-    DataValidatorGroup _voter_gyro;\n-    DataValidatorGroup _voter_accel;\n-    DataValidatorGroup _voter_mag;\n-    int             _gyro_main;         ///< index of the main gyroscope\n-    int             _accel_main;        ///< index of the main accelerometer\n-    int             _mag_main;          ///< index of the main magnetometer\n     bool            _data_good;         ///< all required filter data is ok\n-    bool            _failsafe;          ///< failsafe on one of the sensors\n-    bool            _vibration_warning; ///< high vibration levels detected\n     bool            _ekf_logging;       ///< log EKF state\n     unsigned        _debug;             ///< debug level - default 0\n     bool            _was_landed;        ///< indicates if was landed in previous iteration"},{"sha":"d426c8d3ea6a66645d162213b7956dbdb73fdc9c","filename":"src/modules/ekf_att_pos_estimator/ekf_att_pos_estimator_main.cpp","status":"modified","additions":25,"deletions":111,"changes":136,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fekf_att_pos_estimator%2Fekf_att_pos_estimator_main.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fekf_att_pos_estimator%2Fekf_att_pos_estimator_main.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fekf_att_pos_estimator%2Fekf_att_pos_estimator_main.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -205,15 +205,7 @@ AttitudePositionEstimatorEKF::AttitudePositionEstimatorEKF() :\n \t_filter_start_time(0),\n \t_last_sensor_timestamp(hrt_absolute_time()),\n \t_distance_last_valid(0),\n-\t_voter_gyro(3),\n-\t_voter_accel(3),\n-\t_voter_mag(3),\n-\t_gyro_main(-1),\n-\t_accel_main(-1),\n-\t_mag_main(-1),\n \t_data_good(false),\n-\t_failsafe(false),\n-\t_vibration_warning(false),\n \t_ekf_logging(true),\n \t_debug(0),\n \t_was_landed(true),\n@@ -236,8 +228,6 @@ AttitudePositionEstimatorEKF::AttitudePositionEstimatorEKF() :\n \t_LP_att_Q(250.0f, 20.0f),\n \t_LP_att_R(250.0f, 20.0f)\n {\n-\t_voter_mag.set_timeout(200000);\n-\n \t_terrain_estimator = new TerrainEstimator();\n \n \t_parameter_handles.vel_delay_ms = param_find(\"PE_VEL_DELAY_MS\");\n@@ -620,19 +610,9 @@ void AttitudePositionEstimatorEKF::task_main()\n \t\t\t\t/* system is in HIL now, wait for measurements to come in one last round */\n \t\t\t\tusleep(60000);\n \n-\t\t\t\t/* HIL is slow, set permissive timeouts */\n-\t\t\t\t_voter_gyro.set_timeout(500000);\n-\t\t\t\t_voter_accel.set_timeout(500000);\n-\t\t\t\t_voter_mag.set_timeout(500000);\n-\n \t\t\t\t/* now read all sensor publications to ensure all real sensor data is purged */\n \t\t\t\torb_copy(ORB_ID(sensor_combined), _sensor_combined_sub, &_sensor_combined);\n \n-\t\t\t\t/* set sensors to de-initialized state */\n-\t\t\t\t_gyro_main = -1;\n-\t\t\t\t_accel_main = -1;\n-\t\t\t\t_mag_main = -1;\n-\n \t\t\t\t_baro_init = false;\n \t\t\t\t_gps_initialized = false;\n \n@@ -664,7 +644,8 @@ void AttitudePositionEstimatorEKF::task_main()\n \t\t\t *    We run the filter only once all data has been fetched\n \t\t\t **/\n \n-\t\t\tif (_baro_init && (_gyro_main >= 0) && (_accel_main >= 0) && (_mag_main >= 0)) {\n+\t\t\tif (_baro_init && _sensor_combined.accelerometer_timestamp && _sensor_combined.timestamp\n+\t\t\t\t\t&& _sensor_combined.magnetometer_timestamp) {\n \n \t\t\t\t// maintain filtered baro and gps altitudes to calculate weather offset\n \t\t\t\t// baro sample rate is ~70Hz and measurement bandwidth is high\n@@ -1343,13 +1324,6 @@ void AttitudePositionEstimatorEKF::print_status()\n \t\t (_ekf->useAirspeed) ? \"USE_AIRSPD\" : \"IGN_AIRSPD\",\n \t\t (_ekf->useCompass) ? \"USE_COMPASS\" : \"IGN_COMPASS\",\n \t\t (_ekf->staticMode) ? \"STATIC_MODE\" : \"DYNAMIC_MODE\");\n-\n-\tPX4_INFO(\"gyro status:\");\n-\t_voter_gyro.print();\n-\tPX4_INFO(\"accel status:\");\n-\t_voter_accel.print();\n-\tPX4_INFO(\"mag status:\");\n-\t_voter_mag.print();\n }\n \n void AttitudePositionEstimatorEKF::pollData()\n@@ -1382,97 +1356,37 @@ void AttitudePositionEstimatorEKF::pollData()\n \t/* fill in last data set */\n \t_ekf->dtIMU = deltaT;\n \n-\t// Feed validator with recent sensor data\n-\n-\t//TODO: note, we will move voters into sensors module\n-\tfor (unsigned i = 0; i < (sizeof(_sensor_combined.gyro_timestamp) / sizeof(_sensor_combined.gyro_timestamp[0])); i++) {\n-\t\tfloat gyro_rad_s[3];\n-\t\tfloat gyro_dt = _sensor_combined.gyro_integral_dt[i] / 1.e6f;\n-\t\tgyro_rad_s[0] = _sensor_combined.gyro_integral_rad[i * 3 + 0] / gyro_dt;\n-\t\tgyro_rad_s[1] = _sensor_combined.gyro_integral_rad[i * 3 + 1] / gyro_dt;\n-\t\tgyro_rad_s[2] = _sensor_combined.gyro_integral_rad[i * 3 + 2] / gyro_dt;\n-\t\t_voter_gyro.put(i, _sensor_combined.gyro_timestamp[i], gyro_rad_s, 0, 75);\n-\t\tfloat acceleration[3];\n-\t\tfloat accel_dt = _sensor_combined.accelerometer_integral_dt[i] / 1.e6f;\n-\t\tacceleration[0] = _sensor_combined.accelerometer_integral_m_s[i * 3 + 0] / accel_dt;\n-\t\tacceleration[1] = _sensor_combined.accelerometer_integral_m_s[i * 3 + 1] / accel_dt;\n-\t\tacceleration[2] = _sensor_combined.accelerometer_integral_m_s[i * 3 + 2] / accel_dt;\n-\t\t_voter_accel.put(i, _sensor_combined.accelerometer_timestamp[i], acceleration, 0, 75);\n-\t\t_voter_mag.put(i, _sensor_combined.magnetometer_timestamp[i], &_sensor_combined.magnetometer_ga[i * 3], 0, 75);\n-\t}\n+\t_ekf->dAngIMU.x = _sensor_combined.gyro_integral_rad[0];\n+\t_ekf->dAngIMU.y = _sensor_combined.gyro_integral_rad[1];\n+\t_ekf->dAngIMU.z = _sensor_combined.gyro_integral_rad[2];\n \n-\t// Get best measurement values\n-\thrt_abstime curr_time = hrt_absolute_time();\n-\t(void)_voter_gyro.get_best(curr_time, &_gyro_main);\n+\tfloat gyro_dt = _sensor_combined.gyro_integral_dt / 1.e6f;\n+\t_ekf->angRate = _ekf->dAngIMU / gyro_dt;\n \n-\tif (_gyro_main >= 0) {\n+\tperf_count(_perf_gyro);\n \n-\t\t_ekf->dAngIMU.x = _sensor_combined.gyro_integral_rad[_gyro_main * 3 + 0];\n-\t\t_ekf->dAngIMU.y = _sensor_combined.gyro_integral_rad[_gyro_main * 3 + 1];\n-\t\t_ekf->dAngIMU.z = _sensor_combined.gyro_integral_rad[_gyro_main * 3 + 2];\n+\tif (_last_accel != _sensor_combined.accelerometer_timestamp) {\n \n-\t\tfloat gyro_dt = _sensor_combined.gyro_integral_dt[_gyro_main] / 1.e6f;\n-\t\t_ekf->angRate = _ekf->dAngIMU / gyro_dt;\n+\t\t_ekf->dVelIMU.x = _sensor_combined.accelerometer_integral_m_s[0];\n+\t\t_ekf->dVelIMU.y = _sensor_combined.accelerometer_integral_m_s[1];\n+\t\t_ekf->dVelIMU.z = _sensor_combined.accelerometer_integral_m_s[2];\n \n-\t\tperf_count(_perf_gyro);\n-\t}\n-\n-\t(void)_voter_accel.get_best(curr_time, &_accel_main);\n-\n-\tif (_accel_main >= 0 && (_last_accel != _sensor_combined.accelerometer_timestamp[_accel_main])) {\n-\n-\t\t_ekf->dVelIMU.x = _sensor_combined.accelerometer_integral_m_s[_accel_main * 3 + 0];\n-\t\t_ekf->dVelIMU.y = _sensor_combined.accelerometer_integral_m_s[_accel_main * 3 + 1];\n-\t\t_ekf->dVelIMU.z = _sensor_combined.accelerometer_integral_m_s[_accel_main * 3 + 2];\n-\n-\t\tfloat accel_dt = _sensor_combined.accelerometer_integral_dt[_accel_main] / 1.e6f;\n+\t\tfloat accel_dt = _sensor_combined.accelerometer_integral_dt / 1.e6f;\n \t\t_ekf->accel = _ekf->dVelIMU / accel_dt;\n \n-\t\t_last_accel = _sensor_combined.accelerometer_timestamp[_accel_main];\n-\t}\n-\n-\t(void)_voter_mag.get_best(curr_time, &_mag_main);\n-\n-\tif (_mag_main >= 0) {\n-\t\tVector3f mag(_sensor_combined.magnetometer_ga[_mag_main * 3 + 0], _sensor_combined.magnetometer_ga[_mag_main * 3 + 1],\n-\t\t\t     _sensor_combined.magnetometer_ga[_mag_main * 3 + 2]);\n-\n-\t\t/* fail over to the 2nd mag if we know the first is down */\n-\t\tif (mag.length() > 0.1f && (_last_mag != _sensor_combined.magnetometer_timestamp[_mag_main])) {\n-\t\t\t_ekf->magData.x = mag.x;\n-\t\t\t_ekf->magData.y = mag.y;\n-\t\t\t_ekf->magData.z = mag.z;\n-\t\t\t_newDataMag = true;\n-\t\t\t_last_mag = _sensor_combined.magnetometer_timestamp[_mag_main];\n-\t\t\tperf_count(_perf_mag);\n-\t\t}\n+\t\t_last_accel = _sensor_combined.accelerometer_timestamp;\n \t}\n \n-\tif (!_failsafe && (_voter_gyro.failover_count() > 0 ||\n-\t\t\t   _voter_accel.failover_count() > 0 ||\n-\t\t\t   _voter_mag.failover_count() > 0)) {\n-\n-\t\t_failsafe = true;\n-\t\tmavlink_and_console_log_emergency(&_mavlink_log_pub, \"SENSOR FAILSAFE! RETURN TO LAND IMMEDIATELY\");\n-\t}\n+\tVector3f mag(_sensor_combined.magnetometer_ga[0], _sensor_combined.magnetometer_ga[1],\n+\t\t\t_sensor_combined.magnetometer_ga[2]);\n \n-\tif (!_vibration_warning && (_voter_gyro.get_vibration_factor(curr_time) > _vibration_warning_threshold ||\n-\t\t\t\t    _voter_accel.get_vibration_factor(curr_time) > _vibration_warning_threshold ||\n-\t\t\t\t    _voter_mag.get_vibration_factor(curr_time) > _vibration_warning_threshold)) {\n-\n-\t\tif (_vibration_warning_timestamp == 0) {\n-\t\t\t_vibration_warning_timestamp = curr_time;\n-\n-\t\t} else if (hrt_elapsed_time(&_vibration_warning_timestamp) > 10000000) {\n-\t\t\t_vibration_warning = true;\n-\t\t\t// mavlink_and_console_log_critical(&_mavlink_log_pub, \"HIGH VIBRATION! g: %d a: %d m: %d\",\n-\t\t\t// \t\t\t\t (int)(100 * _voter_gyro.get_vibration_factor(curr_time)),\n-\t\t\t// \t\t\t\t (int)(100 * _voter_accel.get_vibration_factor(curr_time)),\n-\t\t\t// \t\t\t\t (int)(100 * _voter_mag.get_vibration_factor(curr_time)));\n-\t\t}\n-\n-\t} else {\n-\t\t_vibration_warning_timestamp = 0;\n+\tif (mag.length() > 0.1f && _last_mag != _sensor_combined.magnetometer_timestamp) {\n+\t\t_ekf->magData.x = mag.x;\n+\t\t_ekf->magData.y = mag.y;\n+\t\t_ekf->magData.z = mag.z;\n+\t\t_newDataMag = true;\n+\t\t_last_mag = _sensor_combined.magnetometer_timestamp;\n+\t\tperf_count(_perf_mag);\n \t}\n \n \t_last_sensor_timestamp = _sensor_combined.timestamp;\n@@ -1481,8 +1395,8 @@ void AttitudePositionEstimatorEKF::pollData()\n \t// leave this in as long as larger improvements are still being made.\n #if 0\n \n-\tfloat deltaTIntegral = (_sensor_combined.gyro_integral_dt[0]) / 1e6f;\n-\tfloat deltaTIntAcc = (_sensor_combined.accelerometer_integral_dt[0]) / 1e6f;\n+\tfloat deltaTIntegral = _sensor_combined.gyro_integral_dt / 1e6f;\n+\tfloat deltaTIntAcc = _sensor_combined.accelerometer_integral_dt / 1e6f;\n \n \tstatic unsigned dtoverflow5 = 0;\n \tstatic unsigned dtoverflow10 = 0;"},{"sha":"f604581a75ea475884a32e5597fd825978c3798a","filename":"src/modules/fw_pos_control_l1/fw_pos_control_l1_main.cpp","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Ffw_pos_control_l1%2Ffw_pos_control_l1_main.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Ffw_pos_control_l1%2Ffw_pos_control_l1_main.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Ffw_pos_control_l1%2Ffw_pos_control_l1_main.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -1231,7 +1231,7 @@ FixedwingPositionControl::control_position(const math::Vector<2> &current_positi\n \n \t/* filter speed and altitude for controller */\n \tmath::Vector<3> accel_body;\n-\tfloat accel_dt = _sensor_combined.accelerometer_integral_dt[0] / 1.e6f;\n+\tfloat accel_dt = _sensor_combined.accelerometer_integral_dt / 1.e6f;\n \taccel_body(0) = _sensor_combined.accelerometer_integral_m_s[0] / accel_dt;\n \taccel_body(1) = _sensor_combined.accelerometer_integral_m_s[1] / accel_dt;\n \taccel_body(2) = _sensor_combined.accelerometer_integral_m_s[2] / accel_dt;"},{"sha":"cb0301f8a0c328e4bd30f69e104d53892aad4564","filename":"src/modules/local_position_estimator/BlockLocalPositionEstimator.cpp","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Flocal_position_estimator%2FBlockLocalPositionEstimator.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Flocal_position_estimator%2FBlockLocalPositionEstimator.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Flocal_position_estimator%2FBlockLocalPositionEstimator.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -744,7 +744,7 @@ void BlockLocalPositionEstimator::publishGlobalPos()\n \t\t_pub_gpos.get().terrain_alt = _altHome - xLP(X_tz);\n \t\t_pub_gpos.get().terrain_alt_valid = _validTZ;\n \t\t_pub_gpos.get().dead_reckoning = !_validXY && !_xyTimeout;\n-\t\t_pub_gpos.get().pressure_alt = _sub_sensor.get().baro_alt_meter[0];\n+\t\t_pub_gpos.get().pressure_alt = _sub_sensor.get().baro_alt_meter;\n \t\t_pub_gpos.update();\n \t}\n }\n@@ -845,7 +845,7 @@ void BlockLocalPositionEstimator::predict()\n \tif (integrate && _sub_att.get().R_valid) {\n \t\tMatrix3f R_att(_sub_att.get().R);\n \t\tVector3f a;\n-\t\tfloat accel_dt = _sub_sensor.get().accelerometer_integral_dt[0] / 1.e6f;\n+\t\tfloat accel_dt = _sub_sensor.get().accelerometer_integral_dt / 1.e6f;\n \t\ta(0) = _sub_sensor.get().accelerometer_integral_m_s[0] / accel_dt;\n \t\ta(1) = _sub_sensor.get().accelerometer_integral_m_s[1] / accel_dt;\n \t\ta(2) = _sub_sensor.get().accelerometer_integral_m_s[2] / accel_dt;"},{"sha":"ffe8e51611e69ed100dbd6aac1c64f0a8d590f3b","filename":"src/modules/local_position_estimator/sensors/baro.cpp","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Flocal_position_estimator%2Fsensors%2Fbaro.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Flocal_position_estimator%2Fsensors%2Fbaro.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Flocal_position_estimator%2Fsensors%2Fbaro.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -41,7 +41,7 @@ int BlockLocalPositionEstimator::baroMeasure(Vector<float, n_y_baro> &y)\n {\n \t//measure\n \ty.setZero();\n-\ty(0) = _sub_sensor.get().baro_alt_meter[0];\n+\ty(0) = _sub_sensor.get().baro_alt_meter;\n \t_baroStats.update(y);\n \t_time_last_baro = _timeStamp;\n \treturn OK;"},{"sha":"da77fd07ba31622e1901b6032af56a4fa074d96e","filename":"src/modules/mavlink/mavlink_messages.cpp","status":"modified","additions":14,"deletions":14,"changes":28,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fmavlink%2Fmavlink_messages.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fmavlink%2Fmavlink_messages.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fmavlink%2Fmavlink_messages.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -724,39 +724,39 @@ class MavlinkStreamHighresIMU : public MavlinkStream\n \t\tif (_sensor_sub->update(&_sensor_time, &sensor)) {\n \t\t\tuint16_t fields_updated = 0;\n \n-\t\t\tif (_accel_timestamp != sensor.accelerometer_timestamp[0]) {\n+\t\t\tif (_accel_timestamp != sensor.accelerometer_timestamp) {\n \t\t\t\t/* mark first three dimensions as changed */\n \t\t\t\tfields_updated |= (1 << 0) | (1 << 1) | (1 << 2);\n-\t\t\t\t_accel_timestamp = sensor.accelerometer_timestamp[0];\n+\t\t\t\t_accel_timestamp = sensor.accelerometer_timestamp;\n \t\t\t}\n \n-\t\t\tif (_gyro_timestamp != sensor.gyro_timestamp[0]) {\n+\t\t\tif (_gyro_timestamp != sensor.timestamp) {\n \t\t\t\t/* mark second group dimensions as changed */\n \t\t\t\tfields_updated |= (1 << 3) | (1 << 4) | (1 << 5);\n-\t\t\t\t_gyro_timestamp = sensor.gyro_timestamp[0];\n+\t\t\t\t_gyro_timestamp = sensor.timestamp;\n \t\t\t}\n \n-\t\t\tif (_mag_timestamp != sensor.magnetometer_timestamp[0]) {\n+\t\t\tif (_mag_timestamp != sensor.magnetometer_timestamp) {\n \t\t\t\t/* mark third group dimensions as changed */\n \t\t\t\tfields_updated |= (1 << 6) | (1 << 7) | (1 << 8);\n-\t\t\t\t_mag_timestamp = sensor.magnetometer_timestamp[0];\n+\t\t\t\t_mag_timestamp = sensor.magnetometer_timestamp;\n \t\t\t}\n \n-\t\t\tif (_baro_timestamp != sensor.baro_timestamp[0]) {\n+\t\t\tif (_baro_timestamp != sensor.baro_timestamp) {\n \t\t\t\t/* mark last group dimensions as changed */\n \t\t\t\tfields_updated |= (1 << 9) | (1 << 11) | (1 << 12);\n-\t\t\t\t_baro_timestamp = sensor.baro_timestamp[0];\n+\t\t\t\t_baro_timestamp = sensor.baro_timestamp;\n \t\t\t}\n \t\t\t_differential_pressure_sub->update(&_differential_pressure_time, &differential_pressure);\n \n \t\t\tmavlink_highres_imu_t msg;\n \n \t\t\tmsg.time_usec = sensor.timestamp;\n-\t\t\tfloat accel_dt = sensor.accelerometer_integral_dt[0] / 1.e6f;\n+\t\t\tfloat accel_dt = sensor.accelerometer_integral_dt / 1.e6f;\n \t\t\tmsg.xacc = sensor.accelerometer_integral_m_s[0] / accel_dt;\n \t\t\tmsg.yacc = sensor.accelerometer_integral_m_s[1] / accel_dt;\n \t\t\tmsg.zacc = sensor.accelerometer_integral_m_s[2] / accel_dt;\n-\t\t\tfloat gyro_dt = sensor.gyro_integral_dt[0] / 1.e6f;\n+\t\t\tfloat gyro_dt = sensor.gyro_integral_dt / 1.e6f;\n \t\t\tmsg.xgyro = sensor.gyro_integral_rad[0] / gyro_dt;\n \t\t\tmsg.ygyro = sensor.gyro_integral_rad[1] / gyro_dt;\n \t\t\tmsg.zgyro = sensor.gyro_integral_rad[2] / gyro_dt;\n@@ -765,8 +765,8 @@ class MavlinkStreamHighresIMU : public MavlinkStream\n \t\t\tmsg.zmag = sensor.magnetometer_ga[2];\n \t\t\tmsg.abs_pressure = 0;\n \t\t\tmsg.diff_pressure = differential_pressure.differential_pressure_raw_pa;\n-\t\t\tmsg.pressure_alt = sensor.baro_alt_meter[0];\n-\t\t\tmsg.temperature = sensor.baro_temp_celcius[0];\n+\t\t\tmsg.pressure_alt = sensor.baro_alt_meter;\n+\t\t\tmsg.temperature = sensor.baro_temp_celcius;\n \t\t\tmsg.fields_updated = fields_updated;\n \n \t\t\tmavlink_msg_highres_imu_send_struct(_mavlink->get_channel(), &msg);\n@@ -1014,7 +1014,7 @@ class MavlinkStreamVFRHUD : public MavlinkStream\n \t\t\t\t/* fall back to baro altitude */\n \t\t\t\tsensor_combined_s sensor;\n \t\t\t\t(void)_sensor_sub->update(&_sensor_time, &sensor);\n-\t\t\t\tmsg.alt = sensor.baro_alt_meter[0];\n+\t\t\t\tmsg.alt = sensor.baro_alt_meter;\n \t\t\t}\n \t\t\tmsg.climb = -pos.vel_d;\n \n@@ -3121,7 +3121,7 @@ class MavlinkStreamAltitude : public MavlinkStream\n \n \t\t\tmsg.time_usec = hrt_absolute_time();\n \n-\t\t\tmsg.altitude_monotonic = (_sensor_time > 0) ? sensor.baro_alt_meter[0] : NAN;\n+\t\t\tmsg.altitude_monotonic = (_sensor_time > 0) ? sensor.baro_alt_meter : NAN;\n \t\t\tmsg.altitude_amsl = (_global_pos_time > 0) ? global_pos.alt : NAN;\n \t\t\tmsg.altitude_local = (_local_pos_time > 0) ? -local_pos.z : NAN;\n \t\t\tmsg.altitude_relative = (_home_time > 0) ? (global_pos.alt - home.alt) : NAN;"},{"sha":"62cf3b3f9c29620eb648acbe022dbc2bb734d4f1","filename":"src/modules/mavlink/mavlink_receiver.cpp","status":"modified","additions":8,"deletions":10,"changes":18,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fmavlink%2Fmavlink_receiver.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fmavlink%2Fmavlink_receiver.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fmavlink%2Fmavlink_receiver.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -1673,34 +1673,32 @@ MavlinkReceiver::handle_message_hil_sensor(mavlink_message_t *msg)\n \t{\n \t\tstruct sensor_combined_s hil_sensors = {};\n \n-\t\thil_sensors.timestamp = timestamp;\n-\n \t\thil_sensors.gyro_integral_rad[0] = 0.5f * (imu.xgyro + _hil_prev_gyro[0]) * dt;\n \t\thil_sensors.gyro_integral_rad[1] = 0.5f * (imu.ygyro + _hil_prev_gyro[1]) * dt;\n \t\thil_sensors.gyro_integral_rad[2] = 0.5f * (imu.zgyro + _hil_prev_gyro[2]) * dt;\n \t\t_hil_prev_gyro[0] = imu.xgyro;\n \t\t_hil_prev_gyro[1] = imu.ygyro;\n \t\t_hil_prev_gyro[2] = imu.zgyro;\n-\t\thil_sensors.gyro_integral_dt[0] = dt * 1e6f;\n-\t\thil_sensors.gyro_timestamp[0] = timestamp;\n+\t\thil_sensors.gyro_integral_dt = dt * 1e6f;\n+\t\thil_sensors.timestamp = timestamp;\n \n \t\thil_sensors.accelerometer_integral_m_s[0] = 0.5f * (imu.xacc + _hil_prev_accel[0]) * dt;\n \t\thil_sensors.accelerometer_integral_m_s[1] = 0.5f * (imu.yacc + _hil_prev_accel[1]) * dt;\n \t\thil_sensors.accelerometer_integral_m_s[2] = 0.5f * (imu.zacc + _hil_prev_accel[2]) * dt;\n \t\t_hil_prev_accel[0] = imu.xacc;\n \t\t_hil_prev_accel[1] = imu.yacc;\n \t\t_hil_prev_accel[2] = imu.zacc;\n-\t\thil_sensors.accelerometer_integral_dt[0] = dt * 1e6f;\n-\t\thil_sensors.accelerometer_timestamp[0] = timestamp;\n+\t\thil_sensors.accelerometer_integral_dt = dt * 1e6f;\n+\t\thil_sensors.accelerometer_timestamp = timestamp;\n \n \t\thil_sensors.magnetometer_ga[0] = imu.xmag;\n \t\thil_sensors.magnetometer_ga[1] = imu.ymag;\n \t\thil_sensors.magnetometer_ga[2] = imu.zmag;\n-\t\thil_sensors.magnetometer_timestamp[0] = timestamp;\n+\t\thil_sensors.magnetometer_timestamp = timestamp;\n \n-\t\thil_sensors.baro_alt_meter[0] = imu.pressure_alt;\n-\t\thil_sensors.baro_temp_celcius[0] = imu.temperature;\n-\t\thil_sensors.baro_timestamp[0] = timestamp;\n+\t\thil_sensors.baro_alt_meter = imu.pressure_alt;\n+\t\thil_sensors.baro_temp_celcius = imu.temperature;\n+\t\thil_sensors.baro_timestamp = timestamp;\n \n \t\t/* publish combined sensor topic */\n \t\tif (_sensors_pub == nullptr) {"},{"sha":"c3e606da0d538a08ebbd63e8f328b625599b9f27","filename":"src/modules/navigator/navigator_main.cpp","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fnavigator%2Fnavigator_main.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -500,7 +500,7 @@ Navigator::task_main()\n \t\tif (have_geofence_position_data &&\n \t\t\t(_geofence.getGeofenceAction() != geofence_result_s::GF_ACTION_NONE) &&\n \t\t\t(hrt_elapsed_time(&last_geofence_check) > GEOFENCE_CHECK_INTERVAL)) {\n-\t\t\tbool inside = _geofence.inside(_global_pos, _gps_pos, _sensor_combined.baro_alt_meter[0], _home_pos, home_position_valid());\n+\t\t\tbool inside = _geofence.inside(_global_pos, _gps_pos, _sensor_combined.baro_alt_meter, _home_pos, home_position_valid());\n \t\t\tlast_geofence_check = hrt_absolute_time();\n \t\t\thave_geofence_position_data = false;\n "},{"sha":"7ef5cd710664bc42611fc379ee8ab5375c1184cd","filename":"src/modules/position_estimator_inav/position_estimator_inav_main.cpp","status":"modified","additions":11,"deletions":11,"changes":22,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fposition_estimator_inav%2Fposition_estimator_inav_main.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fposition_estimator_inav%2Fposition_estimator_inav_main.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fposition_estimator_inav%2Fposition_estimator_inav_main.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -425,14 +425,14 @@ int position_estimator_inav_thread_main(int argc, char *argv[])\n \t\t\tif (fds_init[0].revents & POLLIN) {\n \t\t\t\torb_copy(ORB_ID(sensor_combined), sensor_combined_sub, &sensor);\n \n-\t\t\t\tif (wait_baro && sensor.baro_timestamp[0] != baro_timestamp) {\n-\t\t\t\t\tbaro_timestamp = sensor.baro_timestamp[0];\n+\t\t\t\tif (wait_baro && sensor.baro_timestamp != baro_timestamp) {\n+\t\t\t\t\tbaro_timestamp = sensor.baro_timestamp;\n \t\t\t\t\tbaro_wait_for_sample_time = hrt_absolute_time();\n \n \t\t\t\t\t/* mean calculation over several measurements */\n \t\t\t\t\tif (baro_init_cnt < baro_init_num) {\n-\t\t\t\t\t\tif (PX4_ISFINITE(sensor.baro_alt_meter[0])) {\n-\t\t\t\t\t\t\tbaro_offset += sensor.baro_alt_meter[0];\n+\t\t\t\t\t\tif (PX4_ISFINITE(sensor.baro_alt_meter)) {\n+\t\t\t\t\t\t\tbaro_offset += sensor.baro_alt_meter;\n \t\t\t\t\t\t\tbaro_init_cnt++;\n \t\t\t\t\t\t}\n \n@@ -502,10 +502,10 @@ int position_estimator_inav_thread_main(int argc, char *argv[])\n \t\t\tif (updated) {\n \t\t\t\torb_copy(ORB_ID(sensor_combined), sensor_combined_sub, &sensor);\n \n-\t\t\t\tif (sensor.accelerometer_timestamp[0] != accel_timestamp) {\n+\t\t\t\tif (sensor.accelerometer_timestamp != accel_timestamp) {\n \t\t\t\t\tif (att.R_valid) {\n \t\t\t\t\t\tfloat sensor_accel[3];\n-\t\t\t\t\t\tfloat accel_dt = sensor.accelerometer_integral_dt[0] / 1.e6f;\n+\t\t\t\t\t\tfloat accel_dt = sensor.accelerometer_integral_dt / 1.e6f;\n \t\t\t\t\t\tsensor_accel[0] = sensor.accelerometer_integral_m_s[0] / accel_dt - acc_bias[0];\n \t\t\t\t\t\tsensor_accel[1] = sensor.accelerometer_integral_m_s[1] / accel_dt - acc_bias[1];\n \t\t\t\t\t\tsensor_accel[2] = sensor.accelerometer_integral_m_s[2] / accel_dt - acc_bias[2];\n@@ -525,13 +525,13 @@ int position_estimator_inav_thread_main(int argc, char *argv[])\n \t\t\t\t\t\tmemset(acc, 0, sizeof(acc));\n \t\t\t\t\t}\n \n-\t\t\t\t\taccel_timestamp = sensor.accelerometer_timestamp[0];\n+\t\t\t\t\taccel_timestamp = sensor.accelerometer_timestamp;\n \t\t\t\t\taccel_updates++;\n \t\t\t\t}\n \n-\t\t\t\tif (sensor.baro_timestamp[0] != baro_timestamp) {\n-\t\t\t\t\tcorr_baro = baro_offset - sensor.baro_alt_meter[0] - z_est[0];\n-\t\t\t\t\tbaro_timestamp = sensor.baro_timestamp[0];\n+\t\t\t\tif (sensor.baro_timestamp != baro_timestamp) {\n+\t\t\t\t\tcorr_baro = baro_offset - sensor.baro_alt_meter - z_est[0];\n+\t\t\t\t\tbaro_timestamp = sensor.baro_timestamp;\n \t\t\t\t\tbaro_updates++;\n \t\t\t\t}\n \t\t\t}\n@@ -1363,7 +1363,7 @@ int position_estimator_inav_thread_main(int argc, char *argv[])\n \t\t\t\t\tglobal_pos.terrain_alt_valid = false;\n \t\t\t\t}\n \n-\t\t\t\tglobal_pos.pressure_alt = sensor.baro_alt_meter[0];\n+\t\t\t\tglobal_pos.pressure_alt = sensor.baro_alt_meter;\n \n \t\t\t\tif (vehicle_global_position_pub == NULL) {\n \t\t\t\t\tvehicle_global_position_pub = orb_advertise(ORB_ID(vehicle_global_position), &global_pos);"},{"sha":"3ad1925c6f4ea496293e51b255d9ba5ba6b70622","filename":"src/modules/sdlog2/sdlog2.c","status":"modified","additions":49,"deletions":71,"changes":120,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fsdlog2%2Fsdlog2.c","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fsdlog2%2Fsdlog2.c","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fsdlog2%2Fsdlog2.c?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -1370,10 +1370,10 @@ int sdlog2_thread_main(int argc, char *argv[])\n \tpthread_cond_init(&logbuffer_cond, NULL);\n \n \t/* track changes in sensor_combined topic */\n-\thrt_abstime gyro_timestamp[3] = {0, 0, 0};\n-\thrt_abstime accelerometer_timestamp[3] = {0, 0, 0};\n-\thrt_abstime magnetometer_timestamp[3] = {0, 0, 0};\n-\thrt_abstime barometer_timestamp[3] = {0, 0, 0};\n+\thrt_abstime gyro_timestamp = 0;\n+\thrt_abstime accelerometer_timestamp = 0;\n+\thrt_abstime magnetometer_timestamp = 0;\n+\thrt_abstime barometer_timestamp = 0;\n \n \t/* initialize calculated mean SNR */\n \tfloat snr_mean = 0.0f;\n@@ -1634,80 +1634,58 @@ int sdlog2_thread_main(int argc, char *argv[])\n \t\t\t// but we need to copy it again because we are re-using the buffer.\n \t\t\torb_copy(ORB_ID(sensor_combined), subs.sensor_sub, &buf.sensor);\n \n-\t\t\tfor (unsigned i = 0; i < 3; i++) {\n-\t\t\t\tbool write_IMU = false;\n-\t\t\t\tbool write_SENS = false;\n+\t\t\tbool write_IMU = false;\n+\t\t\tbool write_SENS = false;\n \n-\t\t\t\tif (buf.sensor.gyro_timestamp[i] != gyro_timestamp[i]) {\n-\t\t\t\t\tgyro_timestamp[i] = buf.sensor.gyro_timestamp[i];\n-\t\t\t\t\twrite_IMU = true;\n-\t\t\t\t}\n-\n-\t\t\t\tif (buf.sensor.accelerometer_timestamp[i] != accelerometer_timestamp[i]) {\n-\t\t\t\t\taccelerometer_timestamp[i] = buf.sensor.accelerometer_timestamp[i];\n-\t\t\t\t\twrite_IMU = true;\n-\t\t\t\t}\n+\t\t\tif (buf.sensor.timestamp != gyro_timestamp) {\n+\t\t\t\tgyro_timestamp = buf.sensor.timestamp;\n+\t\t\t\twrite_IMU = true;\n+\t\t\t}\n \n-\t\t\t\tif (buf.sensor.magnetometer_timestamp[i] != magnetometer_timestamp[i]) {\n-\t\t\t\t\tmagnetometer_timestamp[i] = buf.sensor.magnetometer_timestamp[i];\n-\t\t\t\t\twrite_IMU = true;\n-\t\t\t\t}\n+\t\t\tif (buf.sensor.accelerometer_timestamp != accelerometer_timestamp) {\n+\t\t\t\taccelerometer_timestamp = buf.sensor.accelerometer_timestamp;\n+\t\t\t\twrite_IMU = true;\n+\t\t\t}\n \n-\t\t\t\tif (buf.sensor.baro_timestamp[i] != barometer_timestamp[i]) {\n-\t\t\t\t\tbarometer_timestamp[i] = buf.sensor.baro_timestamp[i];\n-\t\t\t\t\twrite_SENS = true;\n-\t\t\t\t}\n+\t\t\tif (buf.sensor.magnetometer_timestamp != magnetometer_timestamp) {\n+\t\t\t\tmagnetometer_timestamp = buf.sensor.magnetometer_timestamp;\n+\t\t\t\twrite_IMU = true;\n+\t\t\t}\n \n-\t\t\t\tif (write_IMU) {\n-\t\t\t\t\tswitch (i) {\n-\t\t\t\t\t\tcase 0:\n-\t\t\t\t\t\t\tlog_msg.msg_type = LOG_IMU_MSG;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase 1:\n-\t\t\t\t\t\t\tlog_msg.msg_type = LOG_IMU1_MSG;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase 2:\n-\t\t\t\t\t\t\tlog_msg.msg_type = LOG_IMU2_MSG;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n+\t\t\tif (buf.sensor.baro_timestamp != barometer_timestamp) {\n+\t\t\t\tbarometer_timestamp = buf.sensor.baro_timestamp;\n+\t\t\t\twrite_SENS = true;\n+\t\t\t}\n \n-\t\t\t\t\tfloat gyro_dt = buf.sensor.gyro_integral_dt[i] / 1.e6f;\n-\t\t\t\t\tlog_msg.body.log_IMU.gyro_x = buf.sensor.gyro_integral_rad[i * 3 + 0] / gyro_dt;\n-\t\t\t\t\tlog_msg.body.log_IMU.gyro_y = buf.sensor.gyro_integral_rad[i * 3 + 1] / gyro_dt;\n-\t\t\t\t\tlog_msg.body.log_IMU.gyro_z = buf.sensor.gyro_integral_rad[i * 3 + 2] / gyro_dt;\n-\t\t\t\t\tfloat accel_dt = buf.sensor.accelerometer_integral_dt[i] / 1.e6f;\n-\t\t\t\t\tlog_msg.body.log_IMU.acc_x = buf.sensor.accelerometer_integral_m_s[i * 3 + 0] / accel_dt;\n-\t\t\t\t\tlog_msg.body.log_IMU.acc_y = buf.sensor.accelerometer_integral_m_s[i * 3 + 1] / accel_dt;\n-\t\t\t\t\tlog_msg.body.log_IMU.acc_z = buf.sensor.accelerometer_integral_m_s[i * 3 + 2] / accel_dt;\n-\t\t\t\t\tlog_msg.body.log_IMU.mag_x = buf.sensor.magnetometer_ga[i * 3 + 0];\n-\t\t\t\t\tlog_msg.body.log_IMU.mag_y = buf.sensor.magnetometer_ga[i * 3 + 1];\n-\t\t\t\t\tlog_msg.body.log_IMU.mag_z = buf.sensor.magnetometer_ga[i * 3 + 2];\n-\t\t\t\t\tlog_msg.body.log_IMU.temp_gyro = 0;\n-\t\t\t\t\tlog_msg.body.log_IMU.temp_acc = 0;\n-\t\t\t\t\tlog_msg.body.log_IMU.temp_mag = 0;\n-\t\t\t\t\tLOGBUFFER_WRITE_AND_COUNT(IMU);\n-\t\t\t\t}\n+\t\t\tif (write_IMU) {\n+\t\t\t\tlog_msg.msg_type = LOG_IMU_MSG;\n+\n+\t\t\t\tfloat gyro_dt = buf.sensor.gyro_integral_dt / 1.e6f;\n+\t\t\t\tlog_msg.body.log_IMU.gyro_x = buf.sensor.gyro_integral_rad[0] / gyro_dt;\n+\t\t\t\tlog_msg.body.log_IMU.gyro_y = buf.sensor.gyro_integral_rad[1] / gyro_dt;\n+\t\t\t\tlog_msg.body.log_IMU.gyro_z = buf.sensor.gyro_integral_rad[2] / gyro_dt;\n+\t\t\t\tfloat accel_dt = buf.sensor.accelerometer_integral_dt / 1.e6f;\n+\t\t\t\tlog_msg.body.log_IMU.acc_x = buf.sensor.accelerometer_integral_m_s[0] / accel_dt;\n+\t\t\t\tlog_msg.body.log_IMU.acc_y = buf.sensor.accelerometer_integral_m_s[1] / accel_dt;\n+\t\t\t\tlog_msg.body.log_IMU.acc_z = buf.sensor.accelerometer_integral_m_s[2] / accel_dt;\n+\t\t\t\tlog_msg.body.log_IMU.mag_x = buf.sensor.magnetometer_ga[0];\n+\t\t\t\tlog_msg.body.log_IMU.mag_y = buf.sensor.magnetometer_ga[1];\n+\t\t\t\tlog_msg.body.log_IMU.mag_z = buf.sensor.magnetometer_ga[2];\n+\t\t\t\tlog_msg.body.log_IMU.temp_gyro = 0;\n+\t\t\t\tlog_msg.body.log_IMU.temp_acc = 0;\n+\t\t\t\tlog_msg.body.log_IMU.temp_mag = 0;\n+\t\t\t\tLOGBUFFER_WRITE_AND_COUNT(IMU);\n+\t\t\t}\n \n-\t\t\t\tif (write_SENS) {\n-\t\t\t\t\tswitch (i) {\n-\t\t\t\t\t\tcase 0:\n-\t\t\t\t\t\t\tlog_msg.msg_type = LOG_SENS_MSG;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase 1:\n-\t\t\t\t\t\t\tlog_msg.msg_type = LOG_AIR1_MSG;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tcase 2:\n-\t\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n+\t\t\tif (write_SENS) {\n+\t\t\t\tlog_msg.msg_type = LOG_SENS_MSG;\n \n-\t\t\t\t\tlog_msg.body.log_SENS.baro_pres = 0;\n-\t\t\t\t\tlog_msg.body.log_SENS.baro_alt = buf.sensor.baro_alt_meter[i];\n-\t\t\t\t\tlog_msg.body.log_SENS.baro_temp = buf.sensor.baro_temp_celcius[i];\n-\t\t\t\t\tlog_msg.body.log_SENS.diff_pres = 0;\n-\t\t\t\t\tlog_msg.body.log_SENS.diff_pres_filtered = 0;\n-\t\t\t\t\tLOGBUFFER_WRITE_AND_COUNT(SENS);\n-\t\t\t\t}\n+\t\t\t\tlog_msg.body.log_SENS.baro_pres = 0;\n+\t\t\t\tlog_msg.body.log_SENS.baro_alt = buf.sensor.baro_alt_meter;\n+\t\t\t\tlog_msg.body.log_SENS.baro_temp = buf.sensor.baro_temp_celcius;\n+\t\t\t\tlog_msg.body.log_SENS.diff_pres = 0;\n+\t\t\t\tlog_msg.body.log_SENS.diff_pres_filtered = 0;\n+\t\t\t\tLOGBUFFER_WRITE_AND_COUNT(SENS);\n \t\t\t}\n \n \t\t\t/* --- VTOL VEHICLE STATUS --- */"},{"sha":"658998d879100cc7292f68155dd71fcf861db20a","filename":"src/modules/sensors/sensors.cpp","status":"modified","additions":369,"deletions":207,"changes":576,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fsensors%2Fsensors.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/d846ad5dacfa4ab89fd611116d0ea8d21b9bc181/src%2Fmodules%2Fsensors%2Fsensors.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fsensors%2Fsensors.cpp?ref=d846ad5dacfa4ab89fd611116d0ea8d21b9bc181","patch":"@@ -76,6 +76,7 @@\n #include <drivers/drv_px4flow.h>\n \n #include <systemlib/airspeed.h>\n+#include <systemlib/mavlink_log.h>\n #include <systemlib/systemlib.h>\n #include <systemlib/param/param.h>\n #include <systemlib/err.h>\n@@ -85,6 +86,7 @@\n #include <conversion/rotation.h>\n \n #include <lib/ecl/validation/data_validator.h>\n+#include <lib/ecl/validation/data_validator_group.h>\n \n #include <uORB/uORB.h>\n #include <uORB/topics/sensor_combined.h>\n@@ -164,6 +166,9 @@ class Sensors\n \t */\n \tint\t\tstart();\n \n+\n+\tvoid\tprint_status();\n+\n private:\n \tstatic const unsigned _rc_max_chan_count =\n \t\tinput_rc_s::RC_INPUT_MAX_CHANNELS;\t/**< maximum number of r/c channels we handle */\n@@ -200,19 +205,33 @@ class Sensors\n \tint \t\t_sensors_task;\t\t\t/**< task handle for sensor task */\n \n \tbool\t\t_hil_enabled;\t\t\t/**< if true, HIL is active */\n-\tbool\t\t_publishing;\t\t\t/**< if true, we are publishing sensor data */\n+\tbool\t\t_publishing;\t\t\t/**< if true, we are publishing sensor data (in HIL mode, we don't) */\n \tbool\t\t_armed;\t\t\t\t/**< arming status of the vehicle */\n \n-\tint\t\t_gyro_sub[SENSOR_COUNT_MAX];\t/**< raw gyro data subscription */\n-\tint\t\t_accel_sub[SENSOR_COUNT_MAX];\t/**< raw accel data subscription */\n-\tint\t\t_mag_sub[SENSOR_COUNT_MAX];\t/**< raw mag data subscription */\n-\tint\t\t_baro_sub[SENSOR_COUNT_MAX];\t/**< raw baro data subscription */\n-\tint\t\t_actuator_ctrl_0_sub;\t\t/**< attitude controls sub */\n-\tunsigned\t_gyro_count;\t\t\t/**< raw gyro data count */\n-\tunsigned\t_accel_count;\t\t\t/**< raw accel data count */\n-\tunsigned\t_mag_count;\t\t\t/**< raw mag data count */\n-\tunsigned\t_baro_count;\t\t\t/**< raw baro data count */\n+\tstruct SensorData {\n+\t\tSensorData()\n+\t\t\t: subscription_count(0),\n+\t\t\t  voter(SENSOR_COUNT_MAX),\n+\t\t\t  last_failover_count(0)\n+\t\t{\n+\t\t\tfor (unsigned i = 0; i < SENSOR_COUNT_MAX; i++) {\n+\t\t\t\tsubscription[i] = -1;\n+\t\t\t}\n+\t\t}\n+\n+\t\tint subscription[SENSOR_COUNT_MAX]; /**< raw sensor data subscription */\n+\t\tuint8_t priority[SENSOR_COUNT_MAX]; /**< sensor priority */\n+\t\tint subscription_count;\n+\t\tDataValidatorGroup voter;\n+\t\tunsigned int last_failover_count;\n+\t};\n+\n+\tSensorData _gyro;\n+\tSensorData _accel;\n+\tSensorData _mag;\n+\tSensorData _baro;\n \n+\tint\t\t_actuator_ctrl_0_sub;\t\t/**< attitude controls sub */\n \tint \t\t_rc_sub;\t\t\t/**< raw rc channels data subscription */\n \tint\t\t_diff_pres_sub;\t\t\t/**< raw differential pressure subscription */\n \tint\t\t_vcontrol_mode_sub;\t\t/**< vehicle control mode subscription */\n@@ -227,14 +246,14 @@ class Sensors\n \torb_advert_t\t_battery_pub;\t\t\t/**< battery status */\n \torb_advert_t\t_airspeed_pub;\t\t\t/**< airspeed */\n \torb_advert_t\t_diff_pres_pub;\t\t\t/**< differential_pressure */\n+\torb_advert_t\t_mavlink_log_pub;\n \n \tperf_counter_t\t_loop_perf;\t\t\t/**< loop performance counter */\n \n \tDataValidator\t_airspeed_validator;\t\t/**< data validator to monitor airspeed */\n \n \tstruct rc_channels_s _rc;\t\t\t/**< r/c channel data */\n \tstruct battery_status_s _battery_status;\t/**< battery status */\n-\tstruct baro_report _barometer;\t\t\t/**< barometer data */\n \tstruct differential_pressure_s _diff_pres;\n \tstruct airspeed_s _airspeed;\n \tstruct rc_parameter_map_s _rc_parameter_map;\n@@ -245,9 +264,12 @@ class Sensors\n \n \tBattery\t\t_battery;\t\t\t/**< Helper lib to publish battery_status topic. */\n \n-\tfloat\t\t_latest_baro_pressure[SENSOR_COUNT_MAX];\n-\thrt_abstime\t_last_accel_timestamp[SENSOR_COUNT_MAX];\n-\thrt_abstime\t_last_gyro_timestamp[SENSOR_COUNT_MAX];\n+\tfloat _last_baro_pressure[SENSOR_COUNT_MAX]; /**< pressure from last baro sensors */\n+\tfloat _last_best_baro_pressure; /**< pressure from last best baro */\n+\tsensor_combined_s _last_sensor_data[SENSOR_COUNT_MAX]; /**< latest sensor data from all sensors instances */\n+\n+\thrt_abstime _vibration_warning_timestamp;\n+\tbool _vibration_warning;\n \n \tstruct {\n \t\tfloat min[_rc_max_chan_count];\n@@ -320,6 +342,8 @@ class Sensors\n \n \t\tfloat baro_qnh;\n \n+\t\tfloat vibration_warning_threshold;\n+\n \t}\t\t_parameters;\t\t\t/**< local copies of interesting parameters */\n \n \tstruct {\n@@ -387,10 +411,12 @@ class Sensors\n \n \t\tparam_t baro_qnh;\n \n+\t\tparam_t vibe_thresh; /**< vibration threshold */\n+\n \t}\t\t_parameter_handles;\t\t/**< handles for interesting parameters */\n \n \n-\tint\t\tinit_sensor_class(const struct orb_metadata *meta, int *subs);\n+\tvoid\tinit_sensor_class(const struct orb_metadata *meta, SensorData &sensor_data);\n \n \t/**\n \t * Update our local parameter cache.\n@@ -495,6 +521,18 @@ class Sensors\n \t */\n \tvoid\t\tadc_poll(struct sensor_combined_s &raw);\n \n+\t/**\n+\t * Check & handle failover of a sensor\n+\t * @return true if a switch occured (could be for a non-critical reason)\n+\t */\n+\tbool check_failover(SensorData &sensor, const char *sensor_name);\n+\n+\t/**\n+\t * check vibration levels and output a warning if they're high\n+\t * @return true on high vibration\n+\t */\n+\tbool check_vibration();\n+\n \t/**\n \t * Shim for calling task_main from task_create.\n \t */\n@@ -521,10 +559,6 @@ Sensors::Sensors() :\n \t_hil_enabled(false),\n \t_publishing(true),\n \t_armed(false),\n-\t_gyro_count(0),\n-\t_accel_count(0),\n-\t_mag_count(0),\n-\t_baro_count(0),\n \t_rc_sub(-1),\n \t_vcontrol_mode_sub(-1),\n \t_params_sub(-1),\n@@ -539,30 +573,28 @@ Sensors::Sensors() :\n \t_battery_pub(nullptr),\n \t_airspeed_pub(nullptr),\n \t_diff_pres_pub(nullptr),\n+\t_mavlink_log_pub(nullptr),\n \n \t/* performance counters */\n \t_loop_perf(perf_alloc(PC_ELAPSED, \"sensors\")),\n \t_airspeed_validator(),\n \n \t_param_rc_values{},\n \t_board_rotation{},\n-\t_mag_rotation{}\n+\t_mag_rotation{},\n+\n+\t_last_best_baro_pressure(0.f),\n+\n+\t_vibration_warning_timestamp(0),\n+\t_vibration_warning(false)\n {\n-\t/* initialize subscriptions */\n-\tfor (unsigned i = 0; i < SENSOR_COUNT_MAX; i++) {\n-\t\t_gyro_sub[i] = -1;\n-\t\t_accel_sub[i] = -1;\n-\t\t_mag_sub[i] = -1;\n-\t\t_baro_sub[i] = -1;\n-\t}\n+\t_mag.voter.set_timeout(200000);\n \n \tmemset(&_rc, 0, sizeof(_rc));\n \tmemset(&_diff_pres, 0, sizeof(_diff_pres));\n \tmemset(&_parameters, 0, sizeof(_parameters));\n \tmemset(&_rc_parameter_map, 0, sizeof(_rc_parameter_map));\n-\tmemset(&_latest_baro_pressure, 0, sizeof(_latest_baro_pressure));\n-\tmemset(&_last_accel_timestamp, 0, sizeof(_last_accel_timestamp));\n-\tmemset(&_last_gyro_timestamp, 0, sizeof(_last_gyro_timestamp));\n+\tmemset(&_last_sensor_data, 0, sizeof(_last_sensor_data));\n \n \t/* basic r/c parameters */\n \tfor (unsigned i = 0; i < _rc_max_chan_count; i++) {\n@@ -661,6 +693,8 @@ Sensors::Sensors() :\n \t/* Barometer QNH */\n \t_parameter_handles.baro_qnh = param_find(\"SENS_BARO_QNH\");\n \n+\t_parameter_handles.vibe_thresh = param_find(\"ATT_VIBE_THRESH\");\n+\n \t// These are parameters for which QGroundControl always expects to be returned in a list request.\n \t// We do a param_find here to force them into the list.\n \t(void)param_find(\"RC_CHAN_CNT\");\n@@ -993,6 +1027,8 @@ Sensors::parameters_update()\n \n #endif\n \n+\tparam_get(_parameter_handles.vibe_thresh, &_parameters.vibration_warning_threshold);\n+\n \treturn ret;\n }\n \n@@ -1014,136 +1050,234 @@ Sensors::adc_init()\n void\n Sensors::accel_poll(struct sensor_combined_s &raw)\n {\n-\tfor (unsigned i = 0; i < _accel_count; i++) {\n+\tbool got_update = false;\n+\n+\tfor (unsigned i = 0; i < _accel.subscription_count; i++) {\n \t\tbool accel_updated;\n-\t\torb_check(_accel_sub[i], &accel_updated);\n+\t\torb_check(_accel.subscription[i], &accel_updated);\n \n \t\tif (accel_updated) {\n-\t\t\tstruct accel_report\taccel_report;\n+\t\t\tstruct accel_report accel_report;\n+\n+\t\t\torb_copy(ORB_ID(sensor_accel), _accel.subscription[i], &accel_report);\n \n-\t\t\torb_copy(ORB_ID(sensor_accel), _accel_sub[i], &accel_report);\n+\t\t\tif (accel_report.timestamp == 0) {\n+\t\t\t\tcontinue; //ignore invalid data\n+\t\t\t}\n+\n+\t\t\tgot_update = true;\n+\t\t\tmath::Vector<3> sensor_value;\n \n \t\t\tif (accel_report.integral_dt != 0) {\n \t\t\t\tmath::Vector<3> vect_int(accel_report.x_integral, accel_report.y_integral, accel_report.z_integral);\n \t\t\t\tvect_int = _board_rotation * vect_int;\n \n-\t\t\t\traw.accelerometer_integral_m_s[i * 3 + 0] = vect_int(0);\n-\t\t\t\traw.accelerometer_integral_m_s[i * 3 + 1] = vect_int(1);\n-\t\t\t\traw.accelerometer_integral_m_s[i * 3 + 2] = vect_int(2);\n+\t\t\t\t_last_sensor_data[i].accelerometer_integral_m_s[0] = vect_int(0);\n+\t\t\t\t_last_sensor_data[i].accelerometer_integral_m_s[1] = vect_int(1);\n+\t\t\t\t_last_sensor_data[i].accelerometer_integral_m_s[2] = vect_int(2);\n+\n+\t\t\t\t_last_sensor_data[i].accelerometer_integral_dt = accel_report.integral_dt;\n \n-\t\t\t\traw.accelerometer_integral_dt[i] = accel_report.integral_dt;\n+\t\t\t\tfloat dt = accel_report.integral_dt / 1.e6f;\n+\t\t\t\tsensor_value = vect_int / dt;\n \n \t\t\t} else {\n \t\t\t\t//this is undesirable: a driver did not set the integral, so we have to construct it ourselves\n \t\t\t\tmath::Vector<3> vect_val(accel_report.x, accel_report.y, accel_report.z);\n \t\t\t\tvect_val = _board_rotation * vect_val;\n \n-\t\t\t\tif (_last_accel_timestamp[i] == 0) {\n-\t\t\t\t\t_last_accel_timestamp[i] = accel_report.timestamp - 1000;\n+\t\t\t\tsensor_value = vect_val;\n+\n+\t\t\t\tif (_last_sensor_data[i].accelerometer_timestamp == 0) {\n+\t\t\t\t\t_last_sensor_data[i].accelerometer_timestamp = accel_report.timestamp - 1000;\n \t\t\t\t}\n \n-\t\t\t\traw.accelerometer_integral_dt[i] = accel_report.timestamp - _last_accel_timestamp[i];\n-\t\t\t\t_last_accel_timestamp[i] = accel_report.timestamp;\n-\t\t\t\tfloat dt = raw.accelerometer_integral_dt[i] / 1.e6f;\n-\t\t\t\traw.accelerometer_integral_m_s[i * 3 + 0] = vect_val(0) * dt;\n-\t\t\t\traw.accelerometer_integral_m_s[i * 3 + 1] = vect_val(1) * dt;\n-\t\t\t\traw.accelerometer_integral_m_s[i * 3 + 2] = vect_val(2) * dt;\n+\t\t\t\t_last_sensor_data[i].accelerometer_integral_dt =\n+\t\t\t\t\taccel_report.timestamp - _last_sensor_data[i].accelerometer_timestamp;\n+\t\t\t\tfloat dt = _last_sensor_data[i].accelerometer_integral_dt / 1.e6f;\n+\t\t\t\t_last_sensor_data[i].accelerometer_integral_m_s[0] = vect_val(0) * dt;\n+\t\t\t\t_last_sensor_data[i].accelerometer_integral_m_s[1] = vect_val(1) * dt;\n+\t\t\t\t_last_sensor_data[i].accelerometer_integral_m_s[2] = vect_val(2) * dt;\n \t\t\t}\n \n-\t\t\traw.accelerometer_timestamp[i] = accel_report.timestamp;\n+\t\t\t_last_sensor_data[i].accelerometer_timestamp = accel_report.timestamp;\n+\t\t\t_accel.voter.put(i, accel_report.timestamp, sensor_value.data,\n+\t\t\t\t\t accel_report.error_count, _accel.priority[i]);\n+\t\t}\n+\t}\n+\n+\tif (got_update) {\n+\t\tint best_index;\n+\t\t_accel.voter.get_best(hrt_absolute_time(), &best_index);\n+\n+\t\tif (best_index >= 0) {\n+\t\t\traw.accelerometer_integral_m_s[0] = _last_sensor_data[best_index].accelerometer_integral_m_s[0];\n+\t\t\traw.accelerometer_integral_m_s[1] = _last_sensor_data[best_index].accelerometer_integral_m_s[1];\n+\t\t\traw.accelerometer_integral_m_s[2] = _last_sensor_data[best_index].accelerometer_integral_m_s[2];\n+\t\t\traw.accelerometer_integral_dt = _last_sensor_data[best_index].accelerometer_integral_dt;\n+\t\t\traw.accelerometer_timestamp = _last_sensor_data[best_index].accelerometer_timestamp;\n \t\t}\n \t}\n }\n \n void\n Sensors::gyro_poll(struct sensor_combined_s &raw)\n {\n-\tfor (unsigned i = 0; i < _gyro_count; i++) {\n+\tbool got_update = false;\n+\n+\tfor (unsigned i = 0; i < _gyro.subscription_count; i++) {\n \t\tbool gyro_updated;\n-\t\torb_check(_gyro_sub[i], &gyro_updated);\n+\t\torb_check(_gyro.subscription[i], &gyro_updated);\n \n \t\tif (gyro_updated) {\n-\t\t\tstruct gyro_report\tgyro_report;\n+\t\t\tstruct gyro_report gyro_report;\n+\n+\t\t\torb_copy(ORB_ID(sensor_gyro), _gyro.subscription[i], &gyro_report);\n \n-\t\t\torb_copy(ORB_ID(sensor_gyro), _gyro_sub[i], &gyro_report);\n+\t\t\tif (gyro_report.timestamp == 0) {\n+\t\t\t\tcontinue; //ignore invalid data\n+\t\t\t}\n+\n+\t\t\tgot_update = true;\n+\t\t\tmath::Vector<3> sensor_value;\n \n \t\t\tif (gyro_report.integral_dt != 0) {\n \t\t\t\tmath::Vector<3> vect_int(gyro_report.x_integral, gyro_report.y_integral, gyro_report.z_integral);\n \t\t\t\tvect_int = _board_rotation * vect_int;\n \n-\t\t\t\traw.gyro_integral_rad[i * 3 + 0] = vect_int(0);\n-\t\t\t\traw.gyro_integral_rad[i * 3 + 1] = vect_int(1);\n-\t\t\t\traw.gyro_integral_rad[i * 3 + 2] = vect_int(2);\n+\t\t\t\t_last_sensor_data[i].gyro_integral_rad[0] = vect_int(0);\n+\t\t\t\t_last_sensor_data[i].gyro_integral_rad[1] = vect_int(1);\n+\t\t\t\t_last_sensor_data[i].gyro_integral_rad[2] = vect_int(2);\n+\n+\t\t\t\t_last_sensor_data[i].gyro_integral_dt = gyro_report.integral_dt;\n \n-\t\t\t\traw.gyro_integral_dt[i] = gyro_report.integral_dt;\n-\t\t\t\traw.gyro_timestamp[i] = gyro_report.timestamp;\n+\t\t\t\tfloat dt = gyro_report.integral_dt / 1.e6f;\n+\t\t\t\tsensor_value = vect_int / dt;\n \n \t\t\t} else {\n \t\t\t\t//this is undesirable: a driver did not set the integral, so we have to construct it ourselves\n \t\t\t\tmath::Vector<3> vect_val(gyro_report.x, gyro_report.y, gyro_report.z);\n \t\t\t\tvect_val = _board_rotation * vect_val;\n \n-\t\t\t\tif (_last_gyro_timestamp[i] == 0) {\n-\t\t\t\t\t_last_gyro_timestamp[i] = gyro_report.timestamp - 1000;\n-\t\t\t\t}\n+\t\t\t\tsensor_value = vect_val;\n \n-\t\t\t\traw.gyro_integral_dt[i] = gyro_report.timestamp - _last_gyro_timestamp[i];\n-\t\t\t\t_last_gyro_timestamp[i] = gyro_report.timestamp;\n-\t\t\t\tfloat dt = raw.gyro_integral_dt[i] / 1.e6f;\n-\t\t\t\traw.gyro_integral_rad[i * 3 + 0] = vect_val(0) * dt;\n-\t\t\t\traw.gyro_integral_rad[i * 3 + 1] = vect_val(1) * dt;\n-\t\t\t\traw.gyro_integral_rad[i * 3 + 2] = vect_val(2) * dt;\n+\t\t\t\tif (_last_sensor_data[i].timestamp == 0) {\n+\t\t\t\t\t_last_sensor_data[i].timestamp = gyro_report.timestamp - 1000;\n+\t\t\t\t}\n \n+\t\t\t\t_last_sensor_data[i].gyro_integral_dt =\n+\t\t\t\t\tgyro_report.timestamp - _last_sensor_data[i].timestamp;\n+\t\t\t\tfloat dt = _last_sensor_data[i].gyro_integral_dt / 1.e6f;\n+\t\t\t\t_last_sensor_data[i].gyro_integral_rad[0] = vect_val(0) * dt;\n+\t\t\t\t_last_sensor_data[i].gyro_integral_rad[1] = vect_val(1) * dt;\n+\t\t\t\t_last_sensor_data[i].gyro_integral_rad[2] = vect_val(2) * dt;\n \t\t\t}\n \n-\t\t\tif (i == 0) {\n-\t\t\t\traw.timestamp = gyro_report.timestamp;\n-\t\t\t}\n+\t\t\t_last_sensor_data[i].timestamp = gyro_report.timestamp;\n+\t\t\t_gyro.voter.put(i, gyro_report.timestamp, sensor_value.data,\n+\t\t\t\t\tgyro_report.error_count, _gyro.priority[i]);\n+\t\t}\n+\t}\n+\n+\tif (got_update) {\n+\t\tint best_index;\n+\t\t_gyro.voter.get_best(hrt_absolute_time(), &best_index);\n+\n+\t\tif (best_index >= 0) {\n+\t\t\traw.gyro_integral_rad[0] = _last_sensor_data[best_index].gyro_integral_rad[0];\n+\t\t\traw.gyro_integral_rad[1] = _last_sensor_data[best_index].gyro_integral_rad[1];\n+\t\t\traw.gyro_integral_rad[2] = _last_sensor_data[best_index].gyro_integral_rad[2];\n+\t\t\traw.gyro_integral_dt = _last_sensor_data[best_index].gyro_integral_dt;\n+\t\t\traw.timestamp = _last_sensor_data[best_index].timestamp;\n \t\t}\n \t}\n }\n \n void\n Sensors::mag_poll(struct sensor_combined_s &raw)\n {\n-\tfor (unsigned i = 0; i < _mag_count; i++) {\n+\tbool got_update = false;\n+\n+\tfor (unsigned i = 0; i < _mag.subscription_count; i++) {\n \t\tbool mag_updated;\n-\t\torb_check(_mag_sub[i], &mag_updated);\n+\t\torb_check(_mag.subscription[i], &mag_updated);\n \n \t\tif (mag_updated) {\n-\t\t\tstruct mag_report\tmag_report;\n+\t\t\tstruct mag_report mag_report;\n \n-\t\t\torb_copy(ORB_ID(sensor_mag), _mag_sub[i], &mag_report);\n+\t\t\torb_copy(ORB_ID(sensor_mag), _mag.subscription[i], &mag_report);\n \n-\t\t\tmath::Vector<3> vect(mag_report.x, mag_report.y, mag_report.z);\n+\t\t\tif (mag_report.timestamp == 0) {\n+\t\t\t\tcontinue; //ignore invalid data\n+\t\t\t}\n \n+\t\t\tgot_update = true;\n+\t\t\tmath::Vector<3> vect(mag_report.x, mag_report.y, mag_report.z);\n \t\t\tvect = _mag_rotation[i] * vect;\n \n-\t\t\traw.magnetometer_ga[i * 3 + 0] = vect(0);\n-\t\t\traw.magnetometer_ga[i * 3 + 1] = vect(1);\n-\t\t\traw.magnetometer_ga[i * 3 + 2] = vect(2);\n+\t\t\t_last_sensor_data[i].magnetometer_ga[0] = vect(0);\n+\t\t\t_last_sensor_data[i].magnetometer_ga[1] = vect(1);\n+\t\t\t_last_sensor_data[i].magnetometer_ga[2] = vect(2);\n+\n+\t\t\t_last_sensor_data[i].magnetometer_timestamp = mag_report.timestamp;\n+\t\t\t_mag.voter.put(i, mag_report.timestamp, vect.data,\n+\t\t\t\t       mag_report.error_count, _mag.priority[i]);\n+\t\t}\n+\t}\n+\n+\tif (got_update) {\n+\t\tint best_index;\n+\t\t_mag.voter.get_best(hrt_absolute_time(), &best_index);\n \n-\t\t\traw.magnetometer_timestamp[i] = mag_report.timestamp;\n+\t\tif (best_index >= 0) {\n+\t\t\traw.magnetometer_ga[0] = _last_sensor_data[best_index].magnetometer_ga[0];\n+\t\t\traw.magnetometer_ga[1] = _last_sensor_data[best_index].magnetometer_ga[1];\n+\t\t\traw.magnetometer_ga[2] = _last_sensor_data[best_index].magnetometer_ga[2];\n+\t\t\traw.magnetometer_timestamp = _last_sensor_data[best_index].magnetometer_timestamp;\n \t\t}\n \t}\n }\n \n void\n Sensors::baro_poll(struct sensor_combined_s &raw)\n {\n-\tfor (unsigned i = 0; i < _baro_count; i++) {\n+\tbool got_update = false;\n+\n+\tfor (unsigned i = 0; i < _baro.subscription_count; i++) {\n \t\tbool baro_updated;\n-\t\torb_check(_baro_sub[i], &baro_updated);\n+\t\torb_check(_baro.subscription[i], &baro_updated);\n \n \t\tif (baro_updated) {\n+\t\t\tstruct baro_report baro_report;\n+\n+\t\t\torb_copy(ORB_ID(sensor_baro), _baro.subscription[i], &baro_report);\n \n-\t\t\torb_copy(ORB_ID(sensor_baro), _baro_sub[i], &_barometer);\n+\t\t\tif (baro_report.timestamp == 0) {\n+\t\t\t\tcontinue; //ignore invalid data\n+\t\t\t}\n+\n+\t\t\tgot_update = true;\n+\t\t\tmath::Vector<3> vect(baro_report.altitude, 0.f, 0.f);\n \n-\t\t\t_latest_baro_pressure[i] = _barometer.pressure;\n-\t\t\traw.baro_alt_meter[i] = _barometer.altitude; // Altitude in meters\n-\t\t\traw.baro_temp_celcius[i] = _barometer.temperature; // Temperature in degrees celcius\n+\t\t\t_last_sensor_data[i].baro_alt_meter = baro_report.altitude;\n+\t\t\t_last_sensor_data[i].baro_temp_celcius = baro_report.temperature;\n+\t\t\t_last_baro_pressure[i] = baro_report.pressure;\n \n-\t\t\traw.baro_timestamp[i] = _barometer.timestamp;\n+\t\t\t_last_sensor_data[i].baro_timestamp = baro_report.timestamp;\n+\t\t\t_baro.voter.put(i, baro_report.timestamp, vect.data,\n+\t\t\t\t\tbaro_report.error_count, _baro.priority[i]);\n+\t\t}\n+\t}\n+\n+\tif (got_update) {\n+\t\tint best_index;\n+\t\t_baro.voter.get_best(hrt_absolute_time(), &best_index);\n+\n+\t\tif (best_index >= 0) {\n+\t\t\traw.baro_alt_meter = _last_sensor_data[best_index].baro_alt_meter;\n+\t\t\traw.baro_temp_celcius = _last_sensor_data[best_index].baro_temp_celcius;\n+\t\t\traw.baro_timestamp = _last_sensor_data[best_index].baro_timestamp;\n+\t\t\t_last_best_baro_pressure = _last_baro_pressure[best_index];\n \t\t}\n \t}\n }\n@@ -1158,7 +1292,7 @@ Sensors::diff_pres_poll(struct sensor_combined_s &raw)\n \t\torb_copy(ORB_ID(differential_pressure), _diff_pres_sub, &_diff_pres);\n \n \t\tfloat air_temperature_celsius = (_diff_pres.temperature > -300.0f) ? _diff_pres.temperature :\n-\t\t\t\t\t\t(raw.baro_temp_celcius[0] - PCB_TEMP_ESTIMATE_DEG);\n+\t\t\t\t\t\t(raw.baro_temp_celcius - PCB_TEMP_ESTIMATE_DEG);\n \n \t\t_airspeed.timestamp = _diff_pres.timestamp;\n \n@@ -1175,13 +1309,12 @@ Sensors::diff_pres_poll(struct sensor_combined_s &raw)\n \t\t_airspeed.indicated_airspeed_m_s = math::max(0.0f,\n \t\t\t\t\t\t   calc_indicated_airspeed(_diff_pres.differential_pressure_filtered_pa));\n \n-\t\t//FIXME: we just use the baro pressure from the first baro. we should do voting instead.\n \t\t_airspeed.true_airspeed_m_s = math::max(0.0f,\n-\t\t\t\t\t\t\tcalc_true_airspeed(_diff_pres.differential_pressure_filtered_pa + _latest_baro_pressure[0] * 1e2f,\n-\t\t\t\t\t\t\t\t\t_latest_baro_pressure[0] * 1e2f, air_temperature_celsius));\n+\t\t\t\t\t\t\tcalc_true_airspeed(_diff_pres.differential_pressure_filtered_pa + _last_best_baro_pressure * 1e2f,\n+\t\t\t\t\t\t\t\t\t_last_best_baro_pressure * 1e2f, air_temperature_celsius));\n \t\t_airspeed.true_airspeed_unfiltered_m_s = math::max(0.0f,\n-\t\t\t\tcalc_true_airspeed(_diff_pres.differential_pressure_raw_pa + _latest_baro_pressure[0] * 1e2f,\n-\t\t\t\t\t\t   _latest_baro_pressure[0] * 1e2f, air_temperature_celsius));\n+\t\t\t\tcalc_true_airspeed(_diff_pres.differential_pressure_raw_pa + _last_best_baro_pressure * 1e2f,\n+\t\t\t\t\t\t   _last_best_baro_pressure * 1e2f, air_temperature_celsius));\n \n \t\t_airspeed.air_temperature_celsius = air_temperature_celsius;\n \n@@ -1544,14 +1677,7 @@ Sensors::apply_gyro_calibration(DevHandle &h, const struct gyro_calibration_s *g\n #if !defined(__PX4_QURT) && !defined(__PX4_POSIX_RPI2)\n \n \t/* On most systems, we can just use the IOCTL call to set the calibration params. */\n-\tconst int res = h.ioctl(GYROIOCSSCALE, (long unsigned int)gcal);\n-\n-\tif (res) {\n-\t\treturn false;\n-\n-\t} else {\n-\t\treturn true;\n-\t}\n+\treturn !h.ioctl(GYROIOCSSCALE, (long unsigned int)gcal);\n \n #else\n \t/* On QURT, the params are read directly in the respective wrappers. */\n@@ -1565,14 +1691,7 @@ Sensors::apply_accel_calibration(DevHandle &h, const struct accel_calibration_s\n #if !defined(__PX4_QURT) && !defined(__PX4_POSIX_RPI2)\n \n \t/* On most systems, we can just use the IOCTL call to set the calibration params. */\n-\tconst int res = h.ioctl(ACCELIOCSSCALE, (long unsigned int)acal);\n-\n-\tif (res) {\n-\t\treturn false;\n-\n-\t} else {\n-\t\treturn true;\n-\t}\n+\treturn !h.ioctl(ACCELIOCSSCALE, (long unsigned int)acal);\n \n #else\n \t/* On QURT, the params are read directly in the respective wrappers. */\n@@ -1586,14 +1705,7 @@ Sensors::apply_mag_calibration(DevHandle &h, const struct mag_calibration_s *mca\n #if !defined(__PX4_QURT) && !defined(__PX4_POSIX_RPI2)\n \n \t/* On most systems, we can just use the IOCTL call to set the calibration params. */\n-\tconst int res = h.ioctl(MAGIOCSSCALE, (long unsigned int)mcal);\n-\n-\tif (res) {\n-\t\treturn false;\n-\n-\t} else {\n-\t\treturn true;\n-\t}\n+\treturn !h.ioctl(MAGIOCSSCALE, (long unsigned int)mcal);\n \n #else\n \t/* On QURT, the params are read directly in the respective wrappers. */\n@@ -2045,14 +2157,72 @@ Sensors::rc_poll()\n \t}\n }\n \n+bool\n+Sensors::check_failover(SensorData &sensor, const char *sensor_name)\n+{\n+\tif (sensor.last_failover_count != sensor.voter.failover_count()) {\n+\n+\t\tuint32_t flags = sensor.voter.failover_state();\n+\n+\t\tif (flags == DataValidator::ERROR_FLAG_NO_ERROR) {\n+\t\t\t//we switched due to a non-critical reason. No need to panic.\n+\t\t\tPX4_INFO(\"%s sensor switch from #%i\", sensor_name, sensor.voter.failover_index());\n+\n+\t\t} else {\n+\t\t\tmavlink_and_console_log_emergency(&_mavlink_log_pub, \"%s #%i failure :%s%s%s%s%s!\",\n+\t\t\t\t\t\t\t  sensor_name,\n+\t\t\t\t\t\t\t  sensor.voter.failover_index(),\n+\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_NO_DATA) ? \" No data\" : \"\"),\n+\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_STALE_DATA) ? \" Stale data\" : \"\"),\n+\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_TIMEOUT) ? \" Data timeout\" : \"\"),\n+\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_HIGH_ERRCOUNT) ? \" High error count\" : \"\"),\n+\t\t\t\t\t\t\t  ((flags & DataValidator::ERROR_FLAG_HIGH_ERRDENSITY) ? \" High error density\" : \"\"));\n+\t\t}\n+\n+\t\tsensor.last_failover_count = sensor.voter.failover_count();\n+\t\treturn true;\n+\t}\n+\n+\treturn false;\n+}\n+\n+bool\n+Sensors::check_vibration()\n+{\n+\tbool ret = false;\n+\thrt_abstime cur_time = hrt_absolute_time();\n+\n+\tif (!_vibration_warning && (_gyro.voter.get_vibration_factor(cur_time) > _parameters.vibration_warning_threshold ||\n+\t\t\t\t    _accel.voter.get_vibration_factor(cur_time) > _parameters.vibration_warning_threshold ||\n+\t\t\t\t    _mag.voter.get_vibration_factor(cur_time) > _parameters.vibration_warning_threshold)) {\n+\n+\t\tif (_vibration_warning_timestamp == 0) {\n+\t\t\t_vibration_warning_timestamp = cur_time;\n+\n+\t\t} else if (hrt_elapsed_time(&_vibration_warning_timestamp) > 10000 * 1000) {\n+\t\t\t_vibration_warning = true;\n+\t\t\tmavlink_and_console_log_critical(&_mavlink_log_pub, \"HIGH VIBRATION! g: %d a: %d m: %d\",\n+\t\t\t\t\t\t\t (int)(100 * _gyro.voter.get_vibration_factor(cur_time)),\n+\t\t\t\t\t\t\t (int)(100 * _accel.voter.get_vibration_factor(cur_time)),\n+\t\t\t\t\t\t\t (int)(100 * _mag.voter.get_vibration_factor(cur_time)));\n+\t\t\tret = true;\n+\t\t}\n+\n+\t} else {\n+\t\t_vibration_warning_timestamp = 0;\n+\t}\n+\n+\treturn ret;\n+}\n+\n void\n Sensors::task_main_trampoline(int argc, char *argv[])\n {\n \tsensors::g_sensors->task_main();\n }\n \n-int\n-Sensors::init_sensor_class(const struct orb_metadata *meta, int *subs)\n+void\n+Sensors::init_sensor_class(const struct orb_metadata *meta, SensorData &sensor_data)\n {\n \tunsigned group_count = orb_group_count(meta);\n \n@@ -2061,12 +2231,19 @@ Sensors::init_sensor_class(const struct orb_metadata *meta, int *subs)\n \t}\n \n \tfor (unsigned i = 0; i < group_count; i++) {\n-\t\tif (subs[i] < 0) {\n-\t\t\tsubs[i] = orb_subscribe_multi(meta, i);\n+\t\tif (sensor_data.subscription[i] < 0) {\n+\t\t\tsensor_data.subscription[i] = orb_subscribe_multi(meta, i);\n+\t\t\tint32_t priority;\n+\t\t\torb_priority(sensor_data.subscription[i], &priority);\n+\t\t\tsensor_data.priority[i] = (uint8_t)priority;\n \t\t}\n+\n+\t\tint32_t priority;\n+\t\torb_priority(sensor_data.subscription[i], &priority);\n+\t\tsensor_data.priority[i] = (uint8_t)priority;\n \t}\n \n-\treturn group_count;\n+\tsensor_data.subscription_count = group_count;\n }\n \n void\n@@ -2090,84 +2267,79 @@ Sensors::task_main()\n \n \tstruct sensor_combined_s raw = {};\n \n-\t/* ensure no overflows can occur */\n-\tstatic_assert((sizeof(raw.gyro_timestamp) / sizeof(raw.gyro_timestamp[0])) >= SENSOR_COUNT_MAX,\n-\t\t      \"SENSOR_COUNT_MAX larger than sensor_combined datastructure fields. Overflow would occur\");\n-\n \t/*\n \t * do subscriptions\n \t */\n+\tinit_sensor_class(ORB_ID(sensor_gyro), _gyro);\n \n-\tunsigned gcount_prev = _gyro_count;\n-\n-\tunsigned mcount_prev = _mag_count;\n+\tinit_sensor_class(ORB_ID(sensor_mag), _mag);\n \n-\tunsigned acount_prev = _accel_count;\n+\tinit_sensor_class(ORB_ID(sensor_accel), _accel);\n \n-\tunsigned bcount_prev = _baro_count;\n+\tinit_sensor_class(ORB_ID(sensor_baro), _baro);\n \n-\t_gyro_count = init_sensor_class(ORB_ID(sensor_gyro), _gyro_sub);\n-\n-\t_mag_count = init_sensor_class(ORB_ID(sensor_mag), _mag_sub);\n-\n-\t_accel_count = init_sensor_class(ORB_ID(sensor_accel), _accel_sub);\n-\n-\t_baro_count = init_sensor_class(ORB_ID(sensor_baro), _baro_sub);\n-\n-\tif (gcount_prev != _gyro_count ||\n-\t    mcount_prev != _mag_count ||\n-\t    acount_prev != _accel_count ||\n-\t    bcount_prev != _baro_count) {\n-\n-\t\t/* reload calibration params */\n-\t\tparameter_update_poll(true);\n-\t}\n+\t/* reload calibration params */\n+\tparameter_update_poll(true);\n \n \t_rc_sub = orb_subscribe(ORB_ID(input_rc));\n+\n \t_diff_pres_sub = orb_subscribe(ORB_ID(differential_pressure));\n+\n \t_vcontrol_mode_sub = orb_subscribe(ORB_ID(vehicle_control_mode));\n+\n \t_params_sub = orb_subscribe(ORB_ID(parameter_update));\n+\n \t_rc_parameter_map_sub = orb_subscribe(ORB_ID(rc_parameter_map));\n+\n \t_manual_control_sub = orb_subscribe(ORB_ID(manual_control_setpoint));\n+\n \t_actuator_ctrl_0_sub = orb_subscribe(ORB_ID(actuator_controls_0));\n \n-\t/*\n-\t * do advertisements\n-\t */\n-\traw.timestamp = hrt_absolute_time();\n+\traw.timestamp = 0;\n \n \t_battery.reset(&_battery_status);\n \n \t/* get a set of initial values */\n \taccel_poll(raw);\n+\n \tgyro_poll(raw);\n+\n \tmag_poll(raw);\n+\n \tbaro_poll(raw);\n+\n \tdiff_pres_poll(raw);\n \n \tparameter_update_poll(true /* forced */);\n+\n \trc_parameter_map_poll(true /* forced */);\n \n \t/* advertise the sensor_combined topic and make the initial publication */\n \t_sensor_pub = orb_advertise(ORB_ID(sensor_combined), &raw);\n \n \t/* wakeup source(s) */\n-\tpx4_pollfd_struct_t fds[1] = {};\n+\tpx4_pollfd_struct_t fds[SENSOR_COUNT_MAX] = {};\n \n-\t/* use the gyro to pace output */\n-\tfds[0].fd = _gyro_sub[0];\n-\tfds[0].events = POLLIN;\n+\tint num_poll_fds = 0;\n \n \t_task_should_exit = false;\n \n-\traw.timestamp = 0;\n-\n \tuint64_t _last_config_update = hrt_absolute_time();\n \n \twhile (!_task_should_exit) {\n \n+\t\t/* use the gyro(s) to pace output */\n+\t\tif (num_poll_fds != _gyro.subscription_count) { //happens the first time we enter, or when new gyro added\n+\t\t\tnum_poll_fds = _gyro.subscription_count;\n+\n+\t\t\tfor (int i = 0; i < _gyro.subscription_count; ++i) {\n+\t\t\t\tfds[i].fd = _gyro.subscription[i];\n+\t\t\t\tfds[i].events = POLLIN;\n+\t\t\t}\n+\t\t}\n+\n \t\t/* wait for up to 50ms for data */\n-\t\tint pret = px4_poll(fds, (sizeof(fds) / sizeof(fds[0])), 50);\n+\t\tint pret = px4_poll(fds, num_poll_fds, 50);\n \n \t\t/* if pret == 0 it timed out - periodic check for _task_should_exit, etc. */\n \n@@ -2176,11 +2348,12 @@ Sensors::task_main()\n \t\t\t/* if the polling operation failed because no gyro sensor is available yet,\n \t\t\t * then attempt to subscribe once again\n \t\t\t */\n-\t\t\tif (_gyro_count == 0) {\n-\t\t\t\t_gyro_count = init_sensor_class(ORB_ID(sensor_gyro), _gyro_sub);\n-\t\t\t\tfds[0].fd = _gyro_sub[0];\n+\t\t\tif (_gyro.subscription_count == 0) {\n+\t\t\t\tinit_sensor_class(ORB_ID(sensor_gyro), _gyro);\n \t\t\t}\n \n+\t\t\tusleep(1000);\n+\n \t\t\tcontinue;\n \t\t}\n \n@@ -2189,60 +2362,38 @@ Sensors::task_main()\n \t\t/* check vehicle status for changes to publication state */\n \t\tvehicle_control_mode_poll();\n \n-\t\t/* the timestamp of the raw struct is updated by the gyro_poll() method */\n-\t\t/* copy most recent sensor data */\n+\t\t/* the timestamp of the raw struct is updated by the gyro_poll() method (this makes the gyro\n+\t\t * a mandatory sensor) */\n \t\tgyro_poll(raw);\n \t\taccel_poll(raw);\n \t\tmag_poll(raw);\n \t\tbaro_poll(raw);\n \n-\t\t// FIXME TODO: this needs more thinking, otherwise we spam the console and keep switching.\n-\t\t/* Work out if main gyro timed out and fail over to alternate gyro.\n-\t\t * However, don't do this if the secondary is not available. */\n-\t\tif (hrt_elapsed_time(&raw.gyro_timestamp[0]) > 20 * 1000 && _gyro_sub[1] >= 0) {\n-\t\t\tif (fds[0].fd == _gyro_sub[0]) {\n-\t\t\t\tPX4_WARN(\"gyro0 has timed out\");\n-\t\t\t}\n-\n-\t\t\t/* If the secondary failed as well, go to the tertiary, also only if available. */\n-\t\t\tif (hrt_elapsed_time(&raw.gyro_timestamp[1]) > 20 * 1000 && _gyro_sub[2] >= 0 && (fds[0].fd != _gyro_sub[2])) {\n-\t\t\t\tfds[0].fd = _gyro_sub[2];\n-\n-\t\t\t\tif (!_hil_enabled) {\n-\t\t\t\t\tPX4_WARN(\"failing over to third gyro\");\n-\t\t\t\t}\n-\n-\t\t\t} else if (_gyro_sub[1] >= 0 && (fds[0].fd != _gyro_sub[1])) {\n-\t\t\t\tfds[0].fd = _gyro_sub[1];\n-\n-\t\t\t\tif (!_hil_enabled) {\n-\t\t\t\t\tPX4_WARN(\"failing over to second gyro\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n \n \t\t/* check battery voltage */\n \t\tadc_poll(raw);\n \n \t\tdiff_pres_poll(raw);\n \n-\t\t/* Inform other processes that new data is available to copy */\n \t\tif (_publishing && raw.timestamp > 0) {\n \t\t\torb_publish(ORB_ID(sensor_combined), _sensor_pub, &raw);\n+\n+\t\t\tcheck_failover(_accel, \"Accel\");\n+\t\t\tcheck_failover(_gyro, \"Gyro\");\n+\t\t\tcheck_failover(_mag, \"Mag\");\n+\t\t\tcheck_failover(_baro, \"Baro\");\n+\n+\t\t\t//check_vibration(); //disabled for now, as it does not seem to be reliable\n \t\t}\n \n \t\t/* keep adding sensors as long as we are not armed,\n \t\t * when not adding sensors poll for param updates\n \t\t */\n \t\tif (!_armed && hrt_elapsed_time(&_last_config_update) > 500 * 1000) {\n-\t\t\t_gyro_count = init_sensor_class(ORB_ID(sensor_gyro), _gyro_sub);\n-\n-\t\t\t_mag_count = init_sensor_class(ORB_ID(sensor_mag), _mag_sub);\n-\n-\t\t\t_accel_count = init_sensor_class(ORB_ID(sensor_accel), _accel_sub);\n-\n-\t\t\t_baro_count = init_sensor_class(ORB_ID(sensor_baro), _baro_sub);\n-\n+\t\t\tinit_sensor_class(ORB_ID(sensor_gyro), _gyro);\n+\t\t\tinit_sensor_class(ORB_ID(sensor_mag), _mag);\n+\t\t\tinit_sensor_class(ORB_ID(sensor_accel), _accel);\n+\t\t\tinit_sensor_class(ORB_ID(sensor_baro), _baro);\n \t\t\t_last_config_update = hrt_absolute_time();\n \n \t\t} else {\n@@ -2260,22 +2411,20 @@ Sensors::task_main()\n \t\tperf_end(_loop_perf);\n \t}\n \n-\tfor (unsigned i = 0; i < SENSOR_COUNT_MAX; i++) {\n-\t\tif (_gyro_sub[i] >= 0) {\n-\t\t\torb_unsubscribe(_gyro_sub[i]);\n-\t\t}\n+\tfor (unsigned i = 0; i < _gyro.subscription_count; i++) {\n+\t\torb_unsubscribe(_gyro.subscription[i]);\n+\t}\n \n-\t\tif (_accel_sub[i] >= 0) {\n-\t\t\torb_unsubscribe(_accel_sub[i]);\n-\t\t}\n+\tfor (unsigned i = 0; i < _accel.subscription_count; i++) {\n+\t\torb_unsubscribe(_accel.subscription[i]);\n+\t}\n \n-\t\tif (_mag_sub[i] >= 0) {\n-\t\t\torb_unsubscribe(_mag_sub[i]);\n-\t\t}\n+\tfor (unsigned i = 0; i < _mag.subscription_count; i++) {\n+\t\torb_unsubscribe(_mag.subscription[i]);\n+\t}\n \n-\t\tif (_baro_sub[i] >= 0) {\n-\t\t\torb_unsubscribe(_baro_sub[i]);\n-\t\t}\n+\tfor (unsigned i = 0; i < _baro.subscription_count; i++) {\n+\t\torb_unsubscribe(_baro.subscription[i]);\n \t}\n \n \torb_unsubscribe(_rc_sub);\n@@ -2316,6 +2465,19 @@ Sensors::start()\n \treturn OK;\n }\n \n+void Sensors::print_status()\n+{\n+\tPX4_INFO(\"gyro status:\");\n+\t_gyro.voter.print();\n+\tPX4_INFO(\"accel status:\");\n+\t_accel.voter.print();\n+\tPX4_INFO(\"mag status:\");\n+\t_mag.voter.print();\n+\tPX4_INFO(\"baro status:\");\n+\t_baro.voter.print();\n+}\n+\n+\n int sensors_main(int argc, char *argv[])\n {\n \tif (argc < 2) {\n@@ -2360,7 +2522,7 @@ int sensors_main(int argc, char *argv[])\n \n \tif (!strcmp(argv[1], \"status\")) {\n \t\tif (sensors::g_sensors) {\n-\t\t\tPX4_INFO(\"is running\");\n+\t\t\tsensors::g_sensors->print_status();\n \t\t\treturn 0;\n \n \t\t} else {"}]}