{"sha":"6d5f12d2a2ab97f17070179cf3ccc94c3cbb4845","node_id":"MDY6Q29tbWl0NTI5ODc5MDo2ZDVmMTJkMmEyYWI5N2YxNzA3MDE3OWNmM2NjYzk0YzNjYmI0ODQ1","commit":{"author":{"name":"TSC21","email":"n.marques21@hotmail.com","date":"2021-05-07T11:32:25Z"},"committer":{"name":"Nuno Marques","email":"n.marques21@hotmail.com","date":"2021-06-21T14:36:44Z"},"message":"microRTPS: client: add TX rate limiter","tree":{"sha":"33c34faabcf8904a00d28684eb44bc8cbc4fa1ea","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/33c34faabcf8904a00d28684eb44bc8cbc4fa1ea"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/6d5f12d2a2ab97f17070179cf3ccc94c3cbb4845","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/6d5f12d2a2ab97f17070179cf3ccc94c3cbb4845","html_url":"https://github.com/PX4/PX4-Autopilot/commit/6d5f12d2a2ab97f17070179cf3ccc94c3cbb4845","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/6d5f12d2a2ab97f17070179cf3ccc94c3cbb4845/comments","author":{"login":"TSC21","id":5048656,"node_id":"MDQ6VXNlcjUwNDg2NTY=","avatar_url":"https://avatars.githubusercontent.com/u/5048656?v=4","gravatar_id":"","url":"https://api.github.com/users/TSC21","html_url":"https://github.com/TSC21","followers_url":"https://api.github.com/users/TSC21/followers","following_url":"https://api.github.com/users/TSC21/following{/other_user}","gists_url":"https://api.github.com/users/TSC21/gists{/gist_id}","starred_url":"https://api.github.com/users/TSC21/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/TSC21/subscriptions","organizations_url":"https://api.github.com/users/TSC21/orgs","repos_url":"https://api.github.com/users/TSC21/repos","events_url":"https://api.github.com/users/TSC21/events{/privacy}","received_events_url":"https://api.github.com/users/TSC21/received_events","type":"User","site_admin":false},"committer":{"login":"TSC21","id":5048656,"node_id":"MDQ6VXNlcjUwNDg2NTY=","avatar_url":"https://avatars.githubusercontent.com/u/5048656?v=4","gravatar_id":"","url":"https://api.github.com/users/TSC21","html_url":"https://github.com/TSC21","followers_url":"https://api.github.com/users/TSC21/followers","following_url":"https://api.github.com/users/TSC21/following{/other_user}","gists_url":"https://api.github.com/users/TSC21/gists{/gist_id}","starred_url":"https://api.github.com/users/TSC21/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/TSC21/subscriptions","organizations_url":"https://api.github.com/users/TSC21/orgs","repos_url":"https://api.github.com/users/TSC21/repos","events_url":"https://api.github.com/users/TSC21/events{/privacy}","received_events_url":"https://api.github.com/users/TSC21/received_events","type":"User","site_admin":false},"parents":[{"sha":"ac2b38603c2cd361741cdeabb49ad3d9cbc6c535","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/ac2b38603c2cd361741cdeabb49ad3d9cbc6c535","html_url":"https://github.com/PX4/PX4-Autopilot/commit/ac2b38603c2cd361741cdeabb49ad3d9cbc6c535"}],"stats":{"total":206,"additions":103,"deletions":103},"files":[{"sha":"fc06ddf3ff68d12ff4667188ef49a6f74747bbf8","filename":"msg/templates/uorb_microcdr/microRTPS_client.cpp.em","status":"modified","additions":61,"deletions":79,"changes":140,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/6d5f12d2a2ab97f17070179cf3ccc94c3cbb4845/msg%2Ftemplates%2Fuorb_microcdr%2FmicroRTPS_client.cpp.em","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/6d5f12d2a2ab97f17070179cf3ccc94c3cbb4845/msg%2Ftemplates%2Fuorb_microcdr%2FmicroRTPS_client.cpp.em","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/msg%2Ftemplates%2Fuorb_microcdr%2FmicroRTPS_client.cpp.em?ref=6d5f12d2a2ab97f17070179cf3ccc94c3cbb4845","patch":"@@ -57,8 +57,8 @@ receive_base_types = [s.short_name for idx, s in enumerate(spec) if scope[idx] =\n  *\n  ****************************************************************************/\n \n-#include \"microRTPS_transport.h\"\n-#include \"microRTPS_client.h\"\n+#include <microRTPS_transport.h>\n+#include <microRTPS_client.h>\n \n #include <inttypes.h>\n #include <cstdio>\n@@ -76,14 +76,7 @@ receive_base_types = [s.short_name for idx, s in enumerate(spec) if scope[idx] =\n #include <uORB_microcdr/topics/@(topic).h>\n @[end for]@\n \n-uint8_t last_remote_msg_seq = 0;\n-uint8_t last_msg_seq = 0;\n-\n-uint64_t tx_last_sec_read = 0;\n-uint64_t rx_last_sec_read = 0;\n-\n-pthread_mutex_t tx_lock;\n-pthread_mutex_t rx_lock;\n+using namespace time_literals;\n \n @[if recv_topics]@\n // Publishers for received messages\n@@ -101,44 +94,44 @@ struct SendTopicsSubs {\n \tuORB::Subscription @(topic)_sub{ORB_ID(@(topic))};\n @[    end for]@\n };\n-@[end if]@\n-\n-@[if send_topics]@\n \n struct SendThreadArgs {\n+\tconst uint32_t &datarate;\n \tuint64_t &total_sent;\n \tuint64_t &sent_last_sec;\n \tuint64_t &sent;\n \tint &sent_loop;\n-\tSendThreadArgs(uint64_t &total_sent_, uint64_t &sent_last_sec_, uint64_t &sent_, int &sent_loop_)\n-\t\t: total_sent(total_sent_),\n+\tSendThreadArgs(const uint32_t &datarate_, uint64_t &total_sent_,\n+                    uint64_t &sent_last_sec_, uint64_t &sent_, int &sent_loop_)\n+\t\t: datarate(datarate_),\n+\t\t  total_sent(total_sent_),\n \t\t  sent_last_sec(sent_last_sec_),\n \t\t  sent(sent_),\n \t\t  sent_loop(sent_loop_) {}\n };\n \n void *send(void *args)\n {\n-\tchar data_buffer[BUFFER_SIZE] = {};\n-\tint read = 0;\n-\tuint32_t length = 0;\n-\tsize_t header_length = 0;\n+\tchar data_buffer[BUFFER_SIZE]{};\n+\tint read{0};\n+\tuint32_t length{0};\n+\tsize_t header_length{0};\n+\tuint8_t last_msg_seq{0};\n+\tuint8_t last_remote_msg_seq{0};\n+\n \tstruct SendThreadArgs *data = reinterpret_cast<struct SendThreadArgs *>(args);\n \tSendTopicsSubs *subs = new SendTopicsSubs();\n \n+\tfloat bandwidth_mult{0};\n+\tfloat tx_interval{1.f};\n+\tuint64_t tx_last_sec_read{0};\n+\thrt_abstime last_stats_update{0};\n+\n \t// ucdrBuffer to serialize using the user defined buffer\n \tucdrBuffer writer;\n \theader_length = transport_node->get_header_length();\n \tucdr_init_buffer(&writer, reinterpret_cast<uint8_t *>(&data_buffer[header_length]), BUFFER_SIZE - header_length);\n \n-\tpthread_t tx_per_second_thread;\n-\tint rc = pthread_create(&tx_per_second_thread, nullptr, &tx_per_second, (void *)&data->sent_last_sec);\n-\tif (rc != 0) {\n-\t\terrno = rc;\n-\t\tPX4_ERR(\"Could not create tx counter thread (%d)\", errno);\n-\t\treturn nullptr;\n-\t}\n-\n \twhile (!_should_exit_task) {\n @[    for idx, topic in enumerate(send_topics)]@\n \t\t{\n@@ -163,9 +156,7 @@ void *send(void *args)\n \n \t\t\t\t\tif (0 < (read = transport_node->write(static_cast<char>(@(rtps_message_id(ids, topic))), data_buffer, length))) {\n \t\t\t\t\t\tdata->total_sent += read;\n-\t\t\t\t\t\tpthread_mutex_lock(&tx_lock);\n \t\t\t\t\t\ttx_last_sec_read += read;\n-\t\t\t\t\t\tpthread_mutex_unlock(&tx_lock);\n \t\t\t\t\t\t++data->sent;\n \t\t\t\t\t}\n \n@@ -176,37 +167,28 @@ void *send(void *args)\n \t\t\t}\n \t\t}\n @[    end for]@\n-\t\tpx4_usleep(_options.sleep_us);\n-\t\t++data->sent_loop;\n-\t}\n \n-\tpthread_join(tx_per_second_thread, nullptr);\n-\tdelete subs;\n+\t\tif (hrt_absolute_time() - last_stats_update >= 1_s) {\n+\t\t\tdata->sent_last_sec = tx_last_sec_read;\n+\t\t\tif (data->datarate > 0) {\n+\t\t\t\tbandwidth_mult = static_cast<float>(data->datarate) / static_cast<float>(tx_last_sec_read);\n+\t\t\t\t// Apply a low-pass filter to determine the new TX interval\n+\t\t\t\ttx_interval += 0.5f * (tx_interval / bandwidth_mult - tx_interval);\n+\t\t\t\t// Clamp the interval between 1 and 1000 ms\n+\t\t\t\ttx_interval = math::constrain(tx_interval, MIN_TX_INTERVAL_US, MAX_TX_INTERVAL_US);\n+\t\t\t}\n+\t\t\ttx_last_sec_read = 0;\n+\t\t\tlast_stats_update = hrt_absolute_time();\n+\t\t}\n \n-\treturn nullptr;\n-}\n+\t\tpx4_usleep(tx_interval);\n \n-void *tx_per_second(void *sent_last_sec)\n-{\n-\twhile (!_should_exit_task) {\n-\t\tpthread_mutex_lock(&tx_lock);\n-\t\t*((uint64_t *) sent_last_sec) = tx_last_sec_read;\n-\t\ttx_last_sec_read = 0;\n-\t\tpthread_mutex_unlock(&tx_lock);\n-\t\tpx4_sleep(1);\n+\t\t++data->sent_loop;\n \t}\n-\treturn nullptr;\n-}\n \n-void *rx_per_second(void *rcvd_last_sec)\n-{\n-\twhile (!_should_exit_task) {\n-\t\tpthread_mutex_lock(&rx_lock);\n-\t\t*((uint64_t *) rcvd_last_sec) = rx_last_sec_read;\n-\t\trx_last_sec_read = 0;\n-\t\tpthread_mutex_unlock(&rx_lock);\n-\t\tpx4_sleep(1);\n-\t}\n+\tdelete(data);\n+\tdelete(subs);\n+\n \treturn nullptr;\n }\n \n@@ -225,8 +207,8 @@ static int launch_send_thread(pthread_t &sender_thread, struct SendThreadArgs &a\n \t\tPX4_ERR(\"Could not create send thread (%d)\", errno);\n \t\treturn -1;\n \t}\n-\trc = pthread_setname_np(sender_thread, \"micrortps_client_send\");\n-\tif (pthread_setname_np(sender_thread, \"micrortps_client_send\")) {\n+\trc = pthread_setname_np(sender_thread, \"urtpsclient_snd\");\n+\tif (pthread_setname_np(sender_thread, \"urtpsclient_snd\")) {\n \t\terrno = rc;\n \t\tPX4_ERR(\"Could not set pthread name for the send thread (%d)\", errno);\n \t}\n@@ -236,13 +218,21 @@ static int launch_send_thread(pthread_t &sender_thread, struct SendThreadArgs &a\n }\n @[end if]@\n \n-void micrortps_start_topics(struct timespec &begin, uint64_t &total_rcvd, uint64_t &total_sent, uint64_t &sent_last_sec,\n+void micrortps_start_topics(const uint32_t &datarate, struct timespec &begin, uint64_t &total_rcvd,\n+\t\t\t    uint64_t &total_sent, uint64_t &sent_last_sec,\n \t\t\t    uint64_t &rcvd_last_sec, uint64_t &received, uint64_t &sent, int &rcvd_loop, int &sent_loop)\n {\n+\tpx4_clock_gettime(CLOCK_REALTIME, &begin);\n+\t_should_exit_task = false;\n+\n @[if recv_topics]@\n-\tchar data_buffer[BUFFER_SIZE] = {};\n-\tint read = 0;\n-\tuint8_t topic_ID = 255;\n+\tchar data_buffer[BUFFER_SIZE]{};\n+\tint read{0};\n+\tuint8_t topic_ID{255};\n+\n+\tuint64_t rx_last_sec_read{0};\n+\thrt_abstime last_stats_update{0};\n+\n \tRcvTopicsPubs *pubs = new RcvTopicsPubs();\n \n \t// Set the main task name to 'urtpsclient_rcv' in case there is\n@@ -252,21 +242,11 @@ void micrortps_start_topics(struct timespec &begin, uint64_t &total_rcvd, uint64\n \t// ucdrBuffer to deserialize using the user defined buffer\n \tucdrBuffer reader;\n \tucdr_init_buffer(&reader, reinterpret_cast<uint8_t *>(data_buffer), BUFFER_SIZE);\n-\n-\tpthread_t rx_per_second_thread;\n-\tint rc = pthread_create(&rx_per_second_thread, nullptr, &rx_per_second, (void *)&rcvd_last_sec);\n-\tif (rc != 0) {\n-\t\terrno = rc;\n-\t\tPX4_ERR(\"Could not create rx counter thread (%d)\", errno);\n-\t\treturn;\n-\t}\n @[end if]@\n \n-\tpx4_clock_gettime(CLOCK_REALTIME, &begin);\n-\t_should_exit_task = false;\n @[if send_topics]@\n \t// var struct to be updated on the thread\n-\tSendThreadArgs *sender_thread_args = new SendThreadArgs(total_sent, sent_last_sec, sent, sent_loop);\n+\tSendThreadArgs *sender_thread_args = new SendThreadArgs(datarate, total_sent, sent_last_sec, sent, sent_loop);\n \n \t// create a thread for sending data\n \tpthread_t sender_thread;\n@@ -275,11 +255,9 @@ void micrortps_start_topics(struct timespec &begin, uint64_t &total_rcvd, uint64\n \n \twhile (!_should_exit_task) {\n @[if recv_topics]@\n-\t\twhile (0 < (read = transport_node->read(&topic_ID, data_buffer, BUFFER_SIZE))) {\n+\t\tif (0 < (read = transport_node->read(&topic_ID, data_buffer, BUFFER_SIZE))) {\n \t\t\ttotal_rcvd += read;\n-\t\t\tpthread_mutex_lock(&rx_lock);\n-\t\t\trcvd_last_sec += read;\n-\t\t\tpthread_mutex_unlock(&rx_lock);\n+\t\t\trx_last_sec_read += read;\n \n \t\t\tuint64_t read_time = hrt_absolute_time();\n \n@@ -307,6 +285,12 @@ void micrortps_start_topics(struct timespec &begin, uint64_t &total_rcvd, uint64\n \t\t}\n @[end if]@\n \n+\t\tif (hrt_absolute_time() - last_stats_update >= 1_s) {\n+\t\t\trcvd_last_sec = rx_last_sec_read;\n+\t\t\trx_last_sec_read = 0;\n+\t\t\tlast_stats_update = hrt_absolute_time();\n+\t\t}\n+\n \t\t// loop forever if informed loop number is negative\n \t\tif (_options.loops >= 0 && rcvd_loop >= _options.loops) { break; }\n \n@@ -315,12 +299,10 @@ void micrortps_start_topics(struct timespec &begin, uint64_t &total_rcvd, uint64\n \t}\n \n @[if send_topics]@\n-\tdelete sender_thread_args;\n \t_should_exit_task = true;\n \tpthread_join(sender_thread, nullptr);\n @[end if]@\n @[if recv_topics]@\n-\tpthread_join(rx_per_second_thread, nullptr);\n-\tdelete pubs;\n+\tdelete(pubs);\n @[end if]@\n }"},{"sha":"381b9a1603a99bbb4bc68b63d3073ae65c1bc428","filename":"src/modules/micrortps_bridge/micrortps_client/microRTPS_client.h","status":"modified","additions":15,"deletions":13,"changes":28,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/6d5f12d2a2ab97f17070179cf3ccc94c3cbb4845/src%2Fmodules%2Fmicrortps_bridge%2Fmicrortps_client%2FmicroRTPS_client.h","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/6d5f12d2a2ab97f17070179cf3ccc94c3cbb4845/src%2Fmodules%2Fmicrortps_bridge%2Fmicrortps_client%2FmicroRTPS_client.h","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fmicrortps_bridge%2Fmicrortps_client%2FmicroRTPS_client.h?ref=6d5f12d2a2ab97f17070179cf3ccc94c3cbb4845","patch":"@@ -33,7 +33,7 @@\n \n #pragma once\n \n-#include \"microRTPS_transport.h\"\n+#include <microRTPS_transport.h>\n \n #include <inttypes.h>\n #include <cstdio>\n@@ -49,21 +49,22 @@\n #include <px4_platform_common/time.h>\n #include <uORB/uORB.h>\n \n-#define LOOPS -1\n-#define SLEEP_US 1\n-#define BAUDRATE 460800\n-#define DEVICE \"/dev/ttyACM0\"\n-#define POLL_MS 1\n-#define IP \"127.0.0.1\"\n-#define DEFAULT_RECV_PORT 2019\n-#define DEFAULT_SEND_PORT 2020\n+#define LOOPS\t\t\t-1\n+#define SLEEP_US\t\t1000\n+#define BAUDRATE\t\t460800\n+#define MAX_DATA_RATE\t\t10000000\n+#define DEVICE\t\t\"/dev/ttyACM0\"\n+#define POLL_MS\t\t1\n+#define IP\t\t\t\"127.0.0.1\"\n+#define DEFAULT_RECV_PORT\t2019\n+#define DEFAULT_SEND_PORT\t2020\n+#define MIN_TX_INTERVAL_US\t1000.f\n+#define MAX_TX_INTERVAL_US\t1000000.f\n \n \n void *send(void *args);\n-void *tx_per_second(void *sent_last_sec);\n-void *rx_per_second(void *rcvd_last_sec);\n-\n-void micrortps_start_topics(struct timespec &begin, uint64_t &total_rcvd, uint64_t &total_sent, uint64_t &sent_last_sec,\n+void micrortps_start_topics(const uint32_t &datarate, struct timespec &begin, uint64_t &total_rcvd,\n+\t\t\t    uint64_t &total_sent, uint64_t &sent_last_sec,\n \t\t\t    uint64_t &rcvd_last_sec, uint64_t &received, uint64_t &sent, int &rcvd_loop, int &sent_loop);\n \n struct baudtype {\n@@ -83,6 +84,7 @@ struct options {\n \tuint16_t send_port = DEFAULT_SEND_PORT;\n \tuint32_t sleep_us = SLEEP_US;\n \tuint32_t baudrate = BAUDRATE;\n+\tuint32_t datarate = 0;\n \tuint32_t poll_ms = POLL_MS;\n \tint loops = LOOPS;\n \tbool sw_flow_control = false;"},{"sha":"228b3d3de9589dcb1abd1efee871da02dbeda29c","filename":"src/modules/micrortps_bridge/micrortps_client/microRTPS_client_main.cpp","status":"modified","additions":27,"deletions":11,"changes":38,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/6d5f12d2a2ab97f17070179cf3ccc94c3cbb4845/src%2Fmodules%2Fmicrortps_bridge%2Fmicrortps_client%2FmicroRTPS_client_main.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/6d5f12d2a2ab97f17070179cf3ccc94c3cbb4845/src%2Fmodules%2Fmicrortps_bridge%2Fmicrortps_client%2FmicroRTPS_client_main.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fmicrortps_bridge%2Fmicrortps_client%2FmicroRTPS_client_main.cpp?ref=6d5f12d2a2ab97f17070179cf3ccc94c3cbb4845","patch":"@@ -31,8 +31,8 @@\n  *\n  ****************************************************************************/\n \n-#include \"microRTPS_transport.h\"\n-#include \"microRTPS_client.h\"\n+#include <microRTPS_transport.h>\n+#include <microRTPS_client.h>\n \n #include <inttypes.h>\n #include <cstdio>\n@@ -75,10 +75,11 @@ static void usage(const char *name)\n \tPRINT_MODULE_USAGE_PARAM_STRING('t', \"UART\", \"UART|UDP\", \"Transport protocol\", true);\n \tPRINT_MODULE_USAGE_PARAM_STRING('d', \"/dev/ttyACM0\", \"<file:dev>\", \"Select Serial Device\", true);\n \tPRINT_MODULE_USAGE_PARAM_INT('b', 460800, 9600, 3000000, \"Baudrate (can also be p:<param_name>)\", true);\n+\tPRINT_MODULE_USAGE_PARAM_INT('m', 0, 10, 10000000, \"Maximum sending data rate in B/s\", true);\n \tPRINT_MODULE_USAGE_PARAM_INT('p', -1, 1, 1000, \"Poll timeout for UART in ms\", true);\n \tPRINT_MODULE_USAGE_PARAM_INT('l', 10000, -1, 100000, \"Limit number of iterations until the program exits (-1=infinite)\",\n \t\t\t\t     true);\n-\tPRINT_MODULE_USAGE_PARAM_INT('w', 1, 1, 1000000, \"Time in us for which each iteration sleeps\", true);\n+\tPRINT_MODULE_USAGE_PARAM_INT('w', 1, 1, 1000000, \"Time in us for which each read from the link iteration sleeps\", true);\n \tPRINT_MODULE_USAGE_PARAM_INT('r', 2019, 0, 65536, \"Select UDP Network Port for receiving (local)\", true);\n \tPRINT_MODULE_USAGE_PARAM_INT('s', 2020, 0, 65536, \"Select UDP Network Port for sending (remote)\", true);\n \tPRINT_MODULE_USAGE_PARAM_STRING('i', \"127.0.0.1\", \"<x.x.x.x>\", \"Select IP address (remote)\", true);\n@@ -96,7 +97,7 @@ static int parse_options(int argc, char *argv[])\n \tint myoptind = 1;\n \tconst char *myoptarg = nullptr;\n \n-\twhile ((ch = px4_getopt(argc, argv, \"t:d:l:w:b:p:r:s:i:fhv\", &myoptind, &myoptarg)) != EOF) {\n+\twhile ((ch = px4_getopt(argc, argv, \"t:d:l:w:b:m:p:r:s:i:fhv\", &myoptind, &myoptarg)) != EOF) {\n \t\tswitch (ch) {\n \t\tcase 't': _options.transport      = strcmp(myoptarg, \"UDP\") == 0 ?\n \t\t\t\t\t\t\t    options::eTransports::UDP\n@@ -120,6 +121,8 @@ static int parse_options(int argc, char *argv[])\n \t\t\t\tbreak;\n \t\t\t}\n \n+\t\tcase 'm': _options.datarate        = strtoul(myoptarg, nullptr, 10);    break;\n+\n \t\tcase 'p': _options.poll_ms         = strtoul(myoptarg, nullptr, 10);    break;\n \n \t\tcase 'r': _options.recv_port       = strtoul(myoptarg, nullptr, 10);    break;\n@@ -140,9 +143,13 @@ static int parse_options(int argc, char *argv[])\n \t\t}\n \t}\n \n+\tif (_options.datarate > MAX_DATA_RATE) {\n+\t\t_options.datarate = MAX_DATA_RATE;\n+\t\tPX4_WARN(\"Invalid data rate. Using max datarate of %ul B/s\", MAX_DATA_RATE);\n+\t}\n+\n \tif (_options.poll_ms < 1) {\n-\t\t_options.poll_ms = 1;\n-\t\tPX4_ERR(\"poll timeout too low, using 1 ms\");\n+\t\tPX4_WARN(\"Poll timeout too low, using %ul ms\", POLL_MS);\n \t}\n \n \tif (_options.hw_flow_control && _options.sw_flow_control) {\n@@ -193,7 +200,8 @@ static int micrortps_start(int argc, char *argv[])\n \t\treturn -1;\n \t}\n \n-\tmicrortps_start_topics(begin, total_rcvd, total_sent, sent_last_sec, rcvd_last_sec, received, sent, rcv_loop,\n+\tmicrortps_start_topics(_options.datarate, begin, total_rcvd, total_sent, sent_last_sec, rcvd_last_sec, received, sent,\n+\t\t\t       rcv_loop,\n \t\t\t       send_loop);\n \n \tpx4_clock_gettime(CLOCK_REALTIME, &end);\n@@ -262,10 +270,18 @@ int micrortps_client_main(int argc, char *argv[])\n \t\t\tprintf(\"\\ttotal data read: %\" PRIu64 \" bytes\\n\", total_rcvd);\n \t\t\tprintf(\"\\ttotal data sent: %\" PRIu64 \" bytes\\n\", total_sent);\n \t\t\tprintf(\"\\trates:\\n\");\n-\t\t\tprintf(\"\\t  rx: %.3f kB/s\\n\", rcvd_last_sec / 1E3);\n-\t\t\tprintf(\"\\t  tx: %.3f kB/s\\n\", sent_last_sec / 1E3);\n-\t\t\tprintf(\"\\t  avg rx: %.3f kB/s\\n\", static_cast<double>(total_rcvd / (1e3 * elapsed_secs)));\n-\t\t\tprintf(\"\\t  avg tx: %.3f kB/s\\n\", static_cast<double>(total_sent / (1e3 * elapsed_secs)));\n+\t\t\tprintf(\"\\t  rx: %.3f kB/s\\n\", rcvd_last_sec / 1e3);\n+\t\t\tprintf(\"\\t  tx: %.3f kB/s\\n\", sent_last_sec / 1e3);\n+\t\t\tprintf(\"\\t  avg rx: %.3f kB/s\\n\", total_rcvd / (1e3 * elapsed_secs));\n+\t\t\tprintf(\"\\t  avg tx: %.3f kB/s\\n\", total_sent / (1e3 * elapsed_secs));\n+\t\t\tprintf(\"\\t  tx rate max:\");\n+\n+\t\t\tif (_options.datarate != 0) {\n+\t\t\t\tprintf(\" %.1f kB/s\\n\", _options.datarate / 1e3);\n+\n+\t\t\t} else {\n+\t\t\t\tprintf(\" Unlimited\\n\");\n+\t\t\t}\n \t\t}\n \n \t\treturn 0;"}]}