{"sha":"7e0f8b3edaf584a48cd3bc3351e3205fd0106cdc","node_id":"MDY6Q29tbWl0NTI5ODc5MDo3ZTBmOGIzZWRhZjU4NGE0OGNkM2JjMzM1MWUzMjA1ZmQwMTA2Y2Rj","commit":{"author":{"name":"px4dev","email":"px4@purgatory.org","date":"2013-04-20T22:18:10Z"},"committer":{"name":"px4dev","email":"px4@purgatory.org","date":"2013-04-20T22:18:10Z"},"message":"Formatting changes to make the Python style checker happy (copied from the bootloader project).\n\nIncrease the erase timeout to avoid issues with large/slow flash.","tree":{"sha":"5e5c491aaf8a27151f158cd46fcc873884e25b3a","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/5e5c491aaf8a27151f158cd46fcc873884e25b3a"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/7e0f8b3edaf584a48cd3bc3351e3205fd0106cdc","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/7e0f8b3edaf584a48cd3bc3351e3205fd0106cdc","html_url":"https://github.com/PX4/PX4-Autopilot/commit/7e0f8b3edaf584a48cd3bc3351e3205fd0106cdc","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/7e0f8b3edaf584a48cd3bc3351e3205fd0106cdc/comments","author":{"login":"px4dev","id":2095699,"node_id":"MDQ6VXNlcjIwOTU2OTk=","avatar_url":"https://avatars.githubusercontent.com/u/2095699?v=4","gravatar_id":"","url":"https://api.github.com/users/px4dev","html_url":"https://github.com/px4dev","followers_url":"https://api.github.com/users/px4dev/followers","following_url":"https://api.github.com/users/px4dev/following{/other_user}","gists_url":"https://api.github.com/users/px4dev/gists{/gist_id}","starred_url":"https://api.github.com/users/px4dev/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/px4dev/subscriptions","organizations_url":"https://api.github.com/users/px4dev/orgs","repos_url":"https://api.github.com/users/px4dev/repos","events_url":"https://api.github.com/users/px4dev/events{/privacy}","received_events_url":"https://api.github.com/users/px4dev/received_events","type":"User","site_admin":false},"committer":{"login":"px4dev","id":2095699,"node_id":"MDQ6VXNlcjIwOTU2OTk=","avatar_url":"https://avatars.githubusercontent.com/u/2095699?v=4","gravatar_id":"","url":"https://api.github.com/users/px4dev","html_url":"https://github.com/px4dev","followers_url":"https://api.github.com/users/px4dev/followers","following_url":"https://api.github.com/users/px4dev/following{/other_user}","gists_url":"https://api.github.com/users/px4dev/gists{/gist_id}","starred_url":"https://api.github.com/users/px4dev/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/px4dev/subscriptions","organizations_url":"https://api.github.com/users/px4dev/orgs","repos_url":"https://api.github.com/users/px4dev/repos","events_url":"https://api.github.com/users/px4dev/events{/privacy}","received_events_url":"https://api.github.com/users/px4dev/received_events","type":"User","site_admin":false},"parents":[{"sha":"5f14815d51f6dc2b20caac83bd7bb5d7eb9a0216","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/5f14815d51f6dc2b20caac83bd7bb5d7eb9a0216","html_url":"https://github.com/PX4/PX4-Autopilot/commit/5f14815d51f6dc2b20caac83bd7bb5d7eb9a0216"}],"stats":{"total":679,"additions":340,"deletions":339},"files":[{"sha":"d2ebf169879ae768bb4c7e49f4ab530616d24d15","filename":"Tools/px_uploader.py","status":"modified","additions":340,"deletions":339,"changes":679,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/7e0f8b3edaf584a48cd3bc3351e3205fd0106cdc/Tools%2Fpx_uploader.py","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/7e0f8b3edaf584a48cd3bc3351e3205fd0106cdc/Tools%2Fpx_uploader.py","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/Tools%2Fpx_uploader.py?ref=7e0f8b3edaf584a48cd3bc3351e3205fd0106cdc","patch":"@@ -41,20 +41,19 @@\n # The uploader uses the following fields from the firmware file:\n #\n # image\n-#\tThe firmware that will be uploaded.\n+#       The firmware that will be uploaded.\n # image_size\n-#\tThe size of the firmware in bytes.\n+#       The size of the firmware in bytes.\n # board_id\n-#\tThe board for which the firmware is intended.\n+#       The board for which the firmware is intended.\n # board_revision\n-#\tCurrently only used for informational purposes.\n+#       Currently only used for informational purposes.\n #\n \n import sys\n import argparse\n import binascii\n import serial\n-import os\n import struct\n import json\n import zlib\n@@ -64,292 +63,294 @@\n \n from sys import platform as _platform\n \n+\n class firmware(object):\n-\t'''Loads a firmware file'''\n-\n-\tdesc = {}\n-\timage = bytes()\n-\tcrctab = array.array('I', [\n-\t\t0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n-\t\t0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,\n-\t\t0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n-\t\t0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,\n-\t\t0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n-\t\t0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n-\t\t0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,\n-\t\t0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,\n-\t\t0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n-\t\t0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n-\t\t0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,\n-\t\t0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n-\t\t0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,\n-\t\t0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,\n-\t\t0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n-\t\t0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,\n-\t\t0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,\n-\t\t0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n-\t\t0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,\n-\t\t0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n-\t\t0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n-\t\t0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,\n-\t\t0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,\n-\t\t0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n-\t\t0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n-\t\t0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,\n-\t\t0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n-\t\t0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,\n-\t\t0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,\n-\t\t0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n-\t\t0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,\n-\t\t0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d ])\n-\tcrcpad = bytearray('\\xff\\xff\\xff\\xff')\n-\n-\tdef __init__(self, path):\n-\n-\t\t# read the file\n-\t\tf = open(path, \"r\")\n-\t\tself.desc = json.load(f)\n-\t\tf.close()\n-\n-\t\tself.image = bytearray(zlib.decompress(base64.b64decode(self.desc['image'])))\n-\n-\t\t# pad image to 4-byte length\n-\t\twhile ((len(self.image) % 4) != 0):\n-\t\t\tself.image.append('\\xff')\n-\n-\tdef property(self, propname):\n-\t\treturn self.desc[propname]\n-\n-\tdef __crc32(self, bytes, state):\n-\t\tfor byte in bytes:\n-\t\t\tindex = (state ^ byte) & 0xff\n-\t\t\tstate = self.crctab[index] ^ (state >> 8)\n-\t\treturn state\n-\n-\tdef crc(self, padlen):\n-\t\tstate = self.__crc32(self.image, int(0))\n-\t\tfor i in range(len(self.image), (padlen - 1), 4):\n-\t\t\tstate = self.__crc32(self.crcpad, state)\n-\t\treturn state\n+        '''Loads a firmware file'''\n+\n+        desc = {}\n+        image = bytes()\n+        crctab = array.array('I', [\n+            0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n+            0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,\n+            0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n+            0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,\n+            0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n+            0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n+            0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,\n+            0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,\n+            0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n+            0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n+            0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,\n+            0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n+            0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,\n+            0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,\n+            0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n+            0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,\n+            0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,\n+            0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n+            0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,\n+            0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n+            0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n+            0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,\n+            0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,\n+            0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n+            0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n+            0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,\n+            0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n+            0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,\n+            0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,\n+            0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n+            0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,\n+            0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d])\n+        crcpad = bytearray('\\xff\\xff\\xff\\xff')\n+\n+        def __init__(self, path):\n+\n+                # read the file\n+                f = open(path, \"r\")\n+                self.desc = json.load(f)\n+                f.close()\n+\n+                self.image = bytearray(zlib.decompress(base64.b64decode(self.desc['image'])))\n+\n+                # pad image to 4-byte length\n+                while ((len(self.image) % 4) != 0):\n+                        self.image.append('\\xff')\n+\n+        def property(self, propname):\n+                return self.desc[propname]\n+\n+        def __crc32(self, bytes, state):\n+                for byte in bytes:\n+                        index = (state ^ byte) & 0xff\n+                        state = self.crctab[index] ^ (state >> 8)\n+                return state\n+\n+        def crc(self, padlen):\n+                state = self.__crc32(self.image, int(0))\n+                for i in range(len(self.image), (padlen - 1), 4):\n+                        state = self.__crc32(self.crcpad, state)\n+                return state\n+\n \n class uploader(object):\n-\t'''Uploads a firmware file to the PX FMU bootloader'''\n-\n-\t# protocol bytes\n-\tINSYNC\t\t= chr(0x12)\n-\tEOC\t\t= chr(0x20)\n-\n-\t# reply bytes\n-\tOK\t\t= chr(0x10)\n-\tFAILED\t\t= chr(0x11)\n-\tINVALID\t\t= chr(0x13)\t# rev3+\n-\n-\t# command bytes\n-\tNOP\t\t= chr(0x00)\t# guaranteed to be discarded by the bootloader\n-\tGET_SYNC\t= chr(0x21)\n-\tGET_DEVICE\t= chr(0x22)\n-\tCHIP_ERASE\t= chr(0x23)\n-\tCHIP_VERIFY\t= chr(0x24)\t# rev2 only\n-\tPROG_MULTI\t= chr(0x27)\n-\tREAD_MULTI\t= chr(0x28)\t# rev2 only\n-\tGET_CRC\t\t= chr(0x29)\t# rev3+\n-\tREBOOT\t\t= chr(0x30)\n-\t\n-\tINFO_BL_REV\t= chr(1)\t# bootloader protocol revision\n-\tBL_REV_MIN\t= 2\t\t# minimum supported bootloader protocol \n-\tBL_REV_MAX\t= 3\t\t# maximum supported bootloader protocol \n-\tINFO_BOARD_ID\t= chr(2)\t# board type\n-\tINFO_BOARD_REV\t= chr(3)\t# board revision\n-\tINFO_FLASH_SIZE\t= chr(4)\t# max firmware size in bytes\n-\n-\tPROG_MULTI_MAX\t= 60\t\t# protocol max is 255, must be multiple of 4\n-\tREAD_MULTI_MAX\t= 60\t\t# protocol max is 255, something overflows with >= 64\n-\n-\tdef __init__(self, portname, baudrate):\n-\t\t# open the port, keep the default timeout short so we can poll quickly\n-\t\tself.port = serial.Serial(portname, baudrate, timeout=0.5)\n-\n-\tdef close(self):\n-\t\tif self.port is not None:\n-\t\t\tself.port.close()\n-\n-\tdef __send(self, c):\n-#\t\tprint(\"send \" + binascii.hexlify(c))\n-\t\tself.port.write(str(c))\n-\n-\tdef __recv(self, count = 1):\n-\t\tc = self.port.read(count)\n-\t\tif len(c) < 1:\n-\t\t\traise RuntimeError(\"timeout waiting for data\")\n-#\t\tprint(\"recv \" + binascii.hexlify(c))\n-\t\treturn c\n-\n-\tdef __recv_int(self):\n-\t\traw = self.__recv(4)\n-\t\tval = struct.unpack(\"<I\", raw)\n-\t\treturn val[0]\n-\n-\tdef __getSync(self):\n-\t\tself.port.flush()\n-\t\tc = self.__recv()\n-\t\tif c is not self.INSYNC:\n-\t\t\traise RuntimeError(\"unexpected 0x%x instead of INSYNC\" % ord(c))\n-\t\tc = self.__recv()\n-\t\tif c == self.INVALID:\n-\t\t\traise RuntimeError(\"bootloader reports INVALID OPERATION\")\n-\t\tif c == self.FAILED:\n-\t\t\traise RuntimeError(\"bootloader reports OPERATION FAILED\")\n-\t\tif c != self.OK:\n-\t\t\traise RuntimeError(\"unexpected response 0x%x instead of OK\" % ord(c))\n-\n-\t# attempt to get back into sync with the bootloader\n-\tdef __sync(self):\n-\t\t# send a stream of ignored bytes longer than the longest possible conversation\n-\t\t# that we might still have in progress\n-#\t\tself.__send(uploader.NOP * (uploader.PROG_MULTI_MAX + 2))\n-\t\tself.port.flushInput()\n-\t\tself.__send(uploader.GET_SYNC \n-\t\t\t\t+ uploader.EOC)\n-\t\tself.__getSync()\n-\t\t\n-#\tdef __trySync(self):\n-#\t\tc = self.__recv()\n-#\t\tif (c != self.INSYNC):\n-#\t\t\t#print(\"unexpected 0x%x instead of INSYNC\" % ord(c))\n-#\t\t\treturn False;\n-#\t\tc = self.__recv()\n-#\t\tif (c != self.OK):\n-#\t\t\t#print(\"unexpected 0x%x instead of OK\" % ord(c))\n-#\t\t\treturn False\n-#\t\treturn True\n-\n-\t# send the GET_DEVICE command and wait for an info parameter\n-\tdef __getInfo(self, param):\n-\t\tself.__send(uploader.GET_DEVICE + param + uploader.EOC)\n-\t\tvalue = self.__recv_int()\n-\t\tself.__getSync()\n-\t\treturn value\n-\n-\t# send the CHIP_ERASE command and wait for the bootloader to become ready\n-\tdef __erase(self):\n-\t\tself.__send(uploader.CHIP_ERASE \n-\t\t\t\t+ uploader.EOC)\n-\t\t# erase is very slow, give it 10s\n-\t\tdeadline = time.time() + 10\n-\t\twhile time.time() < deadline:\n-\t\t\ttry:\n-\t\t\t\tself.__getSync()\n-\t\t\t\treturn\n-\t\t\texcept RuntimeError as ex:\n-\t\t\t\t# we timed out, that's OK\n-\t\t\t\tcontinue\n-\n-\t\traise RuntimeError(\"timed out waiting for erase\")\n-\n-\t# send a PROG_MULTI command to write a collection of bytes\n-\tdef __program_multi(self, data):\n-\t\tself.__send(uploader.PROG_MULTI\n-\t\t\t\t+ chr(len(data)))\n-\t\tself.__send(data)\n-\t\tself.__send(uploader.EOC)\n-\t\tself.__getSync()\n-\t\t\n-\t# verify multiple bytes in flash\n-\tdef __verify_multi(self, data):\n-\t\tself.__send(uploader.READ_MULTI\n-\t\t\t\t+ chr(len(data))\n-\t\t\t\t+ uploader.EOC)\n-\t\tself.port.flush()\n-\t\tprogrammed = self.__recv(len(data))\n-\t\tif programmed != data:\n-\t\t\tprint((\"got    \" + binascii.hexlify(programmed)))\n-\t\t\tprint((\"expect \" + binascii.hexlify(data)))\n-\t\t\treturn False\n-\t\tself.__getSync()\n-\t\treturn True\n-\t\t\n-\t# send the reboot command\n-\tdef __reboot(self):\n-\t\tself.__send(uploader.REBOOT\n-\t\t\t\t+ uploader.EOC)\n-\t\tself.port.flush()\n-\n-\t\t# v3+ can report failure if the first word flash fails\n-\t\tif self.bl_rev >= 3:\n-\t\t\tself.__getSync()\n-\n-\t# split a sequence into a list of size-constrained pieces\n-\tdef __split_len(self, seq, length):\n-    \t\treturn [seq[i:i+length] for i in range(0, len(seq), length)]\n-\n-\t# upload code\n-\tdef __program(self, fw):\n-\t\tcode = fw.image\n-\t\tgroups = self.__split_len(code, uploader.PROG_MULTI_MAX)\n-\t\tfor bytes in groups:\n-\t\t\tself.__program_multi(bytes)\n-\n-\t# verify code\n-\tdef __verify_v2(self, fw):\n-\t\tself.__send(uploader.CHIP_VERIFY\n-\t\t\t\t+ uploader.EOC)\n-\t\tself.__getSync()\n-\t\tcode = fw.image\n-\t\tgroups = self.__split_len(code, uploader.READ_MULTI_MAX)\n-\t\tfor bytes in groups:\n-\t\t\tif (not self.__verify_multi(bytes)):\n-\t\t\t\traise RuntimeError(\"Verification failed\")\n-\n-\tdef __verify_v3(self, fw):\n-\t\texpect_crc = fw.crc(self.fw_maxsize)\n-\t\tself.__send(uploader.GET_CRC\n-\t\t\t\t+ uploader.EOC)\n-\t\treport_crc = self.__recv_int()\n-\t\tself.__getSync()\n-\t\tif report_crc != expect_crc:\n-\t\t\tprint((\"Expected 0x%x\" % expect_crc))\n-\t\t\tprint((\"Got      0x%x\" % report_crc))\n-\t\t\traise RuntimeError(\"Program CRC failed\")\n-\n-\t# get basic data about the board\n-\tdef identify(self):\n-\t\t# make sure we are in sync before starting\n-\t\tself.__sync()\n-\n-\t\t# get the bootloader protocol ID first\n-\t\tself.bl_rev = self.__getInfo(uploader.INFO_BL_REV)\n-\t\tif (self.bl_rev < uploader.BL_REV_MIN) or (self.bl_rev > uploader.BL_REV_MAX):\n-\t\t\tprint((\"Unsupported bootloader protocol %d\" % uploader.INFO_BL_REV))\n-\t\t\traise RuntimeError(\"Bootloader protocol mismatch\")\n-\n-\t\tself.board_type = self.__getInfo(uploader.INFO_BOARD_ID)\n-\t\tself.board_rev = self.__getInfo(uploader.INFO_BOARD_REV)\n-\t\tself.fw_maxsize = self.__getInfo(uploader.INFO_FLASH_SIZE)\n-\n-\t# upload the firmware\n-\tdef upload(self, fw):\n-\t\t# Make sure we are doing the right thing\n-\t\tif self.board_type != fw.property('board_id'):\n-\t\t\traise RuntimeError(\"Firmware not suitable for this board (run 'make configure_px4fmu && make clean' or 'make configure_px4io && make clean' to reconfigure).\")\n-\t\tif self.fw_maxsize < fw.property('image_size'):\n-\t\t\traise RuntimeError(\"Firmware image is too large for this board\")\n-\n-\t\tprint(\"erase...\")\n-\t\tself.__erase()\n-\n-\t\tprint(\"program...\")\n-\t\tself.__program(fw)\n-\n-\t\tprint(\"verify...\")\n-\t\tif self.bl_rev == 2:\n-\t\t\tself.__verify_v2(fw)\n-\t\telse:\n-\t\t\tself.__verify_v3(fw)\n-\n-\t\tprint(\"done, rebooting.\")\n-\t\tself.__reboot()\n-\t\tself.port.close()\n-\t\n+        '''Uploads a firmware file to the PX FMU bootloader'''\n+\n+        # protocol bytes\n+        INSYNC          = chr(0x12)\n+        EOC             = chr(0x20)\n+\n+        # reply bytes\n+        OK              = chr(0x10)\n+        FAILED          = chr(0x11)\n+        INVALID         = chr(0x13)     # rev3+\n+\n+        # command bytes\n+        NOP             = chr(0x00)     # guaranteed to be discarded by the bootloader\n+        GET_SYNC        = chr(0x21)\n+        GET_DEVICE      = chr(0x22)\n+        CHIP_ERASE      = chr(0x23)\n+        CHIP_VERIFY     = chr(0x24)     # rev2 only\n+        PROG_MULTI      = chr(0x27)\n+        READ_MULTI      = chr(0x28)     # rev2 only\n+        GET_CRC         = chr(0x29)     # rev3+\n+        REBOOT          = chr(0x30)\n+        \n+        INFO_BL_REV     = chr(1)        # bootloader protocol revision\n+        BL_REV_MIN      = 2             # minimum supported bootloader protocol \n+        BL_REV_MAX      = 3             # maximum supported bootloader protocol \n+        INFO_BOARD_ID   = chr(2)        # board type\n+        INFO_BOARD_REV  = chr(3)        # board revision\n+        INFO_FLASH_SIZE = chr(4)        # max firmware size in bytes\n+\n+        PROG_MULTI_MAX  = 60            # protocol max is 255, must be multiple of 4\n+        READ_MULTI_MAX  = 60            # protocol max is 255, something overflows with >= 64\n+\n+        def __init__(self, portname, baudrate):\n+                # open the port, keep the default timeout short so we can poll quickly\n+                self.port = serial.Serial(portname, baudrate, timeout=0.5)\n+\n+        def close(self):\n+                if self.port is not None:\n+                        self.port.close()\n+\n+        def __send(self, c):\n+#               print(\"send \" + binascii.hexlify(c))\n+                self.port.write(str(c))\n+\n+        def __recv(self, count=1):\n+                c = self.port.read(count)\n+                if len(c) < 1:\n+                        raise RuntimeError(\"timeout waiting for data\")\n+#               print(\"recv \" + binascii.hexlify(c))\n+                return c\n+\n+        def __recv_int(self):\n+                raw = self.__recv(4)\n+                val = struct.unpack(\"<I\", raw)\n+                return val[0]\n+\n+        def __getSync(self):\n+                self.port.flush()\n+                c = self.__recv()\n+                if c is not self.INSYNC:\n+                        raise RuntimeError(\"unexpected 0x%x instead of INSYNC\" % ord(c))\n+                c = self.__recv()\n+                if c == self.INVALID:\n+                        raise RuntimeError(\"bootloader reports INVALID OPERATION\")\n+                if c == self.FAILED:\n+                        raise RuntimeError(\"bootloader reports OPERATION FAILED\")\n+                if c != self.OK:\n+                        raise RuntimeError(\"unexpected response 0x%x instead of OK\" % ord(c))\n+\n+        # attempt to get back into sync with the bootloader\n+        def __sync(self):\n+                # send a stream of ignored bytes longer than the longest possible conversation\n+                # that we might still have in progress\n+#               self.__send(uploader.NOP * (uploader.PROG_MULTI_MAX + 2))\n+                self.port.flushInput()\n+                self.__send(uploader.GET_SYNC\n+                            + uploader.EOC)\n+                self.__getSync()\n+\n+#       def __trySync(self):\n+#               c = self.__recv()\n+#               if (c != self.INSYNC):\n+#                       #print(\"unexpected 0x%x instead of INSYNC\" % ord(c))\n+#                       return False;\n+#               c = self.__recv()\n+#               if (c != self.OK):\n+#                       #print(\"unexpected 0x%x instead of OK\" % ord(c))\n+#                       return False\n+#               return True\n+\n+        # send the GET_DEVICE command and wait for an info parameter\n+        def __getInfo(self, param):\n+                self.__send(uploader.GET_DEVICE + param + uploader.EOC)\n+                value = self.__recv_int()\n+                self.__getSync()\n+                return value\n+\n+        # send the CHIP_ERASE command and wait for the bootloader to become ready\n+        def __erase(self):\n+                self.__send(uploader.CHIP_ERASE\n+                            + uploader.EOC)\n+                # erase is very slow, give it 20s\n+                deadline = time.time() + 20\n+                while time.time() < deadline:\n+                        try:\n+                                self.__getSync()\n+                                return\n+                        except RuntimeError:\n+                                # we timed out, that's OK\n+                                continue\n+\n+                raise RuntimeError(\"timed out waiting for erase\")\n+\n+        # send a PROG_MULTI command to write a collection of bytes\n+        def __program_multi(self, data):\n+                self.__send(uploader.PROG_MULTI\n+                            + chr(len(data)))\n+                self.__send(data)\n+                self.__send(uploader.EOC)\n+                self.__getSync()\n+\n+        # verify multiple bytes in flash\n+        def __verify_multi(self, data):\n+                self.__send(uploader.READ_MULTI\n+                            + chr(len(data))\n+                            + uploader.EOC)\n+                self.port.flush()\n+                programmed = self.__recv(len(data))\n+                if programmed != data:\n+                        print(\"got    \" + binascii.hexlify(programmed))\n+                        print(\"expect \" + binascii.hexlify(data))\n+                        return False\n+                self.__getSync()\n+                return True\n+\n+        # send the reboot command\n+        def __reboot(self):\n+                self.__send(uploader.REBOOT\n+                            + uploader.EOC)\n+                self.port.flush()\n+\n+                # v3+ can report failure if the first word flash fails\n+                if self.bl_rev >= 3:\n+                        self.__getSync()\n+\n+        # split a sequence into a list of size-constrained pieces\n+        def __split_len(self, seq, length):\n+                return [seq[i:i+length] for i in range(0, len(seq), length)]\n+\n+        # upload code\n+        def __program(self, fw):\n+                code = fw.image\n+                groups = self.__split_len(code, uploader.PROG_MULTI_MAX)\n+                for bytes in groups:\n+                        self.__program_multi(bytes)\n+\n+        # verify code\n+        def __verify_v2(self, fw):\n+                self.__send(uploader.CHIP_VERIFY\n+                            + uploader.EOC)\n+                self.__getSync()\n+                code = fw.image\n+                groups = self.__split_len(code, uploader.READ_MULTI_MAX)\n+                for bytes in groups:\n+                        if (not self.__verify_multi(bytes)):\n+                                raise RuntimeError(\"Verification failed\")\n+\n+        def __verify_v3(self, fw):\n+                expect_crc = fw.crc(self.fw_maxsize)\n+                self.__send(uploader.GET_CRC\n+                            + uploader.EOC)\n+                report_crc = self.__recv_int()\n+                self.__getSync()\n+                if report_crc != expect_crc:\n+                        print(\"Expected 0x%x\" % expect_crc)\n+                        print(\"Got      0x%x\" % report_crc)\n+                        raise RuntimeError(\"Program CRC failed\")\n+\n+        # get basic data about the board\n+        def identify(self):\n+                # make sure we are in sync before starting\n+                self.__sync()\n+\n+                # get the bootloader protocol ID first\n+                self.bl_rev = self.__getInfo(uploader.INFO_BL_REV)\n+                if (self.bl_rev < uploader.BL_REV_MIN) or (self.bl_rev > uploader.BL_REV_MAX):\n+                        print(\"Unsupported bootloader protocol %d\" % uploader.INFO_BL_REV)\n+                        raise RuntimeError(\"Bootloader protocol mismatch\")\n+\n+                self.board_type = self.__getInfo(uploader.INFO_BOARD_ID)\n+                self.board_rev = self.__getInfo(uploader.INFO_BOARD_REV)\n+                self.fw_maxsize = self.__getInfo(uploader.INFO_FLASH_SIZE)\n+\n+        # upload the firmware\n+        def upload(self, fw):\n+                # Make sure we are doing the right thing\n+                if self.board_type != fw.property('board_id'):\n+                        raise RuntimeError(\"Firmware not suitable for this board\")\n+                if self.fw_maxsize < fw.property('image_size'):\n+                        raise RuntimeError(\"Firmware image is too large for this board\")\n+\n+                print(\"erase...\")\n+                self.__erase()\n+\n+                print(\"program...\")\n+                self.__program(fw)\n+\n+                print(\"verify...\")\n+                if self.bl_rev == 2:\n+                        self.__verify_v2(fw)\n+                else:\n+                        self.__verify_v3(fw)\n+\n+                print(\"done, rebooting.\")\n+                self.__reboot()\n+                self.port.close()\n+\n \n # Parse commandline arguments\n parser = argparse.ArgumentParser(description=\"Firmware uploader for the PX autopilot system.\")\n@@ -360,57 +361,57 @@ def upload(self, fw):\n \n # Load the firmware file\n fw = firmware(args.firmware)\n-print((\"Loaded firmware for %x,%x, waiting for the bootloader...\" % (fw.property('board_id'), fw.property('board_revision'))))\n+print(\"Loaded firmware for %x,%x, waiting for the bootloader...\" % (fw.property('board_id'), fw.property('board_revision')))\n \n # Spin waiting for a device to show up\n while True:\n-\tfor port in args.port.split(\",\"):\n-\n-\t\t#print(\"Trying %s\" % port)\n-\n-\t\t# create an uploader attached to the port\n-\t\ttry:\n-\t\t\tif \"linux\" in _platform:\n-\t\t\t# Linux, don't open Mac OS and Win ports\n-\t\t\t\tif not \"COM\" in port and not \"tty.usb\" in port:\n-\t\t\t\t\tup = uploader(port, args.baud)\n-\t\t\telif \"darwin\" in _platform:\n-\t\t\t\t# OS X, don't open Windows and Linux ports\n-\t\t\t\tif not \"COM\" in port and not \"ACM\" in port:\n-\t\t\t\t\tup = uploader(port, args.baud)\n-\t\t\telif \"win\" in _platform:\n-\t\t\t\t# Windows, don't open POSIX ports\n-\t\t\t\tif not \"/\" in port:\n-\t\t\t\t\tup = uploader(port, args.baud)\n-\t\texcept:\n-\t\t\t# open failed, rate-limit our attempts\n-\t\t\ttime.sleep(0.05)\n-\n-\t\t\t# and loop to the next port\n-\t\t\tcontinue\n-\n-\t\t# port is open, try talking to it\n-\t\ttry:\n-\t\t\t# identify the bootloader\n-\t\t\tup.identify()\n-\t\t\tprint((\"Found board %x,%x bootloader rev %x on %s\" % (up.board_type, up.board_rev, up.bl_rev, port)))\n-\n-\t\texcept:\n-\t\t\t# most probably a timeout talking to the port, no bootloader\n-\t\t\tcontinue\n-\n-\t\ttry:\n-\t\t\t# ok, we have a bootloader, try flashing it\n-\t\t\tup.upload(fw)\n-\n-\t\texcept RuntimeError as ex:\n-\n-\t\t\t# print the error\n-\t\t\tprint((\"ERROR: %s\" % ex.args))\n-\n-\t\tfinally:\n-\t\t\t# always close the port\n-\t\t\tup.close()\n-\n-\t\t# we could loop here if we wanted to wait for more boards...\n-\t\tsys.exit(0)\n+        for port in args.port.split(\",\"):\n+\n+                #print(\"Trying %s\" % port)\n+\n+                # create an uploader attached to the port\n+                try:\n+                        if \"linux\" in _platform:\n+                        # Linux, don't open Mac OS and Win ports\n+                                if not \"COM\" in port and not \"tty.usb\" in port:\n+                                        up = uploader(port, args.baud)\n+                        elif \"darwin\" in _platform:\n+                                # OS X, don't open Windows and Linux ports\n+                                if not \"COM\" in port and not \"ACM\" in port:\n+                                        up = uploader(port, args.baud)\n+                        elif \"win\" in _platform:\n+                                # Windows, don't open POSIX ports\n+                                if not \"/\" in port:\n+                                        up = uploader(port, args.baud)\n+                except:\n+                        # open failed, rate-limit our attempts\n+                        time.sleep(0.05)\n+\n+                        # and loop to the next port\n+                        continue\n+\n+                # port is open, try talking to it\n+                try:\n+                        # identify the bootloader\n+                        up.identify()\n+                        print(\"Found board %x,%x bootloader rev %x on %s\" % (up.board_type, up.board_rev, up.bl_rev, port))\n+\n+                except:\n+                        # most probably a timeout talking to the port, no bootloader\n+                        continue\n+\n+                try:\n+                        # ok, we have a bootloader, try flashing it\n+                        up.upload(fw)\n+\n+                except RuntimeError as ex:\n+\n+                        # print the error\n+                        print(\"ERROR: %s\" % ex.args)\n+\n+                finally:\n+                        # always close the port\n+                        up.close()\n+\n+                # we could loop here if we wanted to wait for more boards...\n+                sys.exit(0)"}]}