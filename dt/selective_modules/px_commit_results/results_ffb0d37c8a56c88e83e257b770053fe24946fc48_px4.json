{"sha":"ffb0d37c8a56c88e83e257b770053fe24946fc48","node_id":"MDY6Q29tbWl0NTI5ODc5MDpmZmIwZDM3YzhhNTZjODhlODNlMjU3Yjc3MDA1M2ZlMjQ5NDZmYzQ4","commit":{"author":{"name":"Lorenz Meier","email":"lm@inf.ethz.ch","date":"2016-05-09T21:01:06Z"},"committer":{"name":"Lorenz Meier","email":"lm@inf.ethz.ch","date":"2016-05-09T21:01:54Z"},"message":"Commander: Fix reposition handling,  run faster to allow catching of consecutive commands","tree":{"sha":"d1e862086f4466c65a00418928d1025809ce6707","url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/trees/d1e862086f4466c65a00418928d1025809ce6707"},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/git/commits/ffb0d37c8a56c88e83e257b770053fe24946fc48","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/ffb0d37c8a56c88e83e257b770053fe24946fc48","html_url":"https://github.com/PX4/PX4-Autopilot/commit/ffb0d37c8a56c88e83e257b770053fe24946fc48","comments_url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/ffb0d37c8a56c88e83e257b770053fe24946fc48/comments","author":{"login":"LorenzMeier","id":1208119,"node_id":"MDQ6VXNlcjEyMDgxMTk=","avatar_url":"https://avatars.githubusercontent.com/u/1208119?v=4","gravatar_id":"","url":"https://api.github.com/users/LorenzMeier","html_url":"https://github.com/LorenzMeier","followers_url":"https://api.github.com/users/LorenzMeier/followers","following_url":"https://api.github.com/users/LorenzMeier/following{/other_user}","gists_url":"https://api.github.com/users/LorenzMeier/gists{/gist_id}","starred_url":"https://api.github.com/users/LorenzMeier/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/LorenzMeier/subscriptions","organizations_url":"https://api.github.com/users/LorenzMeier/orgs","repos_url":"https://api.github.com/users/LorenzMeier/repos","events_url":"https://api.github.com/users/LorenzMeier/events{/privacy}","received_events_url":"https://api.github.com/users/LorenzMeier/received_events","type":"User","site_admin":false},"committer":{"login":"LorenzMeier","id":1208119,"node_id":"MDQ6VXNlcjEyMDgxMTk=","avatar_url":"https://avatars.githubusercontent.com/u/1208119?v=4","gravatar_id":"","url":"https://api.github.com/users/LorenzMeier","html_url":"https://github.com/LorenzMeier","followers_url":"https://api.github.com/users/LorenzMeier/followers","following_url":"https://api.github.com/users/LorenzMeier/following{/other_user}","gists_url":"https://api.github.com/users/LorenzMeier/gists{/gist_id}","starred_url":"https://api.github.com/users/LorenzMeier/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/LorenzMeier/subscriptions","organizations_url":"https://api.github.com/users/LorenzMeier/orgs","repos_url":"https://api.github.com/users/LorenzMeier/repos","events_url":"https://api.github.com/users/LorenzMeier/events{/privacy}","received_events_url":"https://api.github.com/users/LorenzMeier/received_events","type":"User","site_admin":false},"parents":[{"sha":"b9333d95f4a090ada153a485558162c43c0286de","url":"https://api.github.com/repos/PX4/PX4-Autopilot/commits/b9333d95f4a090ada153a485558162c43c0286de","html_url":"https://github.com/PX4/PX4-Autopilot/commit/b9333d95f4a090ada153a485558162c43c0286de"}],"stats":{"total":78,"additions":43,"deletions":35},"files":[{"sha":"f451b44d4e43d43180fd95354a0fc9672fd9dd30","filename":"src/modules/commander/commander.cpp","status":"modified","additions":43,"deletions":35,"changes":78,"blob_url":"https://github.com/PX4/PX4-Autopilot/blob/ffb0d37c8a56c88e83e257b770053fe24946fc48/src%2Fmodules%2Fcommander%2Fcommander.cpp","raw_url":"https://github.com/PX4/PX4-Autopilot/raw/ffb0d37c8a56c88e83e257b770053fe24946fc48/src%2Fmodules%2Fcommander%2Fcommander.cpp","contents_url":"https://api.github.com/repos/PX4/PX4-Autopilot/contents/src%2Fmodules%2Fcommander%2Fcommander.cpp?ref=ffb0d37c8a56c88e83e257b770053fe24946fc48","patch":"@@ -138,7 +138,7 @@ extern struct system_load_s system_load;\n static constexpr uint8_t COMMANDER_MAX_GPS_NOISE = 60;\t\t/**< Maximum percentage signal to noise ratio allowed for GPS reception */\n \n /* Decouple update interval and hysteris counters, all depends on intervals */\n-#define COMMANDER_MONITORING_INTERVAL 50000\n+#define COMMANDER_MONITORING_INTERVAL 10000\n #define COMMANDER_MONITORING_LOOPSPERMSEC (1/(COMMANDER_MONITORING_INTERVAL/1000.0f))\n \n #define MAVLINK_OPEN_INTERVAL 50000\n@@ -210,7 +210,8 @@ static struct commander_state_s internal_state = {};\n \n static uint8_t main_state_before_rtl = commander_state_s::MAIN_STATE_MAX;\n static unsigned _last_mission_instance = 0;\n-static manual_control_setpoint_s _last_sp_man = {};\n+struct manual_control_setpoint_s sp_man = {};\t\t///< the current manual control setpoint\n+static manual_control_setpoint_s _last_sp_man = {};\t///< the manual control setpoint valid at the last mode switch\n \n static struct vtol_vehicle_status_s vtol_status = {};\n \n@@ -262,7 +263,7 @@ void get_circuit_breaker_params();\n \n void check_valid(hrt_abstime timestamp, hrt_abstime timeout, bool valid_in, bool *valid_out, bool *changed);\n \n-transition_result_t set_main_state_rc(struct vehicle_status_s *status, struct manual_control_setpoint_s *sp_man);\n+transition_result_t set_main_state_rc(struct vehicle_status_s *status);\n \n void set_control_mode();\n \n@@ -677,7 +678,7 @@ bool handle_command(struct vehicle_status_s *status_local, const struct safety_s\n \t\t// the data at the exact same time.\n \n \t\t// Check if a mode switch had been requested\n-\t\tif ((((uint8_t)cmd->param1) & 1) > 0) {\n+\t\tif ((((uint32_t)cmd->param2) & 1) > 0) {\n \t\t\ttransition_result_t main_ret = main_state_transition(status_local, commander_state_s::MAIN_STATE_AUTO_LOITER, main_state_prev, &status_flags, &internal_state);\n \n \t\t\tif ((main_ret != TRANSITION_DENIED)) {\n@@ -837,12 +838,20 @@ bool handle_command(struct vehicle_status_s *status_local, const struct safety_s\n \t\t\t\telse {\n \n \t\t\t\t\t// Refuse to arm if preflight checks have failed\n-\t\t\t\t\tif ((!status.hil_state) != vehicle_status_s::HIL_STATE_ON && !status_flags.condition_system_sensors_initialized) {\n+\t\t\t\t\tif ((!status_local->hil_state) != vehicle_status_s::HIL_STATE_ON && !status_flags.condition_system_sensors_initialized) {\n \t\t\t\t\t\tmavlink_log_critical(&mavlink_log_pub, \"Arming DENIED. Preflight checks have failed.\");\n \t\t\t\t\t\tcmd_result = vehicle_command_s::VEHICLE_CMD_RESULT_DENIED;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \n+\t\t\t\t\t// Refuse to arm if in manual with non-zero throttle\n+\t\t\t\t\tif ((status_local->nav_state == vehicle_status_s::NAVIGATION_STATE_MANUAL || status_local->nav_state == vehicle_status_s::NAVIGATION_STATE_STAB ||\n+\t\t\t\t\t\tstatus_local->nav_state == vehicle_status_s::NAVIGATION_STATE_ACRO) && sp_man.z > 0.1f) {\n+\t\t\t\t\t\tmavlink_log_critical(&mavlink_log_pub, \"Arming DENIED. Manual throttle non-zero.\");\n+\t\t\t\t\t\tcmd_result = vehicle_command_s::VEHICLE_CMD_RESULT_DENIED;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\n \t\t\t\t}\n \n \t\t\t\ttransition_result_t arming_res = arm_disarm(cmd_arms,&mavlink_log_pub,  \"arm/disarm component command\");\n@@ -1384,7 +1393,6 @@ int commander_thread_main(int argc, char *argv[])\n \n \t/* Subscribe to manual control data */\n \tint sp_man_sub = orb_subscribe(ORB_ID(manual_control_setpoint));\n-\tstruct manual_control_setpoint_s sp_man;\n \tmemset(&sp_man, 0, sizeof(sp_man));\n \n \t/* Subscribe to offboard control data */\n@@ -2446,7 +2454,7 @@ int commander_thread_main(int argc, char *argv[])\n \n \t\t\t/* evaluate the main state machine according to mode switches */\n \t\t\tbool first_rc_eval = (_last_sp_man.timestamp == 0) && (sp_man.timestamp > 0);\n-\t\t\ttransition_result_t main_res = set_main_state_rc(&status, &sp_man);\n+\t\t\ttransition_result_t main_res = set_main_state_rc(&status);\n \n \t\t\t/* play tune on mode change only if armed, blink LED always */\n \t\t\tif (main_res == TRANSITION_CHANGED || first_rc_eval) {\n@@ -2958,7 +2966,7 @@ control_status_leds(vehicle_status_s *status_local, const actuator_armed_s *actu\n }\n \n transition_result_t\n-set_main_state_rc(struct vehicle_status_s *status_local, struct manual_control_setpoint_s *sp_man)\n+set_main_state_rc(struct vehicle_status_s *status_local)\n {\n \t/* set main state according to RC switches */\n \ttransition_result_t res = TRANSITION_DENIED;\n@@ -2971,34 +2979,34 @@ set_main_state_rc(struct vehicle_status_s *status_local, struct manual_control_s\n \t}\n \n \t/* manual setpoint has not updated, do not re-evaluate it */\n-\tif (((_last_sp_man.timestamp != 0) && (_last_sp_man.timestamp == sp_man->timestamp)) ||\n-\t\t((_last_sp_man.offboard_switch == sp_man->offboard_switch) &&\n-\t\t (_last_sp_man.return_switch == sp_man->return_switch) &&\n-\t\t (_last_sp_man.mode_switch == sp_man->mode_switch) &&\n-\t\t (_last_sp_man.acro_switch == sp_man->acro_switch) &&\n-\t\t (_last_sp_man.rattitude_switch == sp_man->rattitude_switch) &&\n-\t\t (_last_sp_man.posctl_switch == sp_man->posctl_switch) &&\n-\t\t (_last_sp_man.loiter_switch == sp_man->loiter_switch) &&\n-\t\t (_last_sp_man.mode_slot == sp_man->mode_slot))) {\n+\tif (((_last_sp_man.timestamp != 0) && (_last_sp_man.timestamp == sp_man.timestamp)) ||\n+\t\t((_last_sp_man.offboard_switch == sp_man.offboard_switch) &&\n+\t\t (_last_sp_man.return_switch == sp_man.return_switch) &&\n+\t\t (_last_sp_man.mode_switch == sp_man.mode_switch) &&\n+\t\t (_last_sp_man.acro_switch == sp_man.acro_switch) &&\n+\t\t (_last_sp_man.rattitude_switch == sp_man.rattitude_switch) &&\n+\t\t (_last_sp_man.posctl_switch == sp_man.posctl_switch) &&\n+\t\t (_last_sp_man.loiter_switch == sp_man.loiter_switch) &&\n+\t\t (_last_sp_man.mode_slot == sp_man.mode_slot))) {\n \n \t\t// update these fields for the geofence system\n \n \t\tif (!rtl_on) {\n-\t\t\t_last_sp_man.timestamp = sp_man->timestamp;\n-\t\t\t_last_sp_man.x = sp_man->x;\n-\t\t\t_last_sp_man.y = sp_man->y;\n-\t\t\t_last_sp_man.z = sp_man->z;\n-\t\t\t_last_sp_man.r = sp_man->r;\n+\t\t\t_last_sp_man.timestamp = sp_man.timestamp;\n+\t\t\t_last_sp_man.x = sp_man.x;\n+\t\t\t_last_sp_man.y = sp_man.y;\n+\t\t\t_last_sp_man.z = sp_man.z;\n+\t\t\t_last_sp_man.r = sp_man.r;\n \t\t}\n \n \t\t/* no timestamp change or no switch change -> nothing changed */\n \t\treturn TRANSITION_NOT_CHANGED;\n \t}\n \n-\t_last_sp_man = *sp_man;\n+\t_last_sp_man = sp_man;\n \n \t/* offboard switch overrides main switch */\n-\tif (sp_man->offboard_switch == manual_control_setpoint_s::SWITCH_POS_ON) {\n+\tif (sp_man.offboard_switch == manual_control_setpoint_s::SWITCH_POS_ON) {\n \t\tres = main_state_transition(status_local, commander_state_s::MAIN_STATE_OFFBOARD, main_state_prev, &status_flags, &internal_state);\n \n \t\tif (res == TRANSITION_DENIED) {\n@@ -3012,7 +3020,7 @@ set_main_state_rc(struct vehicle_status_s *status_local, struct manual_control_s\n \t}\n \n \t/* RTL switch overrides main switch */\n-\tif (sp_man->return_switch == manual_control_setpoint_s::SWITCH_POS_ON) {\n+\tif (sp_man.return_switch == manual_control_setpoint_s::SWITCH_POS_ON) {\n \t\twarnx(\"RTL switch changed and ON!\");\n \t\tres = main_state_transition(status_local, commander_state_s::MAIN_STATE_AUTO_RTL, main_state_prev, &status_flags, &internal_state);\n \n@@ -3032,14 +3040,14 @@ set_main_state_rc(struct vehicle_status_s *status_local, struct manual_control_s\n \t}\n \n \t/* we know something has changed - check if we are in mode slot operation */\n-\tif (sp_man->mode_slot != manual_control_setpoint_s::MODE_SLOT_NONE) {\n+\tif (sp_man.mode_slot != manual_control_setpoint_s::MODE_SLOT_NONE) {\n \n-\t\tif (sp_man->mode_slot >= sizeof(_flight_mode_slots) / sizeof(_flight_mode_slots[0])) {\n-\t\t\twarnx(\"overflow\");\n+\t\tif (sp_man.mode_slot >= sizeof(_flight_mode_slots) / sizeof(_flight_mode_slots[0])) {\n+\t\t\twarnx(\"m slot overflow\");\n \t\t\treturn TRANSITION_DENIED;\n \t\t}\n \n-\t\tint new_mode = _flight_mode_slots[sp_man->mode_slot];\n+\t\tint new_mode = _flight_mode_slots[sp_man.mode_slot];\n \n \t\tif (new_mode < 0) {\n \t\t\t/* slot is unused */\n@@ -3171,13 +3179,13 @@ set_main_state_rc(struct vehicle_status_s *status_local, struct manual_control_s\n \t}\n \n \t/* offboard and RTL switches off or denied, check main mode switch */\n-\tswitch (sp_man->mode_switch) {\n+\tswitch (sp_man.mode_switch) {\n \tcase manual_control_setpoint_s::SWITCH_POS_NONE:\n \t\tres = TRANSITION_NOT_CHANGED;\n \t\tbreak;\n \n \tcase manual_control_setpoint_s::SWITCH_POS_OFF:\t\t// MANUAL\n-\t\tif (sp_man->acro_switch == manual_control_setpoint_s::SWITCH_POS_ON) {\n+\t\tif (sp_man.acro_switch == manual_control_setpoint_s::SWITCH_POS_ON) {\n \n \t\t\t/* manual mode is stabilized already for multirotors, so switch to acro\n \t\t\t * for any non-manual mode\n@@ -3192,7 +3200,7 @@ set_main_state_rc(struct vehicle_status_s *status_local, struct manual_control_s\n \t\t\t}\n \n \t\t}\n-\t\telse if(sp_man->rattitude_switch == manual_control_setpoint_s::SWITCH_POS_ON){\n+\t\telse if(sp_man.rattitude_switch == manual_control_setpoint_s::SWITCH_POS_ON){\n \t\t\t/* Similar to acro transitions for multirotors.  FW aircraft don't need a\n \t\t\t * rattitude mode.*/\n \t\t\tif (status.is_rotary_wing) {\n@@ -3208,7 +3216,7 @@ set_main_state_rc(struct vehicle_status_s *status_local, struct manual_control_s\n \t\tbreak;\n \n \tcase manual_control_setpoint_s::SWITCH_POS_MIDDLE:\t\t// ASSIST\n-\t\tif (sp_man->posctl_switch == manual_control_setpoint_s::SWITCH_POS_ON) {\n+\t\tif (sp_man.posctl_switch == manual_control_setpoint_s::SWITCH_POS_ON) {\n \t\t\tres = main_state_transition(status_local, commander_state_s::MAIN_STATE_POSCTL, main_state_prev, &status_flags, &internal_state);\n \n \t\t\tif (res != TRANSITION_DENIED) {\n@@ -3225,7 +3233,7 @@ set_main_state_rc(struct vehicle_status_s *status_local, struct manual_control_s\n \t\t\tbreak;\t// changed successfully or already in this mode\n \t\t}\n \n-\t\tif (sp_man->posctl_switch != manual_control_setpoint_s::SWITCH_POS_ON) {\n+\t\tif (sp_man.posctl_switch != manual_control_setpoint_s::SWITCH_POS_ON) {\n \t\t\tprint_reject_mode(status_local, \"ALTITUDE CONTROL\");\n \t\t}\n \n@@ -3235,7 +3243,7 @@ set_main_state_rc(struct vehicle_status_s *status_local, struct manual_control_s\n \t\tbreak;\n \n \tcase manual_control_setpoint_s::SWITCH_POS_ON:\t\t\t// AUTO\n-\t\tif (sp_man->loiter_switch == manual_control_setpoint_s::SWITCH_POS_ON) {\n+\t\tif (sp_man.loiter_switch == manual_control_setpoint_s::SWITCH_POS_ON) {\n \t\t\tres = main_state_transition(status_local, commander_state_s::MAIN_STATE_AUTO_LOITER, main_state_prev, &status_flags, &internal_state);\n \n \t\t\tif (res != TRANSITION_DENIED) {"}]}